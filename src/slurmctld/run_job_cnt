port_mgr.c:		step_iterator = list_iterator_create(job_ptr->step_list);
licenses.c:	FREE_NULL_LIST(job_ptr->license_list);
licenses.c:	job_ptr->license_list = _build_license_list(job_ptr->licenses, &valid);
licenses.c:	xfree(job_ptr->licenses);
licenses.c:	job_ptr->licenses = license_list_to_string(job_ptr->license_list);
licenses.c:	if (!job_ptr->license_list)	/* no licenses needed */
licenses.c:	iter = list_iterator_create(job_ptr->license_list);
licenses.c:			      license_entry->name, job_ptr->job_id);
licenses.c:			     job_ptr->job_id, match->name);
licenses.c:	if (!job_ptr->license_list)	/* no licenses needed */
licenses.c:	iter = list_iterator_create(job_ptr->license_list);
licenses.c:			      license_entry->name, job_ptr->job_id);
licenses.c:	if (!job_ptr->license_list)	/* no licenses needed */
licenses.c:	iter = list_iterator_create(job_ptr->license_list);
job_scheduler.c:		xassert (job_ptr->magic == JOB_MAGIC);
job_scheduler.c:		if (job_ptr->user_id != user_id)
job_scheduler.c:		if (job_name && job_ptr->name &&
job_scheduler.c:		    xstrcmp(job_name, job_ptr->name))
job_scheduler.c:	job_queue_rec->array_task_id = job_ptr->array_task_id;
job_scheduler.c:	job_queue_rec->job_id   = job_ptr->job_id;
job_scheduler.c:	step_iterator = list_iterator_create(job_ptr->step_list);
job_scheduler.c:	xassert(job_ptr->magic == JOB_MAGIC);
job_scheduler.c:	select_g_select_jobinfo_get(job_ptr->select_jobinfo,
job_scheduler.c:	    (job_ptr->details && job_ptr->details->prolog_running) ||
job_scheduler.c:	    (job_ptr->step_list && list_count(job_ptr->step_list))) {
job_scheduler.c:		job_ptr->state_reason = WAIT_CLEANING;
job_scheduler.c:		xfree(job_ptr->state_desc);
job_scheduler.c:	if (job_ptr->state_reason == WAIT_FRONT_END) {
job_scheduler.c:		job_ptr->state_reason = WAIT_NO_REASON;
job_scheduler.c:		xfree(job_ptr->state_desc);
job_scheduler.c:		job_ptr->start_time = (time_t) 0;
job_scheduler.c:	if (job_ptr->priority == 0)	{ /* held */
job_scheduler.c:		if (job_ptr->state_reason != FAIL_BAD_CONSTRAINTS
job_scheduler.c:		    && (job_ptr->state_reason != WAIT_RESV_DELETED)
job_scheduler.c:		    && (job_ptr->state_reason != FAIL_BURST_BUFFER_OP)
job_scheduler.c:		    && (job_ptr->state_reason != WAIT_HELD)
job_scheduler.c:		    && (job_ptr->state_reason != WAIT_HELD_USER)
job_scheduler.c:		    && job_ptr->state_reason != WAIT_MAX_REQUEUE) {
job_scheduler.c:			job_ptr->state_reason = WAIT_HELD;
job_scheduler.c:			xfree(job_ptr->state_desc);
job_scheduler.c:			     job_state_string(job_ptr->job_state),
job_scheduler.c:			     job_reason_string(job_ptr->state_reason),
job_scheduler.c:			     job_ptr->priority);
job_scheduler.c:	    ((job_ptr->state_reason == WAIT_HELD) ||
job_scheduler.c:	     (job_ptr->state_reason == WAIT_HELD_USER))) {
job_scheduler.c:		job_ptr->state_reason = WAIT_DEPENDENCY;
job_scheduler.c:		xfree(job_ptr->state_desc);
job_scheduler.c:	if ((reason != job_ptr->state_reason) &&
job_scheduler.c:		job_ptr->state_reason = reason;
job_scheduler.c:		xfree(job_ptr->state_desc);
job_scheduler.c:	if (job_ptr->resv_ptr && job_ptr->resv_ptr->node_bitmap &&
job_scheduler.c:	    (bit_overlap(job_ptr->resv_ptr->node_bitmap, part_ptr->node_bitmap)
job_scheduler.c:	     < job_ptr->node_cnt_wag))
job_scheduler.c:		    !job_ptr->burst_buffer || !job_ptr->array_recs ||
job_scheduler.c:		    !job_ptr->array_recs->task_id_bitmap ||
job_scheduler.c:		    (job_ptr->array_task_id != NO_VAL))
job_scheduler.c:		if ((i = bit_ffs(job_ptr->array_recs->task_id_bitmap)) < 0)
job_scheduler.c:		pend_cnt = num_pending_job_array_tasks(job_ptr->array_job_id);
job_scheduler.c:		if (job_ptr->array_recs->task_cnt < 1)
job_scheduler.c:		if (job_ptr->array_recs->task_cnt == 1) {
job_scheduler.c:			job_ptr->array_task_id = i;
job_scheduler.c:		job_ptr->array_task_id = i;
job_scheduler.c:			new_job_ptr->job_state = JOB_PENDING;
job_scheduler.c:			new_job_ptr->start_time = (time_t) 0;
job_scheduler.c:		    !job_ptr->array_recs ||
job_scheduler.c:		    !job_ptr->array_recs->task_id_bitmap ||
job_scheduler.c:		    (job_ptr->array_task_id != NO_VAL))
job_scheduler.c:		if ((i = bit_ffs(job_ptr->array_recs->task_id_bitmap)) < 0)
job_scheduler.c:		if ((job_ptr->details == NULL) ||
job_scheduler.c:		    (job_ptr->details->depend_list == NULL) ||
job_scheduler.c:		    (list_count(job_ptr->details->depend_list) == 0))
job_scheduler.c:			job_ptr->details->depend_list);
job_scheduler.c:		pend_cnt = num_pending_job_array_tasks(job_ptr->array_job_id);
job_scheduler.c:		if (job_ptr->array_recs->task_cnt < 1)
job_scheduler.c:		if (job_ptr->array_recs->task_cnt == 1) {
job_scheduler.c:			job_ptr->array_task_id = i;
job_scheduler.c:		job_ptr->array_task_id = i;
job_scheduler.c:			new_job_ptr->job_state = JOB_PENDING;
job_scheduler.c:			new_job_ptr->start_time = (time_t) 0;
job_scheduler.c:		job_ptr->preempt_in_progress = false;	/* initialize */
job_scheduler.c:		if (job_ptr->state_reason != WAIT_NO_REASON) {
job_scheduler.c:			job_ptr->state_reason_prev = job_ptr->state_reason;
job_scheduler.c:			if ((job_ptr->state_reason != WAIT_PRIORITY) &&
job_scheduler.c:			    (job_ptr->state_reason != WAIT_RESOURCES))
job_scheduler.c:				job_ptr->state_reason_prev_db =
job_scheduler.c:					job_ptr->state_reason;
job_scheduler.c:		} else if ((job_ptr->state_reason_prev == WAIT_TIME) &&
job_scheduler.c:			   job_ptr->details &&
job_scheduler.c:			   (job_ptr->details->begin_time <= now)) {
job_scheduler.c:			job_ptr->state_reason_prev = job_ptr->state_reason;
job_scheduler.c:			if ((job_ptr->state_reason != WAIT_PRIORITY) &&
job_scheduler.c:			    (job_ptr->state_reason != WAIT_RESOURCES))
job_scheduler.c:				job_ptr->state_reason_prev_db =
job_scheduler.c:					job_ptr->state_reason;
job_scheduler.c:		if (job_ptr->part_ptr_list) {
job_scheduler.c:				job_ptr->part_ptr_list);
job_scheduler.c:				job_ptr->part_ptr = part_ptr;
job_scheduler.c:				    (reason != job_ptr->state_reason)) {
job_scheduler.c:					job_ptr->state_reason = reason;
job_scheduler.c:					xfree(job_ptr->state_desc);
job_scheduler.c:				if (job_ptr->priority_array) {
job_scheduler.c:							  job_ptr->
job_scheduler.c:							  job_ptr->priority);
job_scheduler.c:			if (job_ptr->part_ptr == NULL) {
job_scheduler.c:				part_ptr = find_part_record(job_ptr->partition);
job_scheduler.c:					      job_ptr->partition, job_ptr);
job_scheduler.c:				job_ptr->part_ptr = part_ptr;
job_scheduler.c:				      job_ptr, job_ptr->partition);
job_scheduler.c:					  job_ptr->part_ptr, job_ptr->priority);
job_scheduler.c:		    (job_ptr->end_time >= recent)) {
job_scheduler.c:			else if (job_ptr->part_ptr)
job_scheduler.c:				       job_ptr->part_ptr->node_bitmap);
job_scheduler.c:		part_ptr = job_ptr->part_ptr;
job_scheduler.c:		if ((job_ptr->details == NULL) ||
job_scheduler.c:		    (job_ptr->details->begin_time > now))
job_scheduler.c:		if ((job_ptr->time_limit != NO_VAL) &&
job_scheduler.c:		    (job_ptr->time_limit > part_ptr->max_time))
job_scheduler.c:		if ((job_ptr->details->max_nodes != 0) &&
job_scheduler.c:		    ((job_ptr->details->max_nodes < part_ptr->min_nodes) ||
job_scheduler.c:		     (job_ptr->details->min_nodes > part_ptr->max_nodes)))
job_scheduler.c:	if ((job_ptr->time_min) && (job_ptr->time_min != NO_VAL)) {
job_scheduler.c:		inter = now + job_ptr->time_min * 60;
job_scheduler.c:		if (job_ptr->deadline < inter) {
job_scheduler.c:			slurm_make_time_str(&job_ptr->deadline,
job_scheduler.c:			     __func__, job_ptr, job_ptr->time_min,
job_scheduler.c:	} else if ((job_ptr->time_limit != NO_VAL) &&
job_scheduler.c:		   (job_ptr->time_limit != INFINITE)) {
job_scheduler.c:		inter = now + job_ptr->time_limit * 60;
job_scheduler.c:		if (job_ptr->deadline < inter) {
job_scheduler.c:			slurm_make_time_str(&job_ptr->deadline,
job_scheduler.c:			     __func__, job_ptr, job_ptr->time_limit,
job_scheduler.c:		job_ptr->job_state = JOB_DEADLINE;
job_scheduler.c:		job_ptr->exit_code = 1;
job_scheduler.c:		job_ptr->state_reason = FAIL_DEADLINE;
job_scheduler.c:		xfree(job_ptr->state_desc);
job_scheduler.c:		job_ptr->start_time = now;
job_scheduler.c:		job_ptr->end_time = now;
job_scheduler.c:			if ((job_ptr->state_reason != WAIT_NO_REASON) &&
job_scheduler.c:			    (job_ptr->state_reason != WAIT_RESOURCES) &&
job_scheduler.c:			    (job_ptr->state_reason != WAIT_POWER_NOT_AVAIL) &&
job_scheduler.c:			    (job_ptr->state_reason != WAIT_POWER_RESERVED) &&
job_scheduler.c:			    (job_ptr->state_reason != WAIT_NODE_NOT_AVAIL))
job_scheduler.c:			job_ptr->state_reason = WAIT_FRONT_END;
job_scheduler.c:			xfree(job_ptr->state_desc);
job_scheduler.c:				job_ptr->state_reason = WAIT_FRONT_END;
job_scheduler.c:				xfree(job_ptr->state_desc);
job_scheduler.c:			if (job_ptr->part_ptr_list) {
job_scheduler.c:					job_ptr->part_ptr_list);
job_scheduler.c:					job_ptr->part_ptr = part_ptr;
job_scheduler.c:			job_ptr->priority = job_queue_rec->priority;
job_scheduler.c:				job_ptr->state_reason = WAIT_FRONT_END;
job_scheduler.c:				xfree(job_ptr->state_desc);
job_scheduler.c:			if ((job_ptr->array_task_id != array_task_id) &&
job_scheduler.c:				job_ptr = find_job_record(job_ptr->array_job_id);
job_scheduler.c:			job_ptr->part_ptr = part_ptr;
job_scheduler.c:		job_ptr->last_sched_eval = time(NULL);
job_scheduler.c:		if (job_ptr->preempt_in_progress)
job_scheduler.c:		if (job_ptr->pack_job_id) {
job_scheduler.c:		if (job_ptr->array_recs && (job_ptr->array_task_id == NO_VAL))
job_scheduler.c:		if ((job_ptr->array_task_id != NO_VAL) || job_ptr->array_recs) {
job_scheduler.c:			if ((reject_array_job_id == job_ptr->array_job_id) &&
job_scheduler.c:			    (reject_array_part   == job_ptr->part_ptr)) {
job_scheduler.c:				xfree(job_ptr->state_desc);
job_scheduler.c:				job_ptr->state_reason = reject_state_reason;
job_scheduler.c:			reject_array_job_id = job_ptr->array_job_id;
job_scheduler.c:			reject_array_part   = job_ptr->part_ptr;
job_scheduler.c:				reject_state_reason = job_ptr->state_reason;
job_scheduler.c:				if (sched_part_ptr[j] != job_ptr->part_ptr)
job_scheduler.c:				if (job_ptr->part_ptr == skip_part_ptr)
job_scheduler.c:					     job_ptr->part_ptr->name);
job_scheduler.c:				if (job_ptr->state_reason == WAIT_NO_REASON) {
job_scheduler.c:					xfree(job_ptr->state_desc);
job_scheduler.c:					job_ptr->state_reason = WAIT_PRIORITY;
job_scheduler.c:				skip_part_ptr = job_ptr->part_ptr;
job_scheduler.c:		if (job_ptr->resv_name) {
job_scheduler.c:				if (failed_resv[i] == job_ptr->resv_ptr) {
job_scheduler.c:				job_ptr->state_reason = WAIT_PRIORITY;
job_scheduler.c:				xfree(job_ptr->state_desc);
job_scheduler.c:					     job_ptr->priority,
job_scheduler.c:					     job_ptr->resv_name);
job_scheduler.c:		} else if (_failed_partition(job_ptr->part_ptr, failed_parts,
job_scheduler.c:			job_ptr->state_reason = WAIT_PRIORITY;
job_scheduler.c:			xfree(job_ptr->state_desc);
job_scheduler.c:				    job_ptr, job_ptr->priority,
job_scheduler.c:				    job_ptr->partition);
job_scheduler.c:		if (job_ptr->state_reason == FAIL_ACCOUNT) {
job_scheduler.c:			assoc_rec.acct      = job_ptr->account;
job_scheduler.c:			if (job_ptr->part_ptr)
job_scheduler.c:				assoc_rec.partition = job_ptr->part_ptr->name;
job_scheduler.c:			assoc_rec.uid       = job_ptr->user_id;
job_scheduler.c:						     &job_ptr->assoc_ptr,
job_scheduler.c:				job_ptr->state_reason = WAIT_NO_REASON;
job_scheduler.c:				xfree(job_ptr->state_desc);
job_scheduler.c:				job_ptr->assoc_id = assoc_rec.id;
job_scheduler.c:				xfree(job_ptr->state_desc);
job_scheduler.c:				job_ptr->state_reason =
job_scheduler.c:		if (job_ptr->qos_id) {
job_scheduler.c:			if (job_ptr->assoc_ptr
job_scheduler.c:			    && ((job_ptr->qos_id >= g_qos_count) ||
job_scheduler.c:				!job_ptr->assoc_ptr->usage ||
job_scheduler.c:				!job_ptr->assoc_ptr->usage->valid_qos ||
job_scheduler.c:				!bit_test(job_ptr->assoc_ptr->usage->valid_qos,
job_scheduler.c:					  job_ptr->qos_id))
job_scheduler.c:			    && !job_ptr->limit_set.qos) {
job_scheduler.c:				xfree(job_ptr->state_desc);
job_scheduler.c:				job_ptr->state_reason = FAIL_QOS;
job_scheduler.c:			} else if (job_ptr->state_reason == FAIL_QOS) {
job_scheduler.c:				xfree(job_ptr->state_desc);
job_scheduler.c:				job_ptr->state_reason = WAIT_NO_REASON;
job_scheduler.c:		if ((job_ptr->deadline) && (job_ptr->deadline != NO_VAL)) {
job_scheduler.c:			deadline_time_limit = job_ptr->deadline - now;
job_scheduler.c:			if ((job_ptr->time_limit != NO_VAL) &&
job_scheduler.c:			    (job_ptr->time_limit != INFINITE)) {
job_scheduler.c:				deadline_time_limit = MIN(job_ptr->time_limit,
job_scheduler.c:				if ((job_ptr->part_ptr->default_time != NO_VAL) &&
job_scheduler.c:				    (job_ptr->part_ptr->default_time != INFINITE)){
job_scheduler.c:						job_ptr->part_ptr->default_time,
job_scheduler.c:				} else if ((job_ptr->part_ptr->max_time != NO_VAL) &&
job_scheduler.c:					   (job_ptr->part_ptr->max_time != INFINITE)){
job_scheduler.c:						job_ptr->part_ptr->max_time,
job_scheduler.c:		if ((job_ptr->state_reason == WAIT_NODE_NOT_AVAIL) &&
job_scheduler.c:		    job_ptr->details && job_ptr->details->req_node_bitmap &&
job_scheduler.c:		    !bit_super_set(job_ptr->details->req_node_bitmap,
job_scheduler.c:		if (!job_ptr->part_ptr)
job_scheduler.c:				job_ptr->part_ptr->node_bitmap);
job_scheduler.c:		if ((job_ptr->details &&
job_scheduler.c:		     (job_ptr->details->min_nodes != NO_VAL) &&
job_scheduler.c:		     (job_ptr->details->min_nodes >  i)) ||
job_scheduler.c:		    (!job_ptr->details && (i == 0))) {
job_scheduler.c:			job_ptr->state_reason = WAIT_RESOURCES;
job_scheduler.c:			xfree(job_ptr->state_desc);
job_scheduler.c:			job_ptr->state_desc = xstrdup("Nodes required for job are DOWN, DRAINED or reserved for jobs in higher priority partitions");
job_scheduler.c:				     job_state_string(job_ptr->job_state),
job_scheduler.c:				     job_reason_string(job_ptr->state_reason),
job_scheduler.c:				     job_ptr->priority, job_ptr->partition);
job_scheduler.c:			job_ptr->state_reason = WAIT_LICENSES;
job_scheduler.c:			xfree(job_ptr->state_desc);
job_scheduler.c:				     job_state_string(job_ptr->job_state),
job_scheduler.c:				     job_reason_string(job_ptr->state_reason),
job_scheduler.c:				     job_ptr->priority);
job_scheduler.c:						job_ptr->assoc_id,
job_scheduler.c:			job_ptr->state_reason = FAIL_ACCOUNT;
job_scheduler.c:			xfree(job_ptr->state_desc);
job_scheduler.c:					   job_ptr->start_time);
job_scheduler.c:			save_time_limit = job_ptr->time_limit;
job_scheduler.c:			job_ptr->time_limit = deadline_time_limit;
job_scheduler.c:			fed_mgr_job_start(job_ptr, job_ptr->start_time);
job_scheduler.c:			job_ptr->time_limit = save_time_limit;
job_scheduler.c:				     job_state_string(job_ptr->job_state),
job_scheduler.c:				     job_reason_string(job_ptr->state_reason),
job_scheduler.c:				     job_ptr->priority, job_ptr->partition);
job_scheduler.c:			if (job_ptr->start_time == 0) {
job_scheduler.c:				job_ptr->start_time = last_job_sched_start;
job_scheduler.c:				     job_state_string(job_ptr->job_state),
job_scheduler.c:				     job_reason_string(job_ptr->state_reason),
job_scheduler.c:				     job_ptr->priority);
job_scheduler.c:			if (job_ptr->resv_ptr &&
job_scheduler.c:			    job_ptr->resv_ptr->node_bitmap) {
job_scheduler.c:					     job_state_string(job_ptr->job_state),
job_scheduler.c:					     job_reason_string(job_ptr->state_reason),
job_scheduler.c:					     job_ptr->priority);
job_scheduler.c:					    job_ptr->resv_ptr->node_bitmap);
job_scheduler.c:					     job_state_string(job_ptr->job_state),
job_scheduler.c:					     job_ptr->priority);
job_scheduler.c:			job_ptr->state_reason = WAIT_FED_JOB_LOCK;
job_scheduler.c:			xfree(job_ptr->state_desc);
job_scheduler.c:				     job_state_string(job_ptr->job_state),
job_scheduler.c:				     job_reason_string(job_ptr->state_reason),
job_scheduler.c:				     job_ptr->priority, job_ptr->partition);
job_scheduler.c:				   job_ptr, job_ptr->nodes,
job_scheduler.c:				   job_ptr->total_cpus,
job_scheduler.c:				   job_ptr->part_ptr->name);
job_scheduler.c:			if (job_ptr->batch_flag == 0)
job_scheduler.c:			    (job_ptr->array_task_id != NO_VAL)) {
job_scheduler.c:				job_ptr = find_job_record(job_ptr->array_job_id);
job_scheduler.c:			   job_ptr->part_ptr_list) {
job_scheduler.c:			      job_ptr, job_ptr->part_ptr->name,
job_scheduler.c:			job_ptr->job_state = JOB_PENDING;
job_scheduler.c:			job_ptr->state_reason = FAIL_BAD_CONSTRAINTS;
job_scheduler.c:			xfree(job_ptr->state_desc);
job_scheduler.c:			job_ptr->start_time = job_ptr->end_time = now;
job_scheduler.c:			job_ptr->priority = 0;
job_scheduler.c:			       job_reason_string(job_ptr->state_reason),
job_scheduler.c:		if (job_ptr->details && job_ptr->details->req_node_bitmap &&
job_scheduler.c:		    (bit_set_count(job_ptr->details->req_node_bitmap) >=
job_scheduler.c:		     job_ptr->details->min_nodes)) {
job_scheduler.c:				    job_ptr->details->req_node_bitmap);
job_scheduler.c:		if (fail_by_part && job_ptr->resv_name) {
job_scheduler.c:					job_ptr->resv_ptr;
job_scheduler.c:			if (job_ptr->details->begin_time == 0) {
job_scheduler.c:					now, job_ptr->details->begin_time);
job_scheduler.c:		    (job_ptr->priority < prio_reserve))
job_scheduler.c:				if (failed_parts[i] == job_ptr->part_ptr) {
job_scheduler.c:			failed_parts[failed_part_cnt++] = job_ptr->part_ptr;
job_scheduler.c:				    job_ptr->part_ptr->node_bitmap);
job_scheduler.c:		if ((reject_array_job_id == job_ptr->array_job_id) &&
job_scheduler.c:		    (reject_array_part   == job_ptr->part_ptr)) {
job_scheduler.c:			reject_state_reason = job_ptr->state_reason;
job_scheduler.c:	if (bf_hetjob_prio && job_rec1->job_ptr->pack_job_id &&
job_scheduler.c:	    (job_rec1->job_ptr->pack_job_id !=
job_scheduler.c:	     job_rec2->job_ptr->pack_job_id)) {
job_scheduler.c:		if ((details = job_rec1->job_ptr->pack_details))
job_scheduler.c:			has_resv1 = (job_rec1->job_ptr->resv_id != 0);
job_scheduler.c:		has_resv1 = (job_rec1->job_ptr->resv_id != 0);
job_scheduler.c:	if (bf_hetjob_prio && job_rec2->job_ptr->pack_job_id &&
job_scheduler.c:	    (job_rec2->job_ptr->pack_job_id !=
job_scheduler.c:	     job_rec1->job_ptr->pack_job_id)) {
job_scheduler.c:		if ((details = job_rec2->job_ptr->pack_details))
job_scheduler.c:			has_resv2 = (job_rec2->job_ptr->resv_id != 0);
job_scheduler.c:		has_resv2 = (job_rec2->job_ptr->resv_id != 0);
job_scheduler.c:		if (bf_hetjob_prio && job_rec1->job_ptr->pack_job_id &&
job_scheduler.c:		    (job_rec1->job_ptr->pack_job_id !=
job_scheduler.c:		     job_rec2->job_ptr->pack_job_id)) {
job_scheduler.c:			if ((details = job_rec1->job_ptr->pack_details))
job_scheduler.c:		if (bf_hetjob_prio && job_rec2->job_ptr->pack_job_id &&
job_scheduler.c:		    (job_rec2->job_ptr->pack_job_id !=
job_scheduler.c:		     job_rec1->job_ptr->pack_job_id)) {
job_scheduler.c:			if ((details = job_rec2->job_ptr->pack_details))
job_scheduler.c:	if (bf_hetjob_prio && job_rec1->job_ptr->pack_job_id &&
job_scheduler.c:	    (job_rec1->job_ptr->pack_job_id !=
job_scheduler.c:	     job_rec2->job_ptr->pack_job_id)) {
job_scheduler.c:		if ((details = job_rec1->job_ptr->pack_details))
job_scheduler.c:			if (job_rec1->job_ptr->part_ptr_list &&
job_scheduler.c:			    job_rec1->job_ptr->priority_array)
job_scheduler.c:				p1 = job_rec1->job_ptr->priority;
job_scheduler.c:		if (job_rec1->job_ptr->part_ptr_list &&
job_scheduler.c:		    job_rec1->job_ptr->priority_array)
job_scheduler.c:			p1 = job_rec1->job_ptr->priority;
job_scheduler.c:	if (bf_hetjob_prio && job_rec2->job_ptr->pack_job_id &&
job_scheduler.c:	    (job_rec2->job_ptr->pack_job_id !=
job_scheduler.c:	     job_rec1->job_ptr->pack_job_id)) {
job_scheduler.c:		if ((details = job_rec2->job_ptr->pack_details))
job_scheduler.c:			if (job_rec2->job_ptr->part_ptr_list &&
job_scheduler.c:			    job_rec2->job_ptr->priority_array)
job_scheduler.c:				p2 = job_rec2->job_ptr->priority;
job_scheduler.c:		if (job_rec2->job_ptr->part_ptr_list &&
job_scheduler.c:		    job_rec2->job_ptr->priority_array)
job_scheduler.c:			p2 = job_rec2->job_ptr->priority;
job_scheduler.c:	if (job_rec1->job_ptr->details && job_rec2->job_ptr->details) {
job_scheduler.c:		if (job_rec1->job_ptr->details->submit_time >
job_scheduler.c:		    job_rec2->job_ptr->details->submit_time)
job_scheduler.c:		if (job_rec2->job_ptr->details->submit_time >
job_scheduler.c:		    job_rec1->job_ptr->details->submit_time)
job_scheduler.c:		job_id1 = job_rec1->job_ptr->array_job_id;
job_scheduler.c:		job_id2 = job_rec2->job_ptr->array_job_id;
job_scheduler.c:	launch_msg_ptr->job_id = job_ptr->job_id;
job_scheduler.c:	launch_msg_ptr->pack_jobid = job_ptr->pack_job_id;
job_scheduler.c:	launch_msg_ptr->array_job_id = job_ptr->array_job_id;
job_scheduler.c:	launch_msg_ptr->array_task_id = job_ptr->array_task_id;
job_scheduler.c:	launch_msg_ptr->uid = job_ptr->user_id;
job_scheduler.c:	launch_msg_ptr->gid = job_ptr->group_id;
job_scheduler.c:		job_complete(job_ptr->job_id, slurmctld_conf.slurm_user_id,
job_scheduler.c:	launch_msg_ptr->ntasks = job_ptr->details->num_tasks;
job_scheduler.c:	launch_msg_ptr->alias_list = xstrdup(job_ptr->alias_list);
job_scheduler.c:	launch_msg_ptr->nodes = xstrdup(job_ptr->nodes);
job_scheduler.c:	launch_msg_ptr->overcommit = job_ptr->details->overcommit;
job_scheduler.c:	launch_msg_ptr->open_mode  = job_ptr->details->open_mode;
job_scheduler.c:	launch_msg_ptr->cpus_per_task = job_ptr->details->cpus_per_task;
job_scheduler.c:	launch_msg_ptr->pn_min_memory = job_ptr->details->pn_min_memory;
job_scheduler.c:	launch_msg_ptr->restart_cnt   = job_ptr->restart_cnt;
job_scheduler.c:	launch_msg_ptr->profile       = job_ptr->profile;
job_scheduler.c:		job_ptr->batch_flag = 1;	/* Allow repeated requeue */
job_scheduler.c:		job_ptr->details->begin_time = time(NULL) + 120;
job_scheduler.c:		job_complete(job_ptr->job_id, slurmctld_conf.slurm_user_id,
job_scheduler.c:	launch_msg_ptr->acctg_freq = xstrdup(job_ptr->details->acctg_freq);
job_scheduler.c:	if (job_ptr->part_ptr)
job_scheduler.c:		launch_msg_ptr->partition = xstrdup(job_ptr->part_ptr->name);
job_scheduler.c:		launch_msg_ptr->partition = xstrdup(job_ptr->partition);
job_scheduler.c:	launch_msg_ptr->std_err = xstrdup(job_ptr->details->std_err);
job_scheduler.c:	launch_msg_ptr->std_in = xstrdup(job_ptr->details->std_in);
job_scheduler.c:	launch_msg_ptr->std_out = xstrdup(job_ptr->details->std_out);
job_scheduler.c:	launch_msg_ptr->work_dir = xstrdup(job_ptr->details->work_dir);
job_scheduler.c:	launch_msg_ptr->ckpt_dir = xstrdup(job_ptr->details->ckpt_dir);
job_scheduler.c:	launch_msg_ptr->restart_dir = xstrdup(job_ptr->details->restart_dir);
job_scheduler.c:	launch_msg_ptr->argc = job_ptr->details->argc;
job_scheduler.c:	launch_msg_ptr->argv = xduparray(job_ptr->details->argc,
job_scheduler.c:					 job_ptr->details->argv);
job_scheduler.c:	launch_msg_ptr->spank_job_env_size = job_ptr->spank_job_env_size;
job_scheduler.c:	launch_msg_ptr->spank_job_env = xduparray(job_ptr->spank_job_env_size,
job_scheduler.c:						  job_ptr->spank_job_env);
job_scheduler.c:		job_complete(job_ptr->job_id, slurmctld_conf.slurm_user_id,
job_scheduler.c:	launch_msg_ptr->job_mem = job_ptr->details->pn_min_memory;
job_scheduler.c:	launch_msg_ptr->num_cpu_groups = job_ptr->job_resrcs->cpu_array_cnt;
job_scheduler.c:		sizeof(uint16_t) * job_ptr->job_resrcs->cpu_array_cnt);
job_scheduler.c:	       job_ptr->job_resrcs->cpu_array_value,
job_scheduler.c:	       (sizeof(uint16_t) * job_ptr->job_resrcs->cpu_array_cnt));
job_scheduler.c:		sizeof(uint32_t) * job_ptr->job_resrcs->cpu_array_cnt);
job_scheduler.c:	       job_ptr->job_resrcs->cpu_array_reps,
job_scheduler.c:	       (sizeof(uint32_t) * job_ptr->job_resrcs->cpu_array_cnt));
job_scheduler.c:		job_ptr->select_jobinfo);
job_scheduler.c:	if (job_ptr->qos_ptr) {
job_scheduler.c:		if (!xstrcmp(job_ptr->qos_ptr->description,
job_scheduler.c:				job_ptr->qos_ptr->description);
job_scheduler.c:	launch_msg_ptr->account = xstrdup(job_ptr->account);
job_scheduler.c:	launch_msg_ptr->resv_name = xstrdup(job_ptr->resv_name);
job_scheduler.c:	if (job_ptr->pack_job_id == 0)	/* Not a pack job */
job_scheduler.c:	pack_leader = find_job_record(job_ptr->pack_job_id);
job_scheduler.c:		if (job_ptr->details)
job_scheduler.c:		if ((job_ptr->batch_flag == 0) ||
job_scheduler.c:	if (job_ptr->total_cpus == 0)
job_scheduler.c:	front_end_ptr = find_front_end_record(job_ptr->batch_host);
job_scheduler.c:	node_ptr = find_node_record(job_ptr->batch_host);
job_scheduler.c:	if (launch_job_ptr->pack_job_id)
job_scheduler.c:	xassert(job_ptr->batch_host);
job_scheduler.c:	agent_arg_ptr->hostlist = hostlist_create(launch_job_ptr->batch_host);
job_scheduler.c:	xassert(job_ptr->job_resrcs);
job_scheduler.c:	job_resrcs_ptr = job_ptr->job_resrcs;
job_scheduler.c:	if (job_ptr->job_resrcs == NULL) {
job_scheduler.c:	cred_arg.x11       = job_ptr->details->x11;
job_scheduler.c:	cred_arg.job_constraints     = job_ptr->details->features;
job_scheduler.c:	cred_arg.job_core_spec       = job_ptr->details->core_spec;
job_scheduler.c:	cred_arg.job_mem_limit       = job_ptr->details->pn_min_memory;
job_scheduler.c:	cred_arg.job_gres_list       = job_ptr->gres_list;
job_scheduler.c:	xassert(job_ptr->batch_host);
job_scheduler.c:	cred_arg.step_hostlist       = job_ptr->batch_host;
job_scheduler.c:	cred_arg.step_mem_limit      = job_ptr->details->pn_min_memory;
job_scheduler.c:/* Print a job's dependency information based upon job_ptr->depend_list */
job_scheduler.c:	if ((job_ptr->details == NULL) ||
job_scheduler.c:	    (job_ptr->details->depend_list == NULL))
job_scheduler.c:	depend_iter = list_iterator_create(job_ptr->details->depend_list);
job_scheduler.c:	if (job_ptr->details == NULL)
job_scheduler.c:	xfree(job_ptr->details->dependency);
job_scheduler.c:	if (job_ptr->details->depend_list == NULL
job_scheduler.c:	    || list_count(job_ptr->details->depend_list) == 0)
job_scheduler.c:	depend_iter = list_iterator_create(job_ptr->details->depend_list);
job_scheduler.c:			xstrfmtcat(job_ptr->details->dependency,
job_scheduler.c:			xstrfmtcat(job_ptr->details->dependency, "%s%s:%u_*",
job_scheduler.c:			xstrfmtcat(job_ptr->details->dependency, "%s%s:%u",
job_scheduler.c:			xstrfmtcat(job_ptr->details->dependency, "%s%s:%u_%u",
job_scheduler.c:	if ((job_ptr->details == NULL) ||
job_scheduler.c:	    (job_ptr->details->depend_list == NULL) ||
job_scheduler.c:	    (list_count(job_ptr->details->depend_list) == 0)) {
job_scheduler.c:		job_ptr->bit_flags &= ~JOB_DEPENDENT;
job_scheduler.c:	depend_iter = list_iterator_create(job_ptr->details->depend_list);
job_scheduler.c:		    job_ptr->name) {
job_scheduler.c:			job_queue = _build_user_job_list(job_ptr->user_id,
job_scheduler.c:							 job_ptr->name);
job_scheduler.c:				     (qjob_ptr->job_id < job_ptr->job_id))) {
job_scheduler.c:			   (djob_ptr->magic != JOB_MAGIC) ||
job_scheduler.c:			   ((djob_ptr->job_id != dep_ptr->job_id) &&
job_scheduler.c:			    (djob_ptr->array_job_id != dep_ptr->job_id))) {
job_scheduler.c:				if (dep_ptr->job_ptr->job_state &
job_scheduler.c:				if ((job_ptr->array_task_id == NO_VAL) ||
job_scheduler.c:				    (job_ptr->array_task_id == INFINITE)) {
job_scheduler.c:						job_ptr->array_task_id);
job_scheduler.c:					else if (job_ptr->array_recs &&
job_scheduler.c:						 (job_ptr->array_task_id ==
job_scheduler.c:			if (djob_ptr->job_state & JOB_SPECIAL_EXIT)
job_scheduler.c:			else if ((djob_ptr->end_time != 0) &&
job_scheduler.c:				 (djob_ptr->end_time > now)) {
job_scheduler.c:				job_ptr->time_limit = djob_ptr->end_time - now;
job_scheduler.c:				job_ptr->time_limit /= 60;  /* sec to min */
job_scheduler.c:			if (!failure && job_ptr->details && djob_ptr->details) {
job_scheduler.c:				job_ptr->details->share_res =
job_scheduler.c:					djob_ptr->details->share_res;
job_scheduler.c:				job_ptr->details->whole_node =
job_scheduler.c:					djob_ptr->details->whole_node;
job_scheduler.c:			job_ptr->bit_flags |= INVALID_DEPEND;
job_scheduler.c:				job_ptr->bit_flags &= ~INVALID_DEPEND;
job_scheduler.c:				if (job_ptr->state_reason == WAIT_DEP_INVALID) {
job_scheduler.c:					job_ptr->state_reason = WAIT_NO_REASON;
job_scheduler.c:					xfree(job_ptr->state_desc);
job_scheduler.c:			if (!(job_ptr->bit_flags & INVALID_DEPEND))
job_scheduler.c:		list_flush(job_ptr->details->depend_list);
job_scheduler.c:		job_ptr->bit_flags |= JOB_DEPENDENT;
job_scheduler.c:		job_ptr->bit_flags &= ~JOB_DEPENDENT;
job_scheduler.c:	xfree(job_ptr->cpus_per_tres);
job_scheduler.c:	job_ptr->cpus_per_tres = xstrdup(dep_job_ptr->cpus_per_tres);
job_scheduler.c:	xfree(job_ptr->tres_per_job);
job_scheduler.c:	job_ptr->tres_per_job = xstrdup(dep_job_ptr->tres_per_job);
job_scheduler.c:	xfree(job_ptr->tres_per_node);
job_scheduler.c:	job_ptr->tres_per_node = xstrdup(dep_job_ptr->tres_per_node);
job_scheduler.c:	xfree(job_ptr->tres_per_socket);
job_scheduler.c:	job_ptr->tres_per_socket = xstrdup(dep_job_ptr->tres_per_socket);
job_scheduler.c:	xfree(job_ptr->tres_per_task);
job_scheduler.c:	job_ptr->tres_per_task = xstrdup(dep_job_ptr->tres_per_task);
job_scheduler.c:	xfree(job_ptr->mem_per_tres);
job_scheduler.c:	job_ptr->mem_per_tres = xstrdup(dep_job_ptr->mem_per_tres);
job_scheduler.c:	if (job_ptr->details == NULL)
job_scheduler.c:	job_ptr->details->expanding_jobid = 0;
job_scheduler.c:		xfree(job_ptr->details->dependency);
job_scheduler.c:		FREE_NULL_LIST(job_ptr->details->depend_list);
job_scheduler.c:			    (job_id == 0) || (job_id == job_ptr->job_id) ||
job_scheduler.c:				    (dep_job_ptr->array_job_id == job_id) &&
job_scheduler.c:				    ((dep_job_ptr->array_task_id != NO_VAL) ||
job_scheduler.c:				     (dep_job_ptr->array_recs != NULL))) {
job_scheduler.c:					dep_ptr->job_id = dep_job_ptr->job_id;
job_scheduler.c:						dep_job_ptr->array_job_id;
job_scheduler.c:			    (job_id == 0) || (job_id == job_ptr->job_id) ||
job_scheduler.c:				    (dep_job_ptr->array_job_id == job_id) &&
job_scheduler.c:				    ((dep_job_ptr->array_task_id != NO_VAL) ||
job_scheduler.c:				     (dep_job_ptr->array_recs != NULL))) {
job_scheduler.c:			     (dep_job_ptr->qos_id != job_ptr->qos_id)	||
job_scheduler.c:			     (dep_job_ptr->part_ptr == NULL)		||
job_scheduler.c:			     (job_ptr->part_ptr     == NULL)		||
job_scheduler.c:			     (dep_job_ptr->part_ptr != job_ptr->part_ptr))) {
job_scheduler.c:				if ((mc_ptr = job_ptr->details->mc_ptr)) {
job_scheduler.c:				job_ptr->details->expanding_jobid = job_id;
job_scheduler.c:				FREE_NULL_LIST(job_ptr->gres_list);
job_scheduler.c:					job_ptr->cpus_per_tres,
job_scheduler.c:					job_ptr->tres_freq,
job_scheduler.c:					job_ptr->tres_per_job,
job_scheduler.c:					job_ptr->tres_per_node,
job_scheduler.c:					job_ptr->tres_per_socket,
job_scheduler.c:					job_ptr->tres_per_task,
job_scheduler.c:					job_ptr->mem_per_tres,
job_scheduler.c:					&job_ptr->details->num_tasks,
job_scheduler.c:					&job_ptr->details->min_nodes,
job_scheduler.c:					&job_ptr->details->max_nodes,
job_scheduler.c:					&job_ptr->details->
job_scheduler.c:					&job_ptr->details->mc_ptr->
job_scheduler.c:					&job_ptr->details->
job_scheduler.c:					&job_ptr->gres_list);
job_scheduler.c:				gres_set_job_tres_cnt(job_ptr->gres_list,
job_scheduler.c:						      job_ptr->details ?
job_scheduler.c:						      job_ptr->details->
job_scheduler.c:						      job_ptr->tres_req_cnt,
job_scheduler.c:				xfree(job_ptr->tres_req_str);
job_scheduler.c:				job_ptr->tres_req_str =
job_scheduler.c:						job_ptr->tres_req_cnt,
job_scheduler.c:					dep_ptr->job_id  = dep_job_ptr->job_id;
job_scheduler.c:						dep_job_ptr->array_job_id;
job_scheduler.c:		(void) _scan_depend(NULL, job_ptr->job_id);
job_scheduler.c:		if (_scan_depend(new_depend_list, job_ptr->job_id))
job_scheduler.c:		FREE_NULL_LIST(job_ptr->details->depend_list);
job_scheduler.c:		job_ptr->details->depend_list = new_depend_list;
job_scheduler.c:		else if ((dep_ptr->job_id != dep_ptr->job_ptr->job_id) ||
job_scheduler.c:			 (dep_ptr->job_ptr->magic != JOB_MAGIC))
job_scheduler.c:			 dep_ptr->job_ptr->details &&
job_scheduler.c:			 dep_ptr->job_ptr->details->depend_list) {
job_scheduler.c:			rc = _scan_depend(dep_ptr->job_ptr->details->
job_scheduler.c:	if (job_ptr->part_ptr == NULL)
job_scheduler.c:	part_node_cnt = job_ptr->part_ptr->total_nodes;
job_scheduler.c:	part_cpu_cnt  = job_ptr->part_ptr->total_cpus;
job_scheduler.c:		    (job_q_ptr->part_ptr != job_ptr->part_ptr) ||
job_scheduler.c:		    (job_q_ptr->priority < job_ptr->priority) ||
job_scheduler.c:		    (job_q_ptr->job_id == job_ptr->job_id) ||
job_scheduler.c:	job_ptr->start_time += cume_space_time;
job_scheduler.c:	if ((job_ptr->details == NULL) || (job_ptr->job_state != JOB_PENDING))
job_scheduler.c:	if (job_ptr->part_ptr_list) {
job_scheduler.c:		list_sort(job_ptr->part_ptr_list, _part_weight_sort);
job_scheduler.c:		iter = list_iterator_create(job_ptr->part_ptr_list);
job_scheduler.c:		part_ptr = job_ptr->part_ptr;
job_scheduler.c:	if (job_ptr->details->exc_node_bitmap) {
job_scheduler.c:		bit_and_not(avail_bitmap, job_ptr->details->exc_node_bitmap);
job_scheduler.c:	if (job_ptr->details->req_node_bitmap) {
job_scheduler.c:		if (!bit_super_set(job_ptr->details->req_node_bitmap,
job_scheduler.c:	if (job_ptr->details->begin_time &&
job_scheduler.c:	    (job_ptr->details->begin_time > now))
job_scheduler.c:		start_res = job_ptr->details->begin_time;
job_scheduler.c:		if (job_ptr->part_ptr_list && (part_ptr = list_next(iter)))
job_scheduler.c:		min_nodes = MAX(job_ptr->details->min_nodes,
job_scheduler.c:		if (job_ptr->details->max_nodes == 0)
job_scheduler.c:			max_nodes = MIN(job_ptr->details->max_nodes,
job_scheduler.c:		if (!job_ptr->limit_set.tres[TRES_ARRAY_NODE] &&
job_scheduler.c:		    job_ptr->details->max_nodes)
job_scheduler.c:		orig_start_time = job_ptr->start_time;
job_scheduler.c:				save_share_res  = job_ptr->details->share_res;
job_scheduler.c:				save_whole_node = job_ptr->details->whole_node;
job_scheduler.c:				job_ptr->details->share_res = 0;
job_scheduler.c:				job_ptr->details->whole_node = 1;
job_scheduler.c:				job_ptr->details->share_res = save_share_res;
job_scheduler.c:				job_ptr->details->whole_node = save_whole_node;
job_scheduler.c:		resp_data->job_id     = job_ptr->job_id;
job_scheduler.c:		resp_data->proc_cnt = job_ptr->total_cpus;
job_scheduler.c:		resp_data->start_time = MAX(job_ptr->start_time,
job_scheduler.c:		job_ptr->start_time   = 0;  /* restore pending job start time */
job_scheduler.c:				(*preemptee_jid) = tmp_job_ptr->job_id;
job_scheduler.c:	if (rc && job_ptr->part_ptr_list && (part_ptr = list_next(iter)))
job_scheduler.c:	epilog_arg->job_id = job_ptr->job_id;
job_scheduler.c:	job_ptr->epilog_running = true;
job_scheduler.c:	if (job_ptr->spank_job_env_size) {
job_scheduler.c:				(const char **) job_ptr->spank_job_env);
job_scheduler.c:	setenvf(&my_env, "SLURM_JOB_ACCOUNT", "%s", job_ptr->account);
job_scheduler.c:	if (job_ptr->details && job_ptr->details->features) {
job_scheduler.c:			"%s", job_ptr->details->features);
job_scheduler.c:		if (WIFEXITED(job_ptr->exit_code)) {
job_scheduler.c:			exit_code = WEXITSTATUS(job_ptr->exit_code);
job_scheduler.c:		if (WIFSIGNALED(job_ptr->exit_code)) {
job_scheduler.c:			signal = WTERMSIG(job_ptr->exit_code);
job_scheduler.c:			job_ptr->derived_ec);
job_scheduler.c:		setenvf(&my_env, "SLURM_JOB_EXIT_CODE", "%u", job_ptr->exit_code);
job_scheduler.c:	if (job_ptr->array_task_id != NO_VAL) {
job_scheduler.c:			job_ptr->array_job_id);
job_scheduler.c:			job_ptr->array_task_id);
job_scheduler.c:		if (job_ptr->details && job_ptr->details->env_sup &&
job_scheduler.c:		    job_ptr->details->env_cnt) {
job_scheduler.c:			for (i = 0; i < job_ptr->details->env_cnt; i++) {
job_scheduler.c:				if (xstrncmp(job_ptr->details->env_sup[i],
job_scheduler.c:				eq = strchr(job_ptr->details->env_sup[i], '=');
job_scheduler.c:					job_ptr->details->env_sup[i],
job_scheduler.c:	if (job_ptr->pack_job_id) {
job_scheduler.c:			job_ptr->pack_job_id);
job_scheduler.c:			job_ptr->pack_job_offset);
job_scheduler.c:		if ((job_ptr->pack_job_offset == 0) && job_ptr->pack_job_list) {
job_scheduler.c:			iter = list_iterator_create(job_ptr->pack_job_list);
job_scheduler.c:				if (job_ptr->pack_job_id !=
job_scheduler.c:	setenvf(&my_env, "SLURM_JOB_GID", "%u", job_ptr->group_id);
job_scheduler.c:	name = gid_to_string((gid_t) job_ptr->group_id);
job_scheduler.c:	setenvf(&my_env, "SLURM_JOBID", "%u", job_ptr->job_id);
job_scheduler.c:	setenvf(&my_env, "SLURM_JOB_ID", "%u", job_ptr->job_id);
job_scheduler.c:	if (job_ptr->licenses)
job_scheduler.c:		setenvf(&my_env, "SLURM_JOB_LICENSES", "%s", job_ptr->licenses);
job_scheduler.c:	setenvf(&my_env, "SLURM_JOB_NAME", "%s", job_ptr->name);
job_scheduler.c:	setenvf(&my_env, "SLURM_JOB_NODELIST", "%s", job_ptr->nodes);
job_scheduler.c:	if (job_ptr->part_ptr) {
job_scheduler.c:			job_ptr->part_ptr->name);
job_scheduler.c:			job_ptr->partition);
job_scheduler.c:	setenvf(&my_env, "SLURM_JOB_UID", "%u", job_ptr->user_id);
job_scheduler.c:	name = uid_to_string((uid_t) job_ptr->user_id);
job_scheduler.c:	if (job_ptr->wckey) {
job_scheduler.c:		setenvf(&my_env, "SLURM_WCKEY", "%s", job_ptr->wckey);
job_scheduler.c:		job_ptr->epilog_running = false;
job_scheduler.c:		if (job_ptr->node_cnt == 0
job_scheduler.c:	    !node_features_g_user_update(job_ptr->user_id))
job_scheduler.c:	build_active_feature_bitmap(job_ptr, job_ptr->node_bitmap,
job_scheduler.c:	reboot_features = node_features_g_job_xlate(job_ptr->details->features);
job_scheduler.c:	boot_node_bitmap = bit_copy(job_ptr->node_bitmap);
job_scheduler.c:	if (job_ptr->reboot)
job_scheduler.c:	    !node_features_g_user_update(job_ptr->user_id))
job_scheduler.c:	if ((job_ptr->details == NULL) || (job_ptr->node_bitmap == NULL))
job_scheduler.c:	if (job_ptr->reboot) {
job_scheduler.c:		boot_node_bitmap = bit_copy(job_ptr->node_bitmap);
job_scheduler.c:	wait_boot_arg->job_id = job_ptr->job_id;
job_scheduler.c:	if (job_ptr->details->features &&
job_scheduler.c:	    node_features_g_user_update(job_ptr->user_id)) {
job_scheduler.c:			job_ptr->details->features);
job_scheduler.c:	job_ptr->details->prolog_running++;
job_scheduler.c:	uint32_t save_job_id = job_ptr->job_id;
job_scheduler.c:		if ((job_ptr->magic != JOB_MAGIC) ||
job_scheduler.c:		    (job_ptr->job_id != save_job_id)) {
job_scheduler.c:		    !job_ptr->node_bitmap) {
job_scheduler.c:		(void) job_requeue(getuid(), job_ptr->job_id, NULL, false, 0);
job_scheduler.c:	if (job_ptr->details) {
job_scheduler.c:		job_ptr->details->prolog_running++;
job_scheduler.c:		job_ptr->job_state |= JOB_CONFIGURING;
job_scheduler.c:	job_id = job_ptr->job_id;
job_scheduler.c:	if (job_ptr->node_bitmap) {
job_scheduler.c:		node_bitmap = bit_copy(job_ptr->node_bitmap);
job_scheduler.c:	track_script_rec = track_script_rec_add(job_ptr->job_id,
job_scheduler.c:			if (job_ptr->pack_job_list) {
job_scheduler.c:	if (job_ptr->job_id != job_id) {
job_scheduler.c:	} else if (job_ptr && job_ptr->node_bitmap) {
job_scheduler.c:			if (bit_test(job_ptr->node_bitmap, i) == 0)
job_scheduler.c:	if (job_ptr->details && job_ptr->details->prolog_running &&
job_scheduler.c:	    (--job_ptr->details->prolog_running > 0))
job_scheduler.c:	if (job_ptr->job_state & JOB_REQUEUE_FED)
job_scheduler.c:		if (job_ptr->batch_flag &&
job_scheduler.c:	struct job_details *detail_ptr = job_ptr->details;
job_scheduler.c:		if (job_ptr->batch_features)
job_scheduler.c:	can_reboot = node_features_g_user_update(job_ptr->user_id);
job_scheduler.c:				if (job_ptr->job_id) {
job_scheduler.c:		if (job_ptr->job_id) {
job_scheduler.c:		if (job_ptr->job_id) {
job_scheduler.c:		if (job_ptr->job_id) {
job_scheduler.c:	if (job_ptr->batch_features) {
job_scheduler.c:	if (!job_ptr->batch_features)
job_scheduler.c:	if (!job_ptr->details || !job_ptr->details->feature_list)
job_scheduler.c:	if (strchr(job_ptr->batch_features, '|'))
job_scheduler.c:	tmp = xstrdup(job_ptr->batch_features);
job_scheduler.c:		if (!list_find_first(job_ptr->details->feature_list,
job_scheduler.c:	List feature_list = job_ptr->details->feature_list;
job_scheduler.c:		if (job_ptr->job_id)
job_scheduler.c:		if (job_ptr->job_id)
job_scheduler.c:		if (job_ptr->job_id) {
job_scheduler.c:	if (!job_ptr->part_ptr_list)
job_scheduler.c:	if (!job_ptr->part_ptr || !job_ptr->part_ptr->name) {
job_scheduler.c:	xfree(job_ptr->partition);
job_scheduler.c:	job_ptr->partition = xstrdup(job_ptr->part_ptr->name);
job_scheduler.c:	part_iterator = list_iterator_create(job_ptr->part_ptr_list);
job_scheduler.c:		if (part_ptr == job_ptr->part_ptr)
job_scheduler.c:		xstrcat(job_ptr->partition, ",");
job_scheduler.c:		xstrcat(job_ptr->partition, part_ptr->name);
job_scheduler.c:	delay = last_job_update - job_ptr->end_time;
job_scheduler.c:	job_ptr->job_state &= (~JOB_COMPLETING);
job_scheduler.c:		fed_mgr_job_complete(job_ptr, job_ptr->exit_code,
job_scheduler.c:				     job_ptr->start_time);
Binary file acct_policy.o matches
job_scheduler.h:/* Print a job's dependency information based upon job_ptr->depend_list */
gang.c: * For GS_CORE:   job_ptr->job_resrcs->{node,core}_bitmap
gang.c: * For GS_CPU:    job_ptr->job_resrcs->{node_bitmap, cpus}
gang.c: * For GS_CPU2:   job_ptr->job_resrcs->{node,core}_bitmap
gang.c: * For GS_SOCKET: job_ptr->job_resrcs->{node,core}_bitmap
gang.c: * For GS_NODE:   job_ptr->job_resrcs->node_bitmap only
gang.c:		if (p_ptr->job_list[i]->job_ptr->job_id == job_id)
gang.c:	job_resources_t *job_res = job_ptr->job_resrcs;
gang.c:	job_resources_t *job_res = job_ptr->job_resrcs;
gang.c:	job_gr_type = _get_part_gr_type(job_ptr->part_ptr);
gang.c:	job_resources_t *job_res = job_ptr->job_resrcs;
gang.c:	job_gr_type = _get_part_gr_type(job_ptr->part_ptr);
gang.c:	msg.job_id = job_ptr->job_id;
gang.c:	msg.job_id = job_ptr->job_id;
gang.c:			ckpt_msg.job_id    = job_ptr->job_id;
gang.c:				ckpt_msg.job_id    = job_ptr->job_id;
gang.c:			   job_ptr->batch_flag && job_ptr->details &&
gang.c:			   (job_ptr->details->requeue > 0)) {
gang.c:			rc = job_requeue(0, job_ptr->job_id, NULL, true, 0);
gang.c:		    (j_ptr->job_ptr->priority == 0))
gang.c:	    j_ptr->job_ptr->priority) {
gang.c:	xassert(job_ptr->job_id > 0);
gang.c:	xassert(job_ptr->job_resrcs);
gang.c:	xassert(job_ptr->job_resrcs->node_bitmap);
gang.c:	xassert(job_ptr->job_resrcs->core_bitmap);
gang.c:	i = _find_job_index(p_ptr, job_ptr->job_id);
gang.c:		_remove_job_from_part(job_ptr->job_id, p_ptr, false);
gang.c:	j_ptr->job_id    = job_ptr->job_id;
gang.c:			_preempt_job_queue(job_ptr->job_id);
gang.c:		if (IS_JOB_SUSPENDED(job_ptr) && (job_ptr->priority == 0))
gang.c:		if (job_ptr->part_ptr && job_ptr->part_ptr->name)
gang.c:			part_name = job_ptr->part_ptr->name;
gang.c:			part_name = job_ptr->partition;
gang.c:			i = _find_job_index(p_ptr, job_ptr->job_id);
gang.c:		_remove_job_from_part(job_ptr->job_id, p_ptr, false);
gang.c:	if (job_ptr->part_ptr && job_ptr->part_ptr->name)
gang.c:		part_name = job_ptr->part_ptr->name;
gang.c:		part_name = job_ptr->partition;
gang.c:		if (IS_JOB_SUSPENDED(job_ptr) && (job_ptr->priority != 0)) {
gang.c:	if (job_ptr->part_ptr && job_ptr->part_ptr->name)
gang.c:		part_name = job_ptr->part_ptr->name;
gang.c:		part_name = job_ptr->partition;
gang.c:	_remove_job_from_part(job_ptr->job_id, p_ptr, true);
gang.c:				    (j_ptr->job_ptr->priority != 0)) {
gang.c:			    (job_ptr->priority == 0))
gang.c:		if (j_ptr->job_ptr->priority == 0)
gang.c:		    (j_ptr->job_ptr->priority != 0)) {	/* Redundant check */
Binary file gang.o matches
trigger_mgr.c:	if ((front_end_bitmap == NULL) || (job_ptr->batch_host == NULL))
trigger_mgr.c:		    !xstrcmp(front_end_nodes[i].name, job_ptr->batch_host)) {
trigger_mgr.c:		long rem_time = (trig_in->job_ptr->end_time - now);
trigger_mgr.c:		    bit_overlap(trig_in->job_ptr->node_bitmap,
trigger_mgr.c:		    bit_overlap(trig_in->job_ptr->node_bitmap,
trigger_mgr.c:		    bit_overlap(trig_in->job_ptr->node_bitmap,
fed_mgr.c:		uint32_t cluster_id = fed_mgr_get_cluster_id(job_ptr->job_id);
fed_mgr.c:		if (job_ptr->fed_details &&
fed_mgr.c:		    (job_ptr->details &&
fed_mgr.c:		     (job_ptr->details->submit_time < sync_time)) &&
fed_mgr.c:		     (job_ptr->fed_details->siblings_viable &
fed_mgr.c:		    *tmp = job_ptr->job_id;
fed_mgr.c:	if (job_ptr->details)
fed_mgr.c:		job_ptr->details->requeue = 0;
fed_mgr.c:	job_info->job_id          = job_ptr->job_id;
fed_mgr.c:	job_info->siblings_active = job_ptr->fed_details->siblings_active;
fed_mgr.c:	job_info->siblings_viable = job_ptr->fed_details->siblings_viable;
fed_mgr.c:	job_ptr->fed_details->siblings_active &=
fed_mgr.c:	job_ptr->fed_details->siblings_viable &=
fed_mgr.c:	if (!(job_ptr->fed_details->siblings_viable &
fed_mgr.c:		job_ptr->job_state |= JOB_REVOKED;
fed_mgr.c:	else if (!job_ptr->fed_details->cluster_lock)
fed_mgr.c:		job_ptr->job_state &= ~JOB_REVOKED;
fed_mgr.c:		siblings_viable = job_ptr->fed_details->siblings_viable;
fed_mgr.c:		    job_ptr->fed_details->cluster_lock)
fed_mgr.c:		free_job_fed_details(&job_ptr->fed_details);
fed_mgr.c:			xfree(job_ptr->resp_host);
fed_mgr.c:		job_ptr->job_state  = JOB_CANCELLED|JOB_REVOKED;
fed_mgr.c:		job_ptr->start_time = now;
fed_mgr.c:		job_ptr->end_time   = now;
fed_mgr.c:		siblings_viable = job_ptr->fed_details->siblings_viable;
fed_mgr.c:		    (job_ptr->fed_details &&
fed_mgr.c:		     job_ptr->fed_details->cluster_lock == cluster->fed.id) ||
fed_mgr.c:			free_job_fed_details(&job_ptr->fed_details);
fed_mgr.c:				xfree(job_ptr->resp_host);
fed_mgr.c:				job_ptr->job_state  = JOB_CANCELLED|JOB_REVOKED;
fed_mgr.c:				job_ptr->start_time = now;
fed_mgr.c:				job_ptr->end_time   = now;
fed_mgr.c:				job_ptr->state_reason = WAIT_NO_REASON;
fed_mgr.c:				xfree(job_ptr->state_desc);
fed_mgr.c:	    (error_code && job_ptr->job_state == JOB_FAILED))
fed_mgr.c:		if (!(job_ptr->fed_details->siblings_viable &
fed_mgr.c:			job_ptr->job_state |= JOB_REVOKED;
fed_mgr.c:	if (job_ptr->job_state & JOB_REQUEUE_FED) {
fed_mgr.c:		job_ptr->job_state &= ~(JOB_PENDING | JOB_COMPLETING);
fed_mgr.c:	} else if (!job_ptr->fed_details) {
fed_mgr.c:	} else if (!job_ptr->fed_details) {
fed_mgr.c:		job_ptr->fed_details->siblings_active =
fed_mgr.c:	job_ptr->fed_details->cluster_lock = cluster_lock;
fed_mgr.c:	job_ptr->fed_details->siblings_active =
fed_mgr.c:		_revoke_sibling_jobs(job_ptr->job_id, cluster_lock,
fed_mgr.c:	} else if (!job_ptr->fed_details) {
fed_mgr.c:		purge_job_record(job_ptr->job_id);
fed_mgr.c:	xassert(job_ptr->details);
fed_mgr.c:	job_ptr->fed_details->siblings_active |= job_desc->fed_siblings_active;
fed_mgr.c:	origin_id = fed_mgr_get_cluster_id(job_ptr->job_id);
fed_mgr.c:	old_sibs = job_ptr->fed_details->siblings_active;
fed_mgr.c:	_validate_cluster_features(job_ptr->details->cluster_features,
fed_mgr.c:	new_sibs = _get_viable_sibs(job_ptr->clusters, feature_sibs,
fed_mgr.c:				    job_ptr->array_recs ? true : false, NULL);
fed_mgr.c:	job_ptr->fed_details->siblings_viable = new_sibs;
fed_mgr.c:		_revoke_sibling_jobs(job_ptr->job_id,
fed_mgr.c:		job_ptr->fed_details->siblings_active &= ~rem_sibs;
fed_mgr.c:	if (job_ptr->priority != 0 && add_sibs)
fed_mgr.c:				job_ptr->fed_details->siblings_viable);
fed_mgr.c:		job_ptr->job_state &= ~JOB_REVOKED;
fed_mgr.c:	if ((job_info = _find_fed_job_info(job_ptr->job_id))) {
fed_mgr.c:			job_ptr->fed_details->siblings_viable;
fed_mgr.c:			job_ptr->fed_details->siblings_active;
fed_mgr.c:	if (!job_ptr || (*alloc_code && job_ptr->job_state == JOB_FAILED)) {
fed_mgr.c:	if (!(job_ptr->fed_details->siblings_viable &
fed_mgr.c:		job_ptr->job_state |= JOB_REVOKED;
fed_mgr.c:	*job_id_ptr = job_ptr->job_id;
fed_mgr.c:		     (!(job_ptr->fed_details->siblings_viable &
fed_mgr.c:	job_ptr->fed_details->siblings_active = job_desc->fed_siblings_active;
fed_mgr.c:				job_ptr->fed_details->siblings_viable))
fed_mgr.c:	job_ptr->fed_details->siblings_active = job_desc->fed_siblings_active;
fed_mgr.c:	if (job_ptr->fed_details &&
fed_mgr.c:	    job_ptr->fed_details->siblings_active &&
fed_mgr.c:	    (!(job_ptr->fed_details->siblings_active &
fed_mgr.c:	if (job_ptr->fed_details &&
fed_mgr.c:	    job_ptr->fed_details->cluster_lock &&
fed_mgr.c:	    job_ptr->fed_details->cluster_lock != fed_mgr_cluster_rec->fed.id)
fed_mgr.c:	if ((!job_ptr->fed_details) ||
fed_mgr.c:	    (!(*origin_id = fed_mgr_get_cluster_id(job_ptr->job_id)))) {
fed_mgr.c:			fed_mgr_job_lock_unset(job_ptr->job_id,
fed_mgr.c:			_persist_fed_job_unlock(sibling, job_ptr->job_id,
fed_mgr.c:	origin_id  = fed_mgr_get_cluster_id(job_ptr->job_id);
fed_mgr.c:	tmp_sibs = job_ptr->fed_details->siblings_viable &
fed_mgr.c:			if (!fed_mgr_job_lock_set(job_ptr->job_id, cluster_id))
fed_mgr.c:		} else if (!_persist_fed_job_lock(sibling, job_ptr->job_id,
fed_mgr.c:	    (!(job_ptr->fed_details->siblings_viable &
fed_mgr.c:						   job_ptr->job_id,
fed_mgr.c:			job_ptr->fed_details->cluster_lock = cluster_id;
fed_mgr.c:			fed_mgr_job_lock_set(job_ptr->job_id, cluster_id);
fed_mgr.c:	rc = fed_mgr_job_lock_set(job_ptr->job_id, cluster_id);
fed_mgr.c:	if (!fed_mgr_cluster_rec || !job_ptr->fed_details ||
fed_mgr.c:	    (job_ptr->fed_details->cluster_lock == fed_mgr_cluster_rec->fed.id))
fed_mgr.c:	if (!job_ptr->fed_details ||
fed_mgr.c:	    job_ptr->fed_details->cluster_lock)
fed_mgr.c:			tmp_sibs = job_ptr->fed_details->siblings_viable &
fed_mgr.c:						     job_ptr->job_id,
fed_mgr.c:			job_ptr->fed_details->cluster_lock = 0;
fed_mgr.c:			fed_mgr_job_lock_unset(job_ptr->job_id, cluster_id);
fed_mgr.c:	rc = fed_mgr_job_lock_unset(job_ptr->job_id, cluster_id);
fed_mgr.c:			viable_sibs = job_ptr->fed_details->siblings_viable;
fed_mgr.c:			_revoke_sibling_jobs(job_ptr->job_id,
fed_mgr.c:					     viable_sibs, job_ptr->start_time);
fed_mgr.c:						    job_ptr->job_id, cluster_id,
fed_mgr.c:						    job_ptr->start_time);
fed_mgr.c:			job_ptr->fed_details->siblings_active =
fed_mgr.c:	if (!(job_info = _find_fed_job_info(job_ptr->job_id))) {
fed_mgr.c:	if (job_ptr->bit_flags & SIB_JOB_FLUSH)
fed_mgr.c:		_revoke_sibling_jobs(job_ptr->job_id,
fed_mgr.c:				     job_ptr->fed_details->siblings_active,
fed_mgr.c:				     job_ptr->start_time);
fed_mgr.c:	return _persist_fed_job_revoke(conn, job_ptr->job_id, return_code,
fed_mgr.c:	_revoke_sibling_jobs(job_ptr->job_id, fed_mgr_cluster_rec->fed.id,
fed_mgr.c:			     job_ptr->fed_details->siblings_active, now);
fed_mgr.c:	job_ptr->exit_code = exit_code;
fed_mgr.c:	job_ptr->job_state  = state;
fed_mgr.c:	job_ptr->start_time = start_time;
fed_mgr.c:	job_ptr->end_time   = start_time;
fed_mgr.c:	job_ptr->state_reason = WAIT_NO_REASON;
fed_mgr.c:	xfree(job_ptr->state_desc);
fed_mgr.c:	if (!job_ptr->db_index && (origin_id != fed_mgr_cluster_rec->fed.id)) {
fed_mgr.c:	purge_job_record(job_ptr->job_id);
fed_mgr.c:		_persist_fed_job_requeue(origin_cluster, job_ptr->job_id,
fed_mgr.c:		job_ptr->job_state |= JOB_REQUEUE_FED;
fed_mgr.c:					job_ptr->fed_details->cluster_lock))) {
fed_mgr.c:			      job_ptr, job_ptr->fed_details->cluster_lock);
fed_mgr.c:		if (_persist_fed_job_cancel(remote_cluster, job_ptr->job_id,
fed_mgr.c:	xassert(job_ptr->details);
fed_mgr.c:	job_ptr->fed_details->siblings_active = 0;
fed_mgr.c:	if (!(job_info = _find_fed_job_info(job_ptr->job_id))) {
fed_mgr.c:	if (job_ptr->priority == 0) {
fed_mgr.c:		job_ptr->job_state &= (~JOB_REQUEUE_FED);
fed_mgr.c:		job_ptr->fed_details->cluster_lock = 0;
fed_mgr.c:	_validate_cluster_features(job_ptr->details->cluster_features,
fed_mgr.c:	job_ptr->fed_details->siblings_viable =
fed_mgr.c:		_get_viable_sibs(job_ptr->clusters, feature_sibs,
fed_mgr.c:				 job_ptr->array_recs ? true : false, NULL);
fed_mgr.c:				 job_ptr->fed_details->siblings_viable);
fed_mgr.c:	job_ptr->job_state &= (~JOB_REQUEUE_FED);
fed_mgr.c:	if (!(job_ptr->fed_details->siblings_viable &
fed_mgr.c:		job_ptr->job_state |= JOB_REVOKED;
fed_mgr.c:		job_ptr->job_state &= ~JOB_REVOKED;
fed_mgr.c:	job_ptr->fed_details->cluster_lock = 0;
fed_mgr.c:			job_ptr->fed_details->siblings_viable;
fed_mgr.c:			job_ptr->fed_details->siblings_active;
fed_mgr.c:		tmp_sibs = job_ptr->fed_details->siblings_viable;
fed_mgr.c:		tmp_sibs = job_ptr->fed_details->siblings_active;
fed_mgr.c:			_persist_fed_job_cancel(cluster, job_ptr->job_id,
fed_mgr.c:		   job_ptr->fed_details->cluster_lock) {
fed_mgr.c:		xfree(job_ptr->clusters);
fed_mgr.c:			job_ptr->clusters =
fed_mgr.c:		   job_ptr->fed_details->cluster_lock) {
fed_mgr.c:		xfree(job_ptr->details->cluster_features);
fed_mgr.c:			job_ptr->details->cluster_features =
fed_mgr.c:	uint32_t origin_id    = fed_mgr_get_cluster_id(job_ptr->job_id);
fed_mgr.c:	if (!job_ptr->fed_details ||
fed_mgr.c:	    !job_ptr->details ||
fed_mgr.c:	    (job_ptr->details->submit_time >= rec_sib->sync_time) ||
fed_mgr.c:	    ((fed_mgr_get_cluster_id(job_ptr->job_id) != sibling_id) &&
fed_mgr.c:	     (!(job_ptr->fed_details->siblings_viable & sibling_bit)))) {
fed_mgr.c:		if (job_ptr->job_id == remote_job->job_id) {
fed_mgr.c:			job_ptr->bit_flags |= SIB_JOB_FLUSH;
fed_mgr.c:			job_ptr->job_state  = JOB_CANCELLED;
fed_mgr.c:			job_ptr->start_time = remote_job->start_time;
fed_mgr.c:			job_ptr->end_time   = remote_job->end_time;
fed_mgr.c:			job_ptr->state_reason = WAIT_NO_REASON;
fed_mgr.c:			xfree(job_ptr->state_desc);
fed_mgr.c:					   job_ptr->start_time);
fed_mgr.c:					   job_ptr->start_time);
fed_mgr.c:		if (!(job_ptr->fed_details->siblings_active & sibling_bit)) {
fed_mgr.c:		} else if (!job_ptr->fed_details->cluster_lock) {
fed_mgr.c:		} else if (job_ptr->fed_details->cluster_lock == sibling_id) {
fed_mgr.c:					   job_ptr->start_time);
fed_mgr.c:			     job_ptr->fed_details->cluster_lock);
fed_mgr.c:			job_ptr->fed_details->siblings_active &= ~sibling_bit;
fed_mgr.c:		if (job_ptr->fed_details->cluster_lock == sibling_id) {
fed_mgr.c:						   job_ptr->start_time);
fed_mgr.c:						   job_ptr->start_time);
fed_mgr.c:		} else if (job_ptr->fed_details->cluster_lock) {
fed_mgr.c:			     job_ptr->fed_details->cluster_lock);
fed_mgr.c:				     job_ptr->fed_details->cluster_lock);
fed_mgr.c:						job_ptr->job_id,
fed_mgr.c:						job_ptr->start_time);
fed_mgr.c:				     job_ptr->fed_details->cluster_lock,
fed_mgr.c:						job_ptr->job_id,
fed_mgr.c:						job_ptr->start_time);
fed_mgr.c:			if (!(job_ptr->fed_details->siblings_active &
fed_mgr.c:				job_ptr->fed_details->siblings_active |=
fed_mgr.c:				job_ptr->job_state  = JOB_CANCELLED;
fed_mgr.c:				job_ptr->start_time = remote_job->start_time;
fed_mgr.c:				job_ptr->end_time   = remote_job->end_time;
fed_mgr.c:				job_ptr->state_reason = WAIT_NO_REASON;
fed_mgr.c:				xfree(job_ptr->state_desc);
fed_mgr.c:				     _find_fed_job_info(job_ptr->job_id))) {
fed_mgr.c:					job_ptr->fed_details->cluster_lock =
fed_mgr.c:	if ((job_info = _find_fed_job_info(job_ptr->job_id))) {
fed_mgr.c:			job_ptr->fed_details->siblings_viable;
fed_mgr.c:			job_ptr->fed_details->siblings_active;
fed_mgr.c:	if (job_ptr->fed_details->cluster_lock)
fed_mgr.c:	if (job_ptr->fed_details->siblings_active &
fed_mgr.c:			_revoke_sibling_jobs(job_ptr->job_id,
fed_mgr.c:		job_ptr->fed_details->siblings_active &=
agent.c:						job_ptr->job_state |=
agent.c:						job_ptr->job_state &=
agent.c:					job_ptr->job_state &= ~JOB_SIGNALING;
agent.c:				job_ptr->job_state &= ~JOB_SIGNALING;
agent.c:	if ((mail_type == MAIL_JOB_BEGIN) && job_ptr->start_time &&
agent.c:	    job_ptr->details && job_ptr->details->submit_time) {
agent.c:		interval = job_ptr->start_time - job_ptr->details->submit_time;
agent.c:	    (job_ptr->start_time && job_ptr->end_time)) {
agent.c:		if (job_ptr->suspend_time) {
agent.c:			interval  = job_ptr->end_time - job_ptr->suspend_time;
agent.c:			interval += job_ptr->pre_sus_time;
agent.c:			interval = job_ptr->end_time - job_ptr->start_time;
agent.c:	     (mail_type == MAIL_JOB_TIME50)) && job_ptr->start_time) {
agent.c:		if (job_ptr->suspend_time) {
agent.c:			interval  = time(NULL) - job_ptr->suspend_time;
agent.c:			interval += job_ptr->pre_sus_time;
agent.c:			interval = time(NULL) - job_ptr->start_time;
agent.c:	if ((mail_type == MAIL_JOB_STAGE_OUT) && job_ptr->end_time) {
agent.c:		interval = time(NULL) - job_ptr->end_time;
agent.c:		base_state = job_ptr->job_state & JOB_STATE_BASE;
agent.c:		if (job_ptr->array_recs &&
agent.c:		    !(job_ptr->mail_type & MAIL_ARRAY_TASKS)) {
agent.c:			exit_status_min = job_ptr->array_recs->min_exit_code;
agent.c:			exit_status_max = job_ptr->array_recs->max_exit_code;
agent.c:			if (job_ptr->array_recs->array_flags &
agent.c:			exit_status_max = job_ptr->exit_code;
agent.c:	if (job_ptr->pack_job_id && (job_ptr->pack_job_offset != 0))
agent.c:	if (!job_ptr->mail_user) {
agent.c:		mi->user_name = uid_to_string((uid_t)job_ptr->user_id);
agent.c:		mi->user_name = xstrdup(job_ptr->mail_user);
agent.c:	if (!(job_ptr->mail_type & MAIL_ARRAY_TASKS) &&
agent.c:	    (job_ptr->array_task_id != NO_VAL) && !job_ptr->array_recs) {
agent.c:		master_job_ptr = find_job_record(job_ptr->array_job_id);
agent.c:		if (master_job_ptr && master_job_ptr->array_recs)
agent.c:	if (job_ptr->array_recs && !(job_ptr->mail_type & MAIL_ARRAY_TASKS)) {
agent.c:					     job_ptr->array_job_id,
agent.c:					     job_ptr->job_id, job_ptr->name,
agent.c:	} else if (job_ptr->array_task_id != NO_VAL) {
agent.c:					     job_ptr->array_job_id,
agent.c:					     job_ptr->array_task_id,
agent.c:					     job_ptr->job_id, job_ptr->name,
agent.c:					     job_ptr->job_id, job_ptr->name,
agent.c:	if (job_ptr->details && job_ptr->details->prolog_running)
agent.c:	if (job_ptr->wait_all_nodes) {
agent.c:				launch_msg_ptr->alias_list = xstrdup(job_ptr->
agent.c:		      job_ptr->job_id);
agent.c:	if (job_ptr->state_reason != WAIT_PROLOG)
agent.c:		      job_ptr->job_id);
acct_policy.h: *	timed out and sets job_ptr->state_reason = FAIL_TIMEOUT;
partition_mgr.c:	if ((job_ptr->state_reason == FAIL_ACCOUNT) ||
partition_mgr.c:	    (job_ptr->state_reason == FAIL_QOS) ||
partition_mgr.c:	    (job_ptr->state_reason == WAIT_NODE_NOT_AVAIL)) {
partition_mgr.c:	if ((job_ptr->state_reason == WAIT_PART_DOWN) ||
partition_mgr.c:	    (job_ptr->state_reason == WAIT_PART_INACTIVE) ||
partition_mgr.c:	    (job_ptr->state_reason == WAIT_PART_NODE_LIMIT) ||
partition_mgr.c:	    (job_ptr->state_reason == WAIT_PART_TIME_LIMIT) ||
partition_mgr.c:	    (job_ptr->state_reason == WAIT_QOS_THRES)) {
partition_mgr.c:				xfree(job_ptr->state_desc);
partition_mgr.c:				job_ptr->state_desc = tmp_err;
partition_mgr.c:				job_ptr->state_reason = WAIT_ACCOUNT;
partition_mgr.c:				xfree(job_ptr->state_desc);
partition_mgr.c:				job_ptr->state_desc = tmp_err;
partition_mgr.c:				job_ptr->state_reason = WAIT_ACCOUNT;
partition_mgr.c:				xfree(job_ptr->state_desc);
partition_mgr.c:				job_ptr->state_desc = tmp_err;
partition_mgr.c:				job_ptr->state_reason = WAIT_ACCOUNT;
partition_mgr.c:				xfree(job_ptr->state_desc);
partition_mgr.c:				job_ptr->state_desc = tmp_err;
partition_mgr.c:				job_ptr->state_reason = WAIT_QOS;
partition_mgr.c:				xfree(job_ptr->state_desc);
partition_mgr.c:				job_ptr->state_desc = tmp_err;
partition_mgr.c:				job_ptr->state_reason = WAIT_QOS;
partition_mgr.c:				xfree(job_ptr->state_desc);
partition_mgr.c:				job_ptr->state_desc = tmp_err;
partition_mgr.c:				job_ptr->state_reason = WAIT_QOS;
calc_hops.c:	char * listnodes = job_ptr->nodes;
calc_hops.c:	if(job_ptr->comment){
Binary file proc_req.o matches
read_config.c:	    (job_ptr->node_bitmap == NULL)        ||
read_config.c:	    (job_ptr->details     == NULL)        ||
read_config.c:	    (job_ptr->details->share_res != 0))
read_config.c:	bit_and_not(share_node_bitmap, job_ptr->node_bitmap);
read_config.c:	job_ptr->job_state = job_state | JOB_COMPLETING;
read_config.c:	job_ptr->end_time = MIN(job_ptr->end_time, now);
read_config.c:	job_ptr->state_reason = state_reason;
read_config.c:	xfree(job_ptr->state_desc);
read_config.c:	job_ptr->state_desc = xstrdup(reason_string);
read_config.c:	if (job_ptr->job_state == JOB_NODE_FAIL) {
read_config.c:	job_ptr->bit_flags &= (~JOB_PACK_FLAG);
read_config.c:	job_ptr->bit_flags |= JOB_PACK_FLAG;
read_config.c:	if ((job_ptr->pack_job_id == 0) || IS_JOB_FINISHED(job_ptr))
read_config.c:	if (job_ptr->bit_flags & JOB_PACK_FLAG)
read_config.c:		if ((job_ptr->pack_job_id == 0) ||
read_config.c:		    (job_ptr->pack_job_offset != 0))
read_config.c:		FREE_NULL_LIST(job_ptr->pack_job_list);
read_config.c:		xstrfmtcat(job_id_str, "[%s]", job_ptr->pack_job_id_set);
read_config.c:			      job_ptr, job_ptr->pack_job_id_set);
read_config.c:		job_ptr->pack_job_list = list_create(NULL);
read_config.c:				      job_id, job_ptr->job_id);
read_config.c:			} else if (pack_job_ptr->pack_job_id !=
read_config.c:				   job_ptr->job_id) {
read_config.c:				      job_id, job_ptr->job_id);
read_config.c:				list_append(job_ptr->pack_job_list,
read_config.c:			list_for_each(job_ptr->pack_job_list, _mark_pack_used,
read_config.c:		    job_ptr->details && job_ptr->details->prolog_running) {
read_config.c:			job_ptr->details->prolog_running = 0;
read_config.c:		if (job_ptr->node_bitmap == NULL)
read_config.c:		if ((job_ptr->node_bitmap) && IS_JOB_COMPLETING(job_ptr)) {
read_config.c:			if (job_ptr->epilog_running == true)
read_config.c:			if (!job_ptr->node_bitmap_cg)
read_config.c:			if (job_ptr->front_end_ptr)
read_config.c:				job_ptr->front_end_ptr->job_cnt_run++;
read_config.c:	if (job_ptr->node_bitmap_cg) /* job completing */
read_config.c:		job_ptr->node_cnt = bit_set_count(job_ptr->node_bitmap_cg);
read_config.c:		job_ptr->node_cnt = bit_set_count(job_ptr->node_bitmap);
read_config.c:		if (job_ptr->node_bitmap_cg) { /* job completing */
read_config.c:			if (bit_test(job_ptr->node_bitmap_cg, i) == 0)
read_config.c:		} else if (bit_test(job_ptr->node_bitmap, i) == 0)
read_config.c:		if ((job_ptr->details &&
read_config.c:		     (job_ptr->details->whole_node == WHOLE_NODE_USER)) ||
read_config.c:		    (job_ptr->part_ptr &&
read_config.c:		     (job_ptr->part_ptr->flags & PART_FLAG_EXCLUSIVE_USER))) {
read_config.c:			node_ptr->owner = job_ptr->user_id;
read_config.c:			node_ptr->mcs_label = xstrdup(job_ptr->mcs_label);
read_config.c:		if(job_ptr->comment && strcmp(job_ptr->comment,"1")==0){
read_config.c:				job_ptr->job_id,node_ptr->leaf_switch);
read_config.c:		if ((job_ptr->details) && (job_ptr->details->share_res == 0))
read_config.c:		    (job_ptr->kill_on_node_fail == 0)   &&
read_config.c:		    (job_ptr->node_cnt > 1)) {
read_config.c:	    (job_ptr->front_end_ptr != NULL))
read_config.c:		job_ptr->front_end_ptr->job_cnt_run++;
read_config.c:		if (bit_test(job_ptr->node_bitmap, i) == 0)
read_config.c:		if (job_ptr->array_recs)
read_config.c:			job_ptr->array_recs->tot_run_tasks = 0;
read_config.c:				   job_ptr->details &&
read_config.c:				   job_ptr->details->accrue_time)
read_config.c:		license_list = license_validate(job_ptr->licenses, false, false,
read_config.c:						job_ptr->tres_req_cnt, &valid);
read_config.c:		FREE_NULL_LIST(job_ptr->license_list);
read_config.c:			job_ptr->license_list = license_list;
read_config.c:			xfree(job_ptr->licenses);
read_config.c:			job_ptr->licenses =
read_config.c:		if ((job_ptr->details == NULL) ||
read_config.c:		    (job_ptr->details->dependency == NULL))
read_config.c:		new_depend = job_ptr->details->dependency;
read_config.c:		job_ptr->details->dependency = NULL;
read_config.c:			else if (job_ptr->db_index != NO_VAL64)
read_config.c:				job_ptr->db_index = 0;
read_config.c:				job_ptr->step_list);
proc_req.c:	job_resources_t *job_resrcs_ptr = job_ptr->job_resrcs;
proc_req.c:	cred_arg.jobid    = job_ptr->job_id;
proc_req.c:	cred_arg.uid      = job_ptr->user_id;
proc_req.c:	cred_arg.gid      = job_ptr->group_id;
proc_req.c:	cred_arg.x11             = job_ptr->details->x11;
proc_req.c:	cred_arg.job_constraints = job_ptr->details->features;
proc_req.c:	cred_arg.job_core_spec   = job_ptr->details->core_spec;
proc_req.c:	cred_arg.job_mem_limit   = job_ptr->details->pn_min_memory;
proc_req.c:	cred_arg.job_gres_list   = job_ptr->gres_list;
proc_req.c:	xassert(job_ptr->batch_host);
proc_req.c:	cred_arg.step_hostlist   = job_ptr->batch_host;
proc_req.c:	job_ptr->job_state	= JOB_CANCELLED;
proc_req.c:	job_ptr->start_time	= now;
proc_req.c:	job_ptr->end_time	= now;
proc_req.c:	job_ptr->exit_code	= 1;
proc_req.c:	if (job_ptr->job_resrcs && job_ptr->job_resrcs->cpu_array_cnt) {
proc_req.c:		alloc_msg->num_cpu_groups = job_ptr->job_resrcs->cpu_array_cnt;
proc_req.c:						    job_ptr->job_resrcs->
proc_req.c:		       job_ptr->job_resrcs->cpu_array_reps,
proc_req.c:		       (sizeof(uint32_t) * job_ptr->job_resrcs->cpu_array_cnt));
proc_req.c:						    job_ptr->job_resrcs->
proc_req.c:		       job_ptr->job_resrcs->cpu_array_value,
proc_req.c:		       (sizeof(uint16_t) * job_ptr->job_resrcs->cpu_array_cnt));
proc_req.c:	alloc_msg->job_id         = job_ptr->job_id;
proc_req.c:	alloc_msg->node_cnt       = job_ptr->node_cnt;
proc_req.c:	alloc_msg->node_list      = xstrdup(job_ptr->nodes);
proc_req.c:	alloc_msg->partition      = xstrdup(job_ptr->partition);
proc_req.c:	alloc_msg->alias_list     = xstrdup(job_ptr->alias_list);
proc_req.c:		select_g_select_jobinfo_copy(job_ptr->select_jobinfo);
proc_req.c:	if (job_ptr->details) {
proc_req.c:		if (job_ptr->bit_flags & JOB_MEM_SET) {
proc_req.c:				job_ptr->details->pn_min_memory;
proc_req.c:		alloc_msg->cpu_freq_min = job_ptr->details->cpu_freq_min;
proc_req.c:		alloc_msg->cpu_freq_max = job_ptr->details->cpu_freq_max;
proc_req.c:		alloc_msg->cpu_freq_gov = job_ptr->details->cpu_freq_gov;
proc_req.c:		if (job_ptr->details->mc_ptr) {
proc_req.c:				job_ptr->details->mc_ptr->ntasks_per_board;
proc_req.c:				job_ptr->details->mc_ptr->ntasks_per_core;
proc_req.c:				job_ptr->details->mc_ptr->ntasks_per_socket;
proc_req.c:		if (job_ptr->details->env_cnt) {
proc_req.c:			alloc_msg->env_size = job_ptr->details->env_cnt;
proc_req.c:					xstrdup(job_ptr->details->env_sup[i]);
proc_req.c:	if (job_ptr->account)
proc_req.c:		alloc_msg->account = xstrdup(job_ptr->account);
proc_req.c:	if (job_ptr->qos_ptr) {
proc_req.c:		qos = (slurmdb_qos_rec_t *)job_ptr->qos_ptr;
proc_req.c:	if (job_ptr->resv_name)
proc_req.c:		alloc_msg->resv_name = xstrdup(job_ptr->resv_name);
proc_req.c:				    job_ptr->origin_cluster);
proc_req.c:		if (error_code && (job_ptr->job_state == JOB_FAILED))
proc_req.c:			pack_job_id = job_ptr->job_id;
proc_req.c:		snprintf(tmp_str, sizeof(tmp_str), "%u", job_ptr->job_id);
proc_req.c:		job_ptr->pack_job_id     = pack_job_id;
proc_req.c:		job_ptr->pack_job_offset = pack_job_offset++;
proc_req.c:			first_job_ptr->pack_job_list = submit_job_list;
proc_req.c:		first_job_ptr->pack_job_list = submit_job_list;
proc_req.c:			job_ptr->pack_job_id_set = xstrdup(tmp_offset);
proc_req.c:			    (error_code && job_ptr->job_state == JOB_FAILED))
proc_req.c:			   __func__, job_ptr, job_ptr->nodes, TIME_STR);
proc_req.c:			_kill_job_on_msg_fail(job_ptr->job_id);
proc_req.c:	if (job_ptr && job_ptr->batch_host && comp_msg->node_name &&
proc_req.c:	    xstrcmp(job_ptr->batch_host, comp_msg->node_name)) {
proc_req.c:		      comp_msg->node_name, job_ptr->batch_host);
proc_req.c:	    (job_ptr->job_state != JOB_PENDING)) {
proc_req.c:	if (job_ptr && job_ptr->front_end_ptr)
proc_req.c:		nodes = job_ptr->front_end_ptr->name;
proc_req.c:			if (job_ptr && job_ptr->front_end_ptr) {
proc_req.c:				update_node_msg.name = job_ptr->front_end_ptr->
proc_req.c:			    job_ptr->details && job_ptr->details->requeue)
proc_req.c:		if (!validate_operator(uid) && job_ptr->user_id != uid) {
proc_req.c:		if (step_rec->job_ptr->batch_host) {
proc_req.c:				xstrdup(step_rec->job_ptr->batch_host);
proc_req.c:		if (step_rec->job_ptr && step_rec->job_ptr->details &&
proc_req.c:		    (step_rec->job_ptr->details->cpu_bind_type != NO_VAL16)) {
proc_req.c:				step_rec->job_ptr->details->cpu_bind_type;
proc_req.c:	if (error_code || (job_ptr == NULL) || (job_ptr->job_resrcs == NULL)) {
proc_req.c:		      job_info_msg->job_id, job_ptr->nodes, TIME_STR);
proc_req.c:	    (job_ptr->pack_job_id && !job_ptr->pack_job_list))
proc_req.c:	if (error_code || (job_ptr == NULL) || (job_ptr->job_resrcs == NULL)) {
proc_req.c:	      job_info_msg->job_id, job_ptr->nodes, TIME_STR);
proc_req.c:	if (!job_ptr->pack_job_list) {
proc_req.c:		iter = list_iterator_create(job_ptr->pack_job_list);
proc_req.c:			if (job_ptr->pack_job_id != pack_job->pack_job_id) {
proc_req.c:		if (job_ptr && job_ptr->pack_job_list) {  /* Do full pack job */
proc_req.c:			iter = list_iterator_create(job_ptr->pack_job_list);
proc_req.c:							     job_ptr->job_id);
proc_req.c:			job_info_msg->job_id = job_ptr->job_id;
proc_req.c:	if (job_ptr && !validate_operator(uid) && job_ptr->user_id != uid)
proc_req.c:			    job_ptr->node_cnt)) {
proc_req.c:		node_addr = job_ptr->node_addr;
proc_req.c:		node_cnt  = job_ptr->node_cnt;
proc_req.c:		node_list = job_ptr->nodes;
proc_req.c:		memcpy(node_addr, job_ptr->node_addr,
proc_req.c:	sbcast_arg.job_id = job_ptr->job_id;
proc_req.c:	sbcast_arg.pack_jobid = job_ptr->pack_job_id;
proc_req.c:	sbcast_arg.uid = job_ptr->user_id;
proc_req.c:	sbcast_arg.gid = job_ptr->group_id;
proc_req.c:	sbcast_arg.expiration = job_ptr->end_time;
proc_req.c:		job_info_resp_msg.job_id         = job_ptr->job_id;
proc_req.c:	if (job_ptr->batch_host)
proc_req.c:		step_layout->front_end = xstrdup(job_ptr->batch_host);
proc_req.c:		    (error_code && job_ptr->job_state == JOB_FAILED))
proc_req.c:			job_id = job_ptr->job_id;
proc_req.c:			priority = job_ptr->priority;
proc_req.c:		    (error_code && job_ptr->job_state == JOB_FAILED)) {
proc_req.c:				pack_job_id = job_ptr->job_id;
proc_req.c:				 job_ptr->job_id);
proc_req.c:			job_ptr->pack_job_id     = pack_job_id;
proc_req.c:			job_ptr->pack_job_offset = pack_job_offset++;
proc_req.c:			job_ptr->batch_flag      = 1;
proc_req.c:		first_job_ptr->pack_job_list = submit_job_list;
proc_req.c:			job_ptr->pack_job_id_set = xstrdup(tmp_offset);
proc_req.c:				first_job_ptr->pack_job_list = submit_job_list;
proc_req.c:		is_running = (job_ptr->state_reason != WAIT_PROLOG);
proc_req.c:	else if (fed_mgr_cluster_rec && job_ptr->fed_details &&
proc_req.c:		 job_ptr->fed_details->cluster_lock &&
proc_req.c:		 (job_ptr->fed_details->cluster_lock !=
proc_req.c:					job_ptr->fed_details->cluster_lock);
proc_req.c:		      job_ptr->fed_details->cluster_lock);
proc_req.c:	else if (job_ptr->batch_flag &&
proc_req.c:		 fed_mgr_cluster_rec && job_ptr->fed_details &&
proc_req.c:		 job_ptr->fed_details->cluster_lock &&
proc_req.c:		 (job_ptr->fed_details->cluster_lock !=
proc_req.c:					job_ptr->fed_details->cluster_lock);
proc_req.c:		      job_ptr->fed_details->cluster_lock);
proc_req.c:	} else if ((job_ptr->user_id == uid) || validate_slurm_user(uid))
proc_req.c:		      uid, job_ptr, job_ptr->user_id);
proc_req.c:				job_ptr->spank_job_env_size;
proc_req.c:					job_ptr->spank_job_env[i]);
proc_req.c:		     (job_ptr && job_ptr->fed_details &&
proc_req.c:		      (job_ptr->fed_details->cluster_lock !=
slurmctld.h: * is defined, return total_cpus. This is cached on job_ptr->billable_tres and
slurmctld.h: * Realloc and possibly update a job_ptr->limit_set->tres array.
slurmctld.h: * IN: tres_limits - job_ptr->limit_set->tres array.
srun_comm.c:	if (job_ptr->pack_job_id == 0)
srun_comm.c:	pack_leader = find_job_record(job_ptr->pack_job_id);
srun_comm.c:	if (!job_ptr || !job_ptr->alloc_resp_port || !job_ptr->alloc_node ||
srun_comm.c:	    !job_ptr->resp_host || !job_ptr->job_resrcs ||
srun_comm.c:	    !job_ptr->job_resrcs->cpu_array_cnt)
srun_comm.c:	if (job_ptr->pack_job_id == 0) {
srun_comm.c:		slurm_set_addr(addr, job_ptr->alloc_resp_port,
srun_comm.c:			job_ptr->resp_host);
srun_comm.c:		_srun_agent_launch(addr, job_ptr->alloc_node,
srun_comm.c:				   job_ptr->start_protocol_ver);
srun_comm.c:	} else if ((pack_leader = find_job_record(job_ptr->pack_job_id))) {
srun_comm.c:		_srun_agent_launch(addr, job_ptr->alloc_node,
srun_comm.c:				   job_ptr->start_protocol_ver);
srun_comm.c:	if (job_ptr && job_ptr->alloc_resp_port && job_ptr->alloc_node &&
srun_comm.c:	    job_ptr->resp_host) {
srun_comm.c:		slurm_set_addr(addr, job_ptr->alloc_resp_port,
srun_comm.c:			       job_ptr->resp_host);
srun_comm.c:		msg_arg->job_id   = job_ptr->job_id;
srun_comm.c:		_srun_agent_launch(addr, job_ptr->alloc_node,
srun_comm.c:				   job_ptr->start_protocol_ver);
srun_comm.c:	step_iterator = list_iterator_create(job_ptr->step_list);
srun_comm.c:		msg_arg->job_id   = job_ptr->job_id;
srun_comm.c:	if (job_ptr->other_port && job_ptr->alloc_node && job_ptr->resp_host) {
srun_comm.c:		slurm_set_addr(addr, job_ptr->other_port, job_ptr->resp_host);
srun_comm.c:		msg_arg->job_id   = job_ptr->job_id;
srun_comm.c:		_srun_agent_launch(addr, job_ptr->alloc_node, SRUN_NODE_FAIL,
srun_comm.c:				   msg_arg, job_ptr->start_protocol_ver);
srun_comm.c:		xassert (job_ptr->magic == JOB_MAGIC);
srun_comm.c:		if ((job_ptr->time_last_active <= old) && job_ptr->other_port
srun_comm.c:		    &&  job_ptr->alloc_node && job_ptr->resp_host) {
srun_comm.c:			slurm_set_addr(addr, job_ptr->other_port,
srun_comm.c:				job_ptr->resp_host);
srun_comm.c:			msg_arg->job_id  = job_ptr->job_id;
srun_comm.c:			_srun_agent_launch(addr, job_ptr->alloc_node,
srun_comm.c:					   job_ptr->start_protocol_ver);
srun_comm.c:	msg_arg->job_id   = step_ptr->job_ptr->job_id;
srun_comm.c:	if (job_ptr->other_port && job_ptr->alloc_node && job_ptr->resp_host) {
srun_comm.c:		slurm_set_addr(addr, job_ptr->other_port, job_ptr->resp_host);
srun_comm.c:		msg_arg->job_id   = job_ptr->job_id;
srun_comm.c:		msg_arg->timeout  = job_ptr->end_time;
srun_comm.c:		_srun_agent_launch(addr, job_ptr->alloc_node, SRUN_TIMEOUT,
srun_comm.c:				   msg_arg, job_ptr->start_protocol_ver);
srun_comm.c:	step_iterator = list_iterator_create(job_ptr->step_list);
srun_comm.c:		srun_step_timeout(step_ptr, job_ptr->end_time);
srun_comm.c:	if (job_ptr->other_port &&
srun_comm.c:	    job_ptr->resp_host && job_ptr->resp_host[0]) {
srun_comm.c:		slurm_set_addr(addr, job_ptr->other_port, job_ptr->resp_host);
srun_comm.c:		msg_arg->job_id = job_ptr->job_id;
srun_comm.c:		_srun_agent_launch(addr, job_ptr->resp_host, SRUN_USER_MSG,
srun_comm.c:				   msg_arg, job_ptr->start_protocol_ver);
srun_comm.c:	} else if (job_ptr->batch_flag && IS_JOB_RUNNING(job_ptr)) {
srun_comm.c:		if (job_ptr->batch_host == NULL)
srun_comm.c:		agent_arg_ptr->hostlist = hostlist_create(job_ptr->batch_host);
srun_comm.c:			fatal("Invalid srun host: %s", job_ptr->batch_host);
srun_comm.c:		if (job_ptr->front_end_ptr)
srun_comm.c:				job_ptr->front_end_ptr->protocol_version;
srun_comm.c:		node_ptr = find_first_node_record(job_ptr->node_bitmap);
srun_comm.c:		notify_msg_ptr->job_id = job_ptr->job_id;
srun_comm.c:	if (job_ptr->other_port && job_ptr->alloc_node && job_ptr->resp_host) {
srun_comm.c:		slurm_set_addr(addr, job_ptr->other_port, job_ptr->resp_host);
srun_comm.c:		msg_arg->job_id   = job_ptr->job_id;
srun_comm.c:		_srun_agent_launch(addr, job_ptr->alloc_node,
srun_comm.c:				   job_ptr->start_protocol_ver);
srun_comm.c:	step_iterator = list_iterator_create(job_ptr->step_list);
srun_comm.c:	if (job_ptr->other_port && job_ptr->alloc_node && job_ptr->resp_host) {
srun_comm.c:		slurm_set_addr(addr, job_ptr->other_port, job_ptr->resp_host);
srun_comm.c:		msg_arg->job_id  = job_ptr->job_id;
srun_comm.c:		_srun_agent_launch(addr, job_ptr->alloc_node,
srun_comm.c:				   job_ptr->start_protocol_ver);
srun_comm.c:		msg_arg->job_id   = step_ptr->job_ptr->job_id;
srun_comm.c:		msg_arg->job_id   = step_ptr->job_ptr->job_id;
srun_comm.c:		msg_arg->job_id      = step_ptr->job_ptr->job_id;
srun_comm.c:		msg_arg->job_id  = step_ptr->job_ptr->job_id;
srun_comm.c:	job_ptr->time_last_active = now;
Binary file node_scheduler.o matches
burst_buffer.c:		if ((job_ptr->burst_buffer == NULL) ||
burst_buffer.c:		    (job_ptr->burst_buffer[0] == '\0'))
burst_buffer.c:		if ((job_ptr->start_time == 0) ||
burst_buffer.c:		    (job_ptr->start_time > now + 10 * 60 * 60))	/* ten hours */
burst_buffer.c:	if ((job_ptr->burst_buffer == NULL) ||
burst_buffer.c:	    (job_ptr->burst_buffer[0] == '\0'))
burst_buffer.c:	if ((job_ptr->burst_buffer == NULL) ||
burst_buffer.c:	    (job_ptr->burst_buffer[0] == '\0'))
burst_buffer.c:	if ((rc != 0) && (job_ptr->mail_type & MAIL_JOB_STAGE_OUT)) {
burst_buffer.c:		job_ptr->mail_type &= (~MAIL_JOB_STAGE_OUT);
Binary file job_scheduler.o matches
front_end.c:			if (job_ptr->group_id == front_end_ptr->deny_gids[i])
front_end.c:			if (job_ptr->user_id == front_end_ptr->deny_uids[i])
front_end.c:				if (job_ptr->group_id ==
front_end.c:				if (job_ptr->user_id ==
front_end.c:	if (!job_ptr->batch_host && (job_ptr->batch_flag == 0) &&
front_end.c:	    (front_end_ptr = find_front_end_record(job_ptr->alloc_node))) {
front_end.c:			     __func__, job_ptr->alloc_node, job_ptr);
front_end.c:			if (job_ptr->batch_host) { /* Find specific front-end */
front_end.c:				if (xstrcmp(job_ptr->batch_host,
front_end.c:	} else if (job_ptr->batch_host) {    /* Find specific front-end node */
front_end.c:		      job_ptr->batch_host);
front_end.c:		if (job_ptr->batch_host) {
front_end.c:			job_ptr->front_end_ptr =
front_end.c:				find_front_end_record(job_ptr->batch_host);
front_end.c:			if ((job_ptr->front_end_ptr == NULL) &&
front_end.c:				      job_ptr->batch_host, job_ptr);
front_end.c:				job_ptr->job_state = JOB_NODE_FAIL |
front_end.c:			} else if (job_ptr->front_end_ptr == NULL) {
front_end.c:				     job_ptr->batch_host);
front_end.c:				job_ptr->front_end_ptr->job_cnt_comp++;
front_end.c:				job_ptr->front_end_ptr->job_cnt_run++;
front_end.c:			job_ptr->front_end_ptr = NULL;
node_scheduler.c:	xstrcat(job_ptr->gres_alloc, "");
node_scheduler.c:	if (!job_ptr->node_bitmap || !job_ptr->gres_list)
node_scheduler.c:	gres_type_count = list_count(job_ptr->gres_list);
node_scheduler.c:	rv = gres_plugin_job_count(job_ptr->gres_list, gres_type_count,
node_scheduler.c:			xstrfmtcat(job_ptr->gres_alloc, "%s%s:%"PRIu64,
node_scheduler.c:	bitstr_t *	    node_bitmap = job_ptr->node_bitmap;
node_scheduler.c:	xstrcat(job_ptr->gres_alloc, "");
node_scheduler.c:		xstrfmtcat(job_ptr->gres_alloc, "%s%s:%"PRIu64,
node_scheduler.c:		if (!bit_test(job_ptr->node_bitmap, i))
node_scheduler.c:			job_ptr->wait_all_nodes = 1;
node_scheduler.c:			job_ptr->alias_list = xstrdup("TBD");
node_scheduler.c:			job_ptr->wait_all_nodes = 1;
node_scheduler.c:	xfree(job_ptr->alias_list);
node_scheduler.c:		if (!bit_test(job_ptr->node_bitmap, i))
node_scheduler.c:				xfree(job_ptr->alias_list);
node_scheduler.c:				job_ptr->alias_list = xstrdup("TBD");
node_scheduler.c:			if (job_ptr->alias_list)
node_scheduler.c:				xstrcat(job_ptr->alias_list, ",");
node_scheduler.c:			xstrcat(job_ptr->alias_list, node_ptr->name);
node_scheduler.c:			xstrcat(job_ptr->alias_list, ":");
node_scheduler.c:			xstrcat(job_ptr->alias_list, node_ptr->comm_name);
node_scheduler.c:			xstrcat(job_ptr->alias_list, ":");
node_scheduler.c:			xstrcat(job_ptr->alias_list, node_ptr->node_hostname);
node_scheduler.c:	xassert(job_ptr->details);
node_scheduler.c:		 gres_plugin_epilog_build_env(job_ptr->gres_list,job_ptr->nodes);
node_scheduler.c:	kill_job->job_id    = job_ptr->job_id;
node_scheduler.c:	kill_job->pack_jobid = job_ptr->pack_job_id;
node_scheduler.c:	kill_job->job_state = job_ptr->job_state;
node_scheduler.c:	kill_job->job_uid   = job_ptr->user_id;
node_scheduler.c:	kill_job->nodes     = xstrdup(job_ptr->nodes);
node_scheduler.c:	kill_job->start_time = job_ptr->start_time;
node_scheduler.c:			job_ptr->select_jobinfo);
node_scheduler.c:	kill_job->spank_job_env = xduparray(job_ptr->spank_job_env_size,
node_scheduler.c:					    job_ptr->spank_job_env);
node_scheduler.c:	kill_job->spank_job_env_size = job_ptr->spank_job_env_size;
node_scheduler.c:	if (job_ptr->batch_host &&
node_scheduler.c:	    (front_end_ptr = job_ptr->front_end_ptr)) {
node_scheduler.c:			if (job_ptr->node_bitmap_cg) {
node_scheduler.c:				bit_nclear(job_ptr->node_bitmap_cg, 0,
node_scheduler.c:				job_ptr->node_bitmap_cg =
node_scheduler.c:			job_ptr->cpu_cnt  = 0;
node_scheduler.c:			job_ptr->node_cnt = 0;
node_scheduler.c:				if (!bit_test(job_ptr->node_bitmap, i))
node_scheduler.c:		hostlist_push_host(agent_args->hostlist, job_ptr->batch_host);
node_scheduler.c:	if (!job_ptr->node_bitmap_cg)
node_scheduler.c:		if (!bit_test(job_ptr->node_bitmap_cg, i))
node_scheduler.c:			if (job_ptr->node_bitmap_cg == NULL) {
node_scheduler.c:			bit_clear(job_ptr->node_bitmap_cg, i);
node_scheduler.c:			job_ptr->node_cnt--;
node_scheduler.c:		if (job_ptr->details->expanding_jobid == 0) {
node_scheduler.c:	struct job_details *details_ptr = job_ptr->details;
node_scheduler.c:	can_reboot = node_features_g_user_update(job_ptr->user_id);
node_scheduler.c: * job_ptr->details->share_res:
node_scheduler.c: * job_ptr->details->whole_node:
node_scheduler.c:	if (job_ptr->reboot)
node_scheduler.c:		job_ptr->details->whole_node = 1;
node_scheduler.c:		job_ptr->details->share_res = 0;
node_scheduler.c:		job_ptr->details->share_res = 1;
node_scheduler.c:		if ((job_ptr->details->share_res  == 0) ||
node_scheduler.c:		    (job_ptr->details->whole_node == WHOLE_NODE_REQUIRED)) {
node_scheduler.c:			job_ptr->details->share_res = 0;
node_scheduler.c:		job_ptr->details->whole_node = WHOLE_NODE_REQUIRED;
node_scheduler.c:			job_ptr->details->share_res = 0;
node_scheduler.c:		if (job_ptr->details->share_res == 1)
node_scheduler.c:		job_ptr->details->share_res = 0;
node_scheduler.c:	if ((job_ptr->details->whole_node == WHOLE_NODE_USER) ||
node_scheduler.c:	    (job_ptr->part_ptr->flags & PART_FLAG_EXCLUSIVE_USER)) {
node_scheduler.c:			    (job_ptr->user_id == job_ptr2->user_id) ||
node_scheduler.c:		    (node_ptr->owner != job_ptr->user_id))
node_scheduler.c:	if (job_ptr->mcs_label && (mcs_select == 1)) {
node_scheduler.c:			     xstrcmp(node_ptr->mcs_label,job_ptr->mcs_label)) {
node_scheduler.c:	if ((job_ptr->details == NULL) ||
node_scheduler.c:	    ((job_ptr->details->begin_time != 0) &&
node_scheduler.c: 	     ((job_ptr->details->begin_time + job_ptr->delay_boot) <=
node_scheduler.c:			job_ptr->user_id);
node_scheduler.c:	    job_ptr->assoc_ptr &&
node_scheduler.c:			job_ptr->assoc_ptr->acct);
node_scheduler.c:	slurmdb_assoc_rec_t *assoc_ptr = job_ptr->assoc_ptr;
node_scheduler.c:	if (job_ptr->resv_name == NULL) {
node_scheduler.c:	saved_job_min_nodes = job_ptr->details->min_nodes;
node_scheduler.c:	if (job_ptr->details->req_node_bitmap) {
node_scheduler.c:		accumulate_bitmap = job_ptr->details->req_node_bitmap;
node_scheduler.c:		job_ptr->details->req_node_bitmap = NULL;
node_scheduler.c:	saved_min_cpus = job_ptr->details->min_cpus;
node_scheduler.c:	job_ptr->details->min_cpus = 1;
node_scheduler.c:	if (job_ptr->details->feature_list) {
node_scheduler.c:		uint64_t orig_req_mem = job_ptr->details->pn_min_memory;
node_scheduler.c:				job_ptr->details->feature_list);
node_scheduler.c:					      job_ptr->details->features);
node_scheduler.c:			saved_job_num_tasks = job_ptr->details->num_tasks;
node_scheduler.c:			job_ptr->details->min_nodes = feat_ptr->count;
node_scheduler.c:			job_ptr->details->min_cpus = feat_ptr->count;
node_scheduler.c:			job_ptr->details->pn_min_memory = orig_req_mem;
node_scheduler.c:			job_ptr->details->num_tasks = saved_job_num_tasks;
node_scheduler.c:			if (job_ptr->details->pn_min_memory) {
node_scheduler.c:				if (job_ptr->details->pn_min_memory <
node_scheduler.c:						job_ptr->details->pn_min_memory;
node_scheduler.c:					job_ptr->details->pn_min_memory =
node_scheduler.c:				} else if (job_ptr->details->req_node_bitmap) {
node_scheduler.c:					bit_or(job_ptr->details->
node_scheduler.c:					job_ptr->details->req_node_bitmap =
node_scheduler.c:			      job_ptr->details->features);
node_scheduler.c:		FREE_NULL_BITMAP(job_ptr->details->req_node_bitmap);
node_scheduler.c:		job_ptr->details->req_node_bitmap =
node_scheduler.c:		if (job_ptr->details->req_node_bitmap) {
node_scheduler.c:			bit_or(job_ptr->details->req_node_bitmap,
node_scheduler.c:			job_ptr->details->req_node_bitmap = accumulate_bitmap;
node_scheduler.c:		node_cnt = bit_set_count(job_ptr->details->req_node_bitmap);
node_scheduler.c:		job_ptr->details->min_cpus = MAX(saved_min_cpus, node_cnt);
node_scheduler.c:		job_ptr->details->min_nodes = min_nodes;
node_scheduler.c:		job_ptr->details->min_cpus = saved_min_cpus;
node_scheduler.c:		job_ptr->details->min_nodes = saved_job_min_nodes;
node_scheduler.c:	char *tmp_str = bitmap2node_name(job_ptr->details->req_node_bitmap);
node_scheduler.c:					  job_ptr->details->cpu_freq_min,
node_scheduler.c:					  job_ptr->details->cpu_freq_max);
node_scheduler.c:			if (job_ptr->details->min_nodes == 0) {
node_scheduler.c:				job_ptr->details->min_nodes = 1;
node_scheduler.c:			cpus_per_node = job_ptr->details->min_cpus /
node_scheduler.c:					job_ptr->details->min_nodes;
node_scheduler.c:				job_ptr->details->cpu_freq_min = tmp_pcap_cpu_freq;
node_scheduler.c:				job_ptr->details->cpu_freq_max = tmp_pcap_cpu_freq;
node_scheduler.c:				job_ptr->details->cpu_freq_gov = 0x10;
node_scheduler.c:				if ((job_ptr->time_limit != INFINITE) &&
node_scheduler.c:				    (job_ptr->time_limit != NO_VAL))
node_scheduler.c:					job_ptr->time_limit = (ratio *
node_scheduler.c:						  job_ptr->time_limit);
node_scheduler.c:				if ((job_ptr->time_min != INFINITE) &&
node_scheduler.c:				    (job_ptr->time_min != NO_VAL))
node_scheduler.c:					job_ptr->time_min = (ratio *
node_scheduler.c:						  job_ptr->time_min);
node_scheduler.c:	FREE_NULL_BITMAP(job_ptr->details->req_node_bitmap);
node_scheduler.c:	job_ptr->details->req_node_bitmap = saved_req_node_bitmap;
node_scheduler.c:	job_ptr->details->min_cpus = saved_min_cpus;
node_scheduler.c:	job_ptr->details->min_nodes = saved_job_min_nodes;
node_scheduler.c:	uint64_t orig_req_mem = job_ptr->details->pn_min_memory;
node_scheduler.c:	if ((job_ptr->details->min_nodes == 0) &&
node_scheduler.c:	    (job_ptr->details->max_nodes == 0)) {
node_scheduler.c:		job_ptr->cr_enabled = cr_enabled; /* CR enabled for this job */
node_scheduler.c:	if (job_ptr->details->req_node_bitmap) {  /* specific nodes required */
node_scheduler.c:				job_ptr->details->req_node_bitmap);
node_scheduler.c:		if ((job_ptr->details->core_spec != NO_VAL16) &&
node_scheduler.c:		    ((job_ptr->details->core_spec & CORE_SPEC_THREAD) == 0)) {
node_scheduler.c:			i = bit_ffs(job_ptr->details->req_node_bitmap);
node_scheduler.c:			if ((i >= 0) && (job_ptr->details->core_spec >= j)) {
node_scheduler.c:		if (!bit_super_set(job_ptr->details->req_node_bitmap,
node_scheduler.c:		if (job_ptr->details->req_node_bitmap) {
node_scheduler.c:			if (!bit_super_set(job_ptr->details->req_node_bitmap,
node_scheduler.c:			avail_bitmap = bit_copy(job_ptr->details->
node_scheduler.c:			if (job_ptr->details->req_node_bitmap == NULL)
node_scheduler.c:					    tmp_job_ptr->details->share_res ||
node_scheduler.c:					    !tmp_job_ptr->job_resrcs)
node_scheduler.c:					       tmp_job_ptr->job_resrcs->node_bitmap);
node_scheduler.c:			job_ptr->details->pn_min_memory = orig_req_mem;
node_scheduler.c:			if (job_ptr->details->pn_min_memory) {
node_scheduler.c:				if (job_ptr->details->pn_min_memory <
node_scheduler.c:						job_ptr->details->pn_min_memory;
node_scheduler.c:					job_ptr->details->pn_min_memory =
node_scheduler.c:		    ((job_ptr->details->req_node_bitmap == NULL) ||
node_scheduler.c:		     bit_super_set(job_ptr->details->req_node_bitmap,
node_scheduler.c:			job_ptr->details->pn_min_memory = orig_req_mem;
node_scheduler.c:			if (job_ptr->details->pn_min_memory) {
node_scheduler.c:				if (job_ptr->details->pn_min_memory <
node_scheduler.c:						job_ptr->details->pn_min_memory;
node_scheduler.c:					job_ptr->details->pn_min_memory =
node_scheduler.c:		    ((job_ptr->details->req_node_bitmap == NULL) ||
node_scheduler.c:		     (bit_super_set(job_ptr->details->req_node_bitmap,
node_scheduler.c:				job_ptr->details->pn_min_memory = orig_req_mem;
node_scheduler.c:				if (job_ptr->details->pn_min_memory) {
node_scheduler.c:					if (job_ptr->details->pn_min_memory <
node_scheduler.c:							job_ptr->details->
node_scheduler.c:						job_ptr->details->
node_scheduler.c:				job_ptr->details->pn_min_memory = orig_req_mem;
node_scheduler.c:				if (job_ptr->details->pn_min_memory) {
node_scheduler.c:					if (job_ptr->details->pn_min_memory <
node_scheduler.c:							job_ptr->details->
node_scheduler.c:						job_ptr->details->
node_scheduler.c:	} else if (job_ptr->details->req_node_bitmap &&
node_scheduler.c:		   bit_overlap(job_ptr->details->req_node_bitmap,
node_scheduler.c:	} else if (!preempt_flag && job_ptr->details->req_node_bitmap) {
node_scheduler.c:			if (!bit_super_set(job_ptr->details->req_node_bitmap,
node_scheduler.c:			if (bit_overlap(job_ptr->details->req_node_bitmap,
node_scheduler.c:		} else if (!bit_super_set(job_ptr->details->req_node_bitmap,
node_scheduler.c:	} else if (job_ptr->details->req_node_bitmap &&
node_scheduler.c:		   bit_overlap(job_ptr->details->req_node_bitmap,
node_scheduler.c:			ckpt_msg.job_id    = job_ptr->job_id;
node_scheduler.c:				ckpt_msg.job_id    = job_ptr->job_id;
node_scheduler.c:			rc = job_requeue(0, job_ptr->job_id, NULL, true, 0);
node_scheduler.c:			job_ptr->preempt_time = time(NULL);
node_scheduler.c:	if (job_ptr->array_task_id == NO_VAL)
node_scheduler.c:	meta_job_ptr = find_job_record(job_ptr->array_job_id);
node_scheduler.c:	if (!meta_job_ptr || !meta_job_ptr->array_recs) {
node_scheduler.c:	if ((meta_job_ptr->array_recs->tot_run_tasks == 1) &&	/* This task */
node_scheduler.c:	    (meta_job_ptr->array_recs->tot_comp_tasks == 0))
node_scheduler.c:	job_ptr->exit_code = 0;
node_scheduler.c:	gres_plugin_job_clear(job_ptr->gres_list);
node_scheduler.c:	job_ptr->job_state = JOB_RUNNING;
node_scheduler.c:	job_ptr->bit_flags |= JOB_WAS_RUNNING;
node_scheduler.c:	FREE_NULL_BITMAP(job_ptr->node_bitmap);
node_scheduler.c:	xfree(job_ptr->nodes);
node_scheduler.c:	xfree(job_ptr->sched_nodes);
node_scheduler.c:	job_ptr->start_time = now;
node_scheduler.c:	job_ptr->state_reason = WAIT_NO_REASON;
node_scheduler.c:	xfree(job_ptr->state_desc);
node_scheduler.c:	job_ptr->time_last_active = now;
node_scheduler.c:	if (!job_ptr->step_list)
node_scheduler.c:		job_ptr->step_list = list_create(NULL);
node_scheduler.c:	if ((job_ptr->mail_type & MAIL_JOB_BEGIN) &&
node_scheduler.c:	    ((job_ptr->mail_type & MAIL_ARRAY_TASKS) ||
node_scheduler.c:	job_ptr->end_time = now;
node_scheduler.c:	job_ptr->job_state = JOB_COMPLETE;
node_scheduler.c:	if (job_ptr->tres_per_job) {
node_scheduler.c:		xstrfmtcat(tres_str, "PER_JOB:%s", job_ptr->tres_per_job);
node_scheduler.c:	if (job_ptr->tres_per_node) {
node_scheduler.c:			   job_ptr->tres_per_node);
node_scheduler.c:	if (job_ptr->tres_per_socket) {
node_scheduler.c:			   job_ptr->tres_per_socket);
node_scheduler.c:	if (job_ptr->tres_per_task) {
node_scheduler.c:			   job_ptr->tres_per_task);
node_scheduler.c:	xassert(job_ptr->magic == JOB_MAGIC);
node_scheduler.c:	part_ptr = job_ptr->part_ptr;
node_scheduler.c:		part_ptr = find_part_record(job_ptr->partition);
node_scheduler.c:		job_ptr->part_ptr = part_ptr;
node_scheduler.c:		      job_ptr, job_ptr->partition);
node_scheduler.c:	if (job_ptr->qos_ptr)
node_scheduler.c:		qos_flags = job_ptr->qos_ptr->flags;
node_scheduler.c:	if ((error_code = part_policy_valid_qos(job_ptr->part_ptr,
node_scheduler.c:				job_ptr->qos_ptr, job_ptr)) != SLURM_SUCCESS) {
node_scheduler.c:		     job_ptr->part_ptr,
node_scheduler.c:		     job_ptr->assoc_ptr ? job_ptr->assoc_ptr->acct : NULL,
node_scheduler.c:	if (job_ptr->priority == 0) {	/* user/admin hold */
node_scheduler.c:		if (job_ptr->state_reason != FAIL_BAD_CONSTRAINTS
node_scheduler.c:		    && (job_ptr->state_reason != FAIL_BURST_BUFFER_OP)
node_scheduler.c:		    && (job_ptr->state_reason != WAIT_HELD)
node_scheduler.c:		    && (job_ptr->state_reason != WAIT_HELD_USER)
node_scheduler.c:		    && (job_ptr->state_reason != WAIT_MAX_REQUEUE)) {
node_scheduler.c:			job_ptr->state_reason = WAIT_HELD;
node_scheduler.c:		    (job_ptr->state_reason == FAIL_BURST_BUFFER_OP))
node_scheduler.c:		xfree(job_ptr->state_desc);
node_scheduler.c:			job_ptr->state_reason = WAIT_BURST_BUFFER_STAGING;
node_scheduler.c:			job_ptr->state_reason = WAIT_BURST_BUFFER_RESOURCE;
node_scheduler.c:	if ((job_ptr->details->min_nodes == 0) &&
node_scheduler.c:	    (job_ptr->details->max_nodes == 0)) {
node_scheduler.c:		if (!job_ptr->burst_buffer)
node_scheduler.c:	can_reboot = node_features_g_user_update(job_ptr->user_id);
node_scheduler.c:	if (job_ptr->details->req_node_bitmap) {
node_scheduler.c:		error_code = _nodes_in_sets(job_ptr->details->req_node_bitmap,
node_scheduler.c:			     job_ptr, job_ptr->part_ptr->name);
node_scheduler.c:	/* info("req: %u-%u, %u", job_ptr->details->min_nodes, */
node_scheduler.c:	/*    job_ptr->details->max_nodes, part_ptr->max_nodes); */
node_scheduler.c:		if (job_ptr->job_resrcs)
node_scheduler.c:		job_ptr->node_cnt_wag = selected_node_cnt;
node_scheduler.c:	memcpy(tres_req_cnt, job_ptr->tres_req_cnt, sizeof(tres_req_cnt));
node_scheduler.c:		(uint64_t)(job_ptr->total_cpus ?
node_scheduler.c:			   job_ptr->total_cpus : job_ptr->details->min_cpus);
node_scheduler.c:					job_ptr->job_resrcs,
node_scheduler.c:					job_ptr->details->pn_min_memory,
node_scheduler.c:	gres_set_job_tres_cnt(job_ptr->gres_list,
node_scheduler.c:					job_ptr->part_ptr->billing_weights,
node_scheduler.c:		free_job_resources(&job_ptr->job_resrcs);
node_scheduler.c:	job_ptr->cpu_cnt = job_ptr->total_cpus;
node_scheduler.c:		struct job_details *detail_ptr = job_ptr->details;
node_scheduler.c:			job_ptr->preempt_in_progress = true;
node_scheduler.c:			if (job_ptr->array_recs)
node_scheduler.c:				job_ptr->array_recs->pend_run_tasks++;
node_scheduler.c:			job_ptr->state_reason = WAIT_PART_NODE_LIMIT;
node_scheduler.c:			xfree(job_ptr->state_desc);
node_scheduler.c:			job_ptr->state_reason = WAIT_NODE_NOT_AVAIL;
node_scheduler.c:			xfree(job_ptr->state_desc);
node_scheduler.c:			if (job_ptr->details->req_node_bitmap &&
node_scheduler.c:					job_ptr->details->req_node_bitmap)) {
node_scheduler.c:					job_ptr->details->req_node_bitmap);
node_scheduler.c:				xstrfmtcat(job_ptr->state_desc,
node_scheduler.c:				xstrfmtcat(job_ptr->state_desc,
node_scheduler.c:			job_ptr->state_reason = WAIT_NODE_NOT_AVAIL;
node_scheduler.c:			xfree(job_ptr->state_desc);
node_scheduler.c:			xstrfmtcat(job_ptr->state_desc,
node_scheduler.c:			job_ptr->state_reason = WAIT_RESERVATION;
node_scheduler.c:			xfree(job_ptr->state_desc);
node_scheduler.c:		} else if ((job_ptr->state_reason == WAIT_BLOCK_MAX_ERR) ||
node_scheduler.c:			   (job_ptr->state_reason == WAIT_BLOCK_D_ACTION)) {
node_scheduler.c:		} else if ((job_ptr->state_reason == WAIT_HELD) &&
node_scheduler.c:			   (job_ptr->priority == 0)) {
node_scheduler.c:				job_ptr->state_reason = WAIT_POWER_NOT_AVAIL;
node_scheduler.c:				job_ptr->state_reason = WAIT_POWER_RESERVED;
node_scheduler.c:				job_ptr->state_reason = WAIT_RESOURCES;
node_scheduler.c:			xfree(job_ptr->state_desc);
node_scheduler.c:	job_ptr->bit_flags &= ~JOB_KILL_HURRY;
node_scheduler.c:	job_ptr->job_state &= ~JOB_POWER_UP_NODE;
node_scheduler.c:	FREE_NULL_BITMAP(job_ptr->node_bitmap);
node_scheduler.c:	xfree(job_ptr->nodes);
node_scheduler.c:	xfree(job_ptr->sched_nodes);
node_scheduler.c:	job_ptr->exit_code = 0;
node_scheduler.c:	gres_plugin_job_clear(job_ptr->gres_list);
node_scheduler.c:	if (!job_ptr->step_list)
node_scheduler.c:		job_ptr->step_list = list_create(NULL);
node_scheduler.c:	job_ptr->node_bitmap = select_bitmap;
node_scheduler.c:	job_ptr->start_time = job_ptr->time_last_active = now;
node_scheduler.c:	if ((job_ptr->limit_set.time != ADMIN_SET_LIMIT) &&
node_scheduler.c:	    ((job_ptr->time_limit == NO_VAL) ||
node_scheduler.c:	     ((job_ptr->time_limit > part_ptr->max_time) &&
node_scheduler.c:			job_ptr->time_limit = part_ptr->default_time;
node_scheduler.c:			job_ptr->time_limit = part_ptr->max_time;
node_scheduler.c:		job_ptr->limit_set.time = 1;
node_scheduler.c:		job_ptr->start_time = 0;
node_scheduler.c:		job_ptr->time_last_active = 0;
node_scheduler.c:		job_ptr->end_time = 0;
node_scheduler.c:		job_ptr->priority = 0;
node_scheduler.c:		job_ptr->state_reason = WAIT_HELD;
node_scheduler.c:		job_ptr->start_time = 0;
node_scheduler.c:		job_ptr->time_last_active = 0;
node_scheduler.c:		job_ptr->end_time = 0;
node_scheduler.c:		job_ptr->state_reason = WAIT_RESOURCES;
node_scheduler.c:	job_ptr->state_reason = WAIT_NO_REASON;
node_scheduler.c:	xfree(job_ptr->state_desc);
node_scheduler.c:	if (job_ptr->job_resrcs && job_ptr->job_resrcs->nodes)
node_scheduler.c:		job_ptr->nodes = xstrdup(job_ptr->job_resrcs->nodes);
node_scheduler.c:		job_ptr->start_time = 0;
node_scheduler.c:		job_ptr->time_last_active = 0;
node_scheduler.c:		job_ptr->end_time = 0;
node_scheduler.c:		job_ptr->state_reason = WAIT_RESOURCES;
node_scheduler.c:	job_ptr->db_flags &= SLURMDB_JOB_CLEAR_SCHED;
node_scheduler.c:	job_ptr->db_flags |= scheduler_type;
node_scheduler.c:	job_ptr->job_state = JOB_RUNNING;
node_scheduler.c:	job_ptr->bit_flags |= JOB_WAS_RUNNING;
node_scheduler.c:		if (!job_ptr->job_resrcs) {
node_scheduler.c:			job_ptr->start_time = 0;
node_scheduler.c:			job_ptr->time_last_active = 0;
node_scheduler.c:			job_ptr->end_time = 0;
node_scheduler.c:			job_ptr->state_reason = WAIT_RESOURCES;
node_scheduler.c:			job_ptr->job_state = JOB_PENDING;
node_scheduler.c:	if ((job_ptr->mail_type & MAIL_JOB_BEGIN) &&
node_scheduler.c:	    ((job_ptr->mail_type & MAIL_ARRAY_TASKS) ||
node_scheduler.c:		     __func__, job_ptr, tmp, job_ptr->gres_alloc);
node_scheduler.c:	if (bit_overlap(job_ptr->node_bitmap, power_node_bitmap))
node_scheduler.c:		job_ptr->job_state |= JOB_POWER_UP_NODE;
node_scheduler.c:	    !bit_super_set(job_ptr->node_bitmap, avail_node_bitmap)) {
node_scheduler.c:		job_ptr->job_state |= JOB_CONFIGURING;
node_scheduler.c:		if (job_ptr->batch_flag)
node_scheduler.c:	if (job_ptr->array_recs && job_ptr->array_recs->task_id_bitmap &&
node_scheduler.c:	    (bit_ffs(job_ptr->array_recs->task_id_bitmap) != -1)) {
node_scheduler.c:		job_ptr->array_task_id = NO_VAL;
node_scheduler.c:		FREE_NULL_BITMAP(job_ptr->node_bitmap);
node_scheduler.c:		*min_nodes = job_ptr->details->min_nodes;
node_scheduler.c:		*min_nodes = MAX(job_ptr->details->min_nodes,
node_scheduler.c:	if (!job_ptr->details->max_nodes)
node_scheduler.c:		*max_nodes = job_ptr->details->max_nodes;
node_scheduler.c:		*max_nodes = MIN(job_ptr->details->max_nodes,
node_scheduler.c:	if (job_ptr->details->req_node_bitmap && job_ptr->details->max_nodes) {
node_scheduler.c:		i = bit_set_count(job_ptr->details->req_node_bitmap);
node_scheduler.c:		if (i > job_ptr->details->max_nodes) {
node_scheduler.c:			     job_ptr, i, job_ptr->details->max_nodes);
node_scheduler.c:	if (!job_ptr->limit_set.tres[TRES_ARRAY_NODE] &&
node_scheduler.c:	    job_ptr->details->max_nodes &&
node_scheduler.c:	    !(job_ptr->bit_flags & USE_MIN_NODES))
node_scheduler.c:		xfree(job_ptr->state_desc);
node_scheduler.c:		job_ptr->state_reason = wait_reason;
node_scheduler.c:	if (job_ptr->batch_flag)
node_scheduler.c:		job_ptr->state_reason = WAIT_PROLOG;
node_scheduler.c:		 gres_plugin_epilog_build_env(job_ptr->gres_list,job_ptr->nodes);
node_scheduler.c:	prolog_msg_ptr->job_id = job_ptr->job_id;
node_scheduler.c:	prolog_msg_ptr->pack_job_id = job_ptr->pack_job_id;
node_scheduler.c:	prolog_msg_ptr->uid = job_ptr->user_id;
node_scheduler.c:	prolog_msg_ptr->gid = job_ptr->group_id;
node_scheduler.c:	if (!job_ptr->user_name)
node_scheduler.c:		job_ptr->user_name = uid_to_string_or_null(job_ptr->user_id);
node_scheduler.c:	prolog_msg_ptr->user_name = xstrdup(job_ptr->user_name);
node_scheduler.c:	prolog_msg_ptr->alias_list = xstrdup(job_ptr->alias_list);
node_scheduler.c:	prolog_msg_ptr->nodes = xstrdup(job_ptr->nodes);
node_scheduler.c:	prolog_msg_ptr->partition = xstrdup(job_ptr->partition);
node_scheduler.c:	prolog_msg_ptr->std_err = xstrdup(job_ptr->details->std_err);
node_scheduler.c:	prolog_msg_ptr->std_out = xstrdup(job_ptr->details->std_out);
node_scheduler.c:	prolog_msg_ptr->work_dir = xstrdup(job_ptr->details->work_dir);
node_scheduler.c:	prolog_msg_ptr->x11 = job_ptr->details->x11;
node_scheduler.c:				xstrdup(job_ptr->details->x11_magic_cookie);
node_scheduler.c:		prolog_msg_ptr->x11_alloc_host = xstrdup(job_ptr->resp_host);
node_scheduler.c:		prolog_msg_ptr->x11_alloc_port = job_ptr->other_port;
node_scheduler.c:		prolog_msg_ptr->x11_target = xstrdup(job_ptr->details->x11_target);
node_scheduler.c:		prolog_msg_ptr->x11_target_port = job_ptr->details->x11_target_port;
node_scheduler.c:	prolog_msg_ptr->spank_job_env_size = job_ptr->spank_job_env_size;
node_scheduler.c:	prolog_msg_ptr->spank_job_env = xduparray(job_ptr->spank_job_env_size,
node_scheduler.c:						  job_ptr->spank_job_env);
node_scheduler.c:	xassert(job_ptr->job_resrcs);
node_scheduler.c:	job_resrcs_ptr = job_ptr->job_resrcs;
node_scheduler.c:	cred_arg.jobid               = job_ptr->job_id;
node_scheduler.c:	cred_arg.uid                 = job_ptr->user_id;
node_scheduler.c:	cred_arg.gid                 = job_ptr->group_id;
node_scheduler.c:	cred_arg.x11                 = job_ptr->details->x11;
node_scheduler.c:	cred_arg.job_core_spec       = job_ptr->details->core_spec;
node_scheduler.c:	cred_arg.job_gres_list       = job_ptr->gres_list;
node_scheduler.c:	cred_arg.job_nhosts          = job_ptr->job_resrcs->nhosts;
node_scheduler.c:	cred_arg.job_constraints     = job_ptr->details->features;
node_scheduler.c:	cred_arg.job_mem_limit       = job_ptr->details->pn_min_memory;
node_scheduler.c:	cred_arg.step_mem_limit      = job_ptr->details->pn_min_memory;
node_scheduler.c:	xassert(job_ptr->batch_host);
node_scheduler.c:	cred_arg.job_hostlist    = job_ptr->batch_host;
node_scheduler.c:	cred_arg.step_hostlist   = job_ptr->batch_host;
node_scheduler.c:	cred_arg.job_hostlist    = job_ptr->job_resrcs->nodes;
node_scheduler.c:	cred_arg.step_hostlist   = job_ptr->job_resrcs->nodes;
node_scheduler.c:	xassert(job_ptr->front_end_ptr);
node_scheduler.c:	xassert(job_ptr->front_end_ptr->name);
node_scheduler.c:		job_ptr->front_end_ptr->protocol_version;
node_scheduler.c:	agent_arg_ptr->hostlist = hostlist_create(job_ptr->front_end_ptr->name);
node_scheduler.c:	agent_arg_ptr->hostlist = hostlist_create(job_ptr->nodes);
node_scheduler.c:		if (bit_test(job_ptr->node_bitmap, i) == 0)
node_scheduler.c:	agent_arg_ptr->node_count = job_ptr->node_cnt;
node_scheduler.c:	if (!job_ptr->gres_list || (list_count(job_ptr->gres_list) == 0)) {
node_scheduler.c:		if (job_ptr->gres_req == NULL)
node_scheduler.c:			xstrcat(job_ptr->gres_req, "");
node_scheduler.c:	} else if ((job_ptr->node_cnt > 0) && !job_ptr->gres_req) {
node_scheduler.c:		job_ptr->gres_req =
node_scheduler.c:			gres_plugin_job_alloc_count(job_ptr->gres_list);
node_scheduler.c:	if (!job_ptr->gres_alloc || (job_ptr->gres_alloc[0] == '\0') ) {
node_scheduler.c:			     __func__, job_ptr, tmp, job_ptr->gres_alloc);
node_scheduler.c:	struct job_details *detail_ptr = job_ptr->details;
node_scheduler.c:	user_update = node_features_g_user_update(job_ptr->user_id);
node_scheduler.c:				if (job_ptr->job_id) {
node_scheduler.c:	struct job_details *detail_ptr = job_ptr->details;
node_scheduler.c:	struct part_record *part_ptr = job_ptr->part_ptr;
node_scheduler.c:	struct job_details *detail_ptr = job_ptr->details;
node_scheduler.c:	if (job_ptr->resv_name) {
node_scheduler.c:			job_ptr->state_reason = WAIT_RESERVATION;
node_scheduler.c:			xfree(job_ptr->state_desc);
node_scheduler.c:			job_ptr->state_reason = WAIT_RESERVATION;
node_scheduler.c:			xfree(job_ptr->state_desc);
node_scheduler.c:		if (job_ptr->resv_ptr &&
node_scheduler.c:		    (job_ptr->resv_ptr->flags & RESERVE_FLAG_FLEX) &&
node_scheduler.c:		    job_ptr->resv_ptr->node_bitmap &&
node_scheduler.c:				   job_ptr->resv_ptr->node_bitmap)) {
node_scheduler.c:				bit_copy(job_ptr->resv_ptr->node_bitmap);
node_scheduler.c:					job_ptr->details->feature_list,
node_scheduler.c:		     __func__, job_ptr, job_ptr->part_ptr->name);
node_scheduler.c:		xfree(job_ptr->state_desc);
node_scheduler.c:		if (job_ptr->resv_name) {
node_scheduler.c:			job_ptr->state_reason = WAIT_RESERVATION;
node_scheduler.c:			job_ptr->state_reason = FAIL_BAD_CONSTRAINTS;
node_scheduler.c:			       job_reason_string(job_ptr->state_reason),
node_scheduler.c:	if ((job_ptr->node_bitmap == NULL) || (job_ptr->nodes == NULL)) {
node_scheduler.c:		job_ptr->node_cnt = 0;
node_scheduler.c:		xfree(job_ptr->node_addr);
node_scheduler.c:	if ((host_list = hostlist_create(job_ptr->nodes)) == NULL)
node_scheduler.c:		fatal("hostlist_create error for %s: %m", job_ptr->nodes);
node_scheduler.c:	job_ptr->total_nodes = job_ptr->node_cnt = hostlist_count(host_list);
node_scheduler.c:	if (job_ptr->details->ntasks_per_node && job_ptr->details->num_tasks)
node_scheduler.c:		job_ptr->details->num_tasks = job_ptr->node_cnt *
node_scheduler.c:			job_ptr->details->ntasks_per_node;
node_scheduler.c:	xrecalloc(job_ptr->node_addr, job_ptr->node_cnt, sizeof(slurm_addr_t));
node_scheduler.c:		xfree(job_ptr->batch_host);
node_scheduler.c:		job_ptr->front_end_ptr = assign_front_end(job_ptr);
node_scheduler.c:		if (job_ptr->front_end_ptr) {
node_scheduler.c:			job_ptr->batch_host = xstrdup(job_ptr->
node_scheduler.c:	} else if (job_ptr->batch_host) {
node_scheduler.c:		job_ptr->front_end_ptr = assign_front_end(job_ptr);
node_scheduler.c:		if (!job_ptr->front_end_ptr)
node_scheduler.c:			xfree(job_ptr->batch_host);
node_scheduler.c:	xfree(job_ptr->batch_host);
node_scheduler.c:			memcpy(&job_ptr->node_addr[node_inx++],
node_scheduler.c:		if (!job_ptr->batch_host && !job_ptr->batch_features) {
node_scheduler.c:			job_ptr->batch_host = xstrdup(this_node_name);
node_scheduler.c:	if (job_ptr->node_cnt != node_inx) {
node_scheduler.c:		      job_ptr, job_ptr->node_cnt, node_inx);
node_scheduler.c:	if (job_ptr->batch_host)
node_scheduler.c:	if (!job_ptr->node_bitmap) {
node_scheduler.c:	i_first = bit_ffs(job_ptr->node_bitmap);
node_scheduler.c:	if (!job_ptr->batch_features) {
node_scheduler.c:		job_ptr->batch_host = xstrdup(node_ptr->name);
node_scheduler.c:	feature_bitmap = bit_copy(job_ptr->node_bitmap);
node_scheduler.c:	tmp = xstrdup(job_ptr->batch_features);
node_scheduler.c:	bit_and(feature_bitmap, job_ptr->node_bitmap);
node_scheduler.c:	job_ptr->batch_host = xstrdup(node_ptr->name);
node_scheduler.c:	struct job_details *details_ptr = job_ptr->details;
node_scheduler.c:	xassert(job_ptr->details);
node_scheduler.c:		gres_plugin_epilog_build_env(job_ptr->gres_list,job_ptr->nodes);
node_scheduler.c:	kill_job->job_id    = job_ptr->job_id;
node_scheduler.c:	kill_job->pack_jobid = job_ptr->pack_job_id;
node_scheduler.c:	kill_job->job_uid   = job_ptr->user_id;
node_scheduler.c:	kill_job->job_state = job_ptr->job_state;
node_scheduler.c:	kill_job->start_time = job_ptr->start_time;
node_scheduler.c:				   job_ptr->select_jobinfo);
node_scheduler.c:	kill_job->spank_job_env = xduparray(job_ptr->spank_job_env_size,
node_scheduler.c:					    job_ptr->spank_job_env);
node_scheduler.c:	kill_job->spank_job_env_size = job_ptr->spank_job_env_size;
node_scheduler.c:	step_iterator = list_iterator_create(job_ptr->step_list);
node_scheduler.c:	if (job_ptr->batch_host &&
node_scheduler.c:	    (front_end_ptr = find_front_end_record(job_ptr->batch_host))) {
node_scheduler.c:				if ((job_ptr->node_bitmap_cg == NULL) ||
node_scheduler.c:				    (!bit_test(job_ptr->node_bitmap_cg, i)))
node_scheduler.c:				bit_clear(job_ptr->node_bitmap_cg, i);
node_scheduler.c:				if ((job_ptr->node_cnt > 0) &&
node_scheduler.c:				    ((--job_ptr->node_cnt) == 0)) {
node_scheduler.c:						  job_ptr->batch_host);
node_scheduler.c:				      job_ptr->batch_host);
node_scheduler.c:		if ((job_ptr->node_bitmap_cg == NULL) ||
node_scheduler.c:		    (bit_test(job_ptr->node_bitmap_cg, i) == 0)) {
node_scheduler.c:			bit_clear(job_ptr->node_bitmap_cg, i);
node_scheduler.c:			if ((job_ptr->node_cnt > 0) &&
node_scheduler.c:			    ((--job_ptr->node_cnt) == 0)) {
node_scheduler.c:	if (job_ptr->job_id != last_job_id) {
node_scheduler.c:	last_job_id = job_ptr->job_id;
Binary file fed_mgr.o matches
reservation.c:		    (job_ptr->end_time > start_time)	&&
reservation.c:		    (bit_overlap(job_ptr->node_bitmap, node_bitmap) > 0) &&
reservation.c:		     (xstrcmp(resv_name, job_ptr->resv_name) != 0))) {
reservation.c:		    (job_ptr->resv_id == resv_ptr->resv_id)) {
reservation.c:		if (job_ptr->resv_ptr != resv_ptr)
reservation.c:			     job_ptr, job_ptr->resv_name);
reservation.c:		job_ptr->resv_id = 0;
reservation.c:		job_ptr->resv_ptr = NULL;
reservation.c:		xfree(job_ptr->resv_name);
reservation.c:		    (job_ptr->state_reason != WAIT_HELD)) {
reservation.c:			xfree(job_ptr->state_desc);
reservation.c:			job_ptr->state_reason = WAIT_RESV_DELETED;
reservation.c:			job_ptr->job_state |= JOB_RESV_DEL_HOLD;
reservation.c:			xstrfmtcat(job_ptr->state_desc,
reservation.c:			job_ptr->priority = 0;	/* Hold job */
reservation.c:		if (job_ptr->resv_name == NULL)
reservation.c:		if ((job_ptr->resv_ptr == NULL) ||
reservation.c:		    (job_ptr->resv_ptr->magic != RESV_MAGIC)) {
reservation.c:			job_ptr->resv_ptr = (slurmctld_resv_t *)
reservation.c:							job_ptr->resv_name);
reservation.c:		if (!job_ptr->resv_ptr) {
reservation.c:			       job_ptr, job_ptr->resv_name);
reservation.c:			job_ptr->resv_id = 0;
reservation.c:			xfree(job_ptr->resv_name);
reservation.c:	if ((job_ptr->resv_name == NULL) || (job_ptr->resv_name[0] == '\0')) {
reservation.c:		xfree(job_ptr->resv_name);
reservation.c:		job_ptr->resv_id    = 0;
reservation.c:		job_ptr->resv_ptr   = NULL;
reservation.c:			_find_resv_name, job_ptr->resv_name);
reservation.c:		job_ptr->resv_id    = resv_ptr->resv_id;
reservation.c:		job_ptr->resv_ptr   = resv_ptr;
reservation.c:		job_ptr->details = xmalloc(sizeof(struct job_details));
reservation.c:		job_ptr->details->features = resv_desc_ptr->features;
reservation.c:		/* job_ptr->job_id = 0; */
reservation.c:		/* job_ptr->user_id = 0; */
reservation.c:		    list_find_first(job_ptr->details->feature_list,
reservation.c:			find_feature_nodes(job_ptr->details->feature_list,
reservation.c:		} else if (list_find_first(job_ptr->details->feature_list,
reservation.c:						job_ptr->details->feature_list);
reservation.c:		FREE_NULL_LIST(job_ptr->details->feature_list);
reservation.c:		xfree(job_ptr->details);
reservation.c:	job_resources_t *job_res = job_ptr->job_resrcs;
reservation.c:				if (bit_test(job_ptr->job_resrcs->core_bitmap,
reservation.c:		if (job_ptr->end_time < resv_desc_ptr->start_time)
reservation.c:			bit_and_not(avail_bitmap, job_ptr->node_bitmap);
reservation.c:			if (job_ptr->end_time < resv_desc_ptr->start_time)
reservation.c:			bit_and(tmp_bitmap, job_ptr->node_bitmap);
reservation.c:		info("Reservation name not found (%s)", job_ptr->resv_name);
reservation.c:		if (!job_ptr->assoc_ptr) {
reservation.c:			assoc_rec.id = job_ptr->assoc_id;
reservation.c:				    &job_ptr->assoc_ptr, false))
reservation.c:			assoc = job_ptr->assoc_ptr;
reservation.c:			assoc = job_ptr->assoc_ptr;
reservation.c:			if (job_ptr->user_id == resv_ptr->user_list[i]) {
reservation.c:		for (i=0; (i<resv_ptr->account_cnt) && job_ptr->account; i++) {
reservation.c:			    (xstrcmp(job_ptr->account,
reservation.c:	     job_ptr->user_id, job_ptr->account, resv_ptr->name);
reservation.c:	if (job_ptr->resv_name == NULL)
reservation.c:			_find_resv_name, job_ptr->resv_name);
reservation.c:	job_ptr->resv_ptr = resv_ptr;
reservation.c:	if (job_ptr->resv_name == NULL)
reservation.c:			_find_resv_name, job_ptr->resv_name);
reservation.c:		if (job_ptr->resv_ptr == resv_ptr)
reservation.c:		if (resv_ptr->start_time >= job_ptr->end_time)
reservation.c:		if (!license_list_overlap(job_ptr->license_list,
reservation.c:				  job_ptr->node_bitmap) == 0)))
reservation.c:		job_ptr->time_limit = MIN(job_ptr->time_limit,resv_begin_time);
reservation.c:	job_ptr->time_limit = MAX(job_ptr->time_limit, job_ptr->time_min);
reservation.c:	if (job_ptr->time_limit == INFINITE)
reservation.c:	else if (job_ptr->time_limit != NO_VAL)
reservation.c:		duration = (job_ptr->time_limit * 60);
reservation.c:		if (job_ptr->part_ptr->max_time == INFINITE)
reservation.c:			duration = (job_ptr->part_ptr->max_time * 60);
reservation.c:	if (job_ptr->part_ptr)
reservation.c:		time_slices = job_ptr->part_ptr->max_share & ~SHARED_FORCE;
reservation.c:	if ((job_ptr->burst_buffer == NULL) ||
reservation.c:	    (job_ptr->burst_buffer[0] == '\0'))
reservation.c:		if (!xstrcmp(job_ptr->resv_name, resv_ptr->name))
reservation.c:		if (job_ptr->resv_name &&
reservation.c:		    (xstrcmp(job_ptr->resv_name, resv_ptr->name) == 0))
reservation.c:		if (job_ptr->resv_name &&
reservation.c:		    (xstrcmp(job_ptr->resv_name, resv_ptr->name) == 0))
reservation.c:	if (job_ptr->resv_name) {
reservation.c:				_find_resv_name, job_ptr->resv_name);
reservation.c:		job_ptr->resv_ptr = resv_ptr;
reservation.c:		if (job_ptr->resv_id != resv_ptr->resv_id) {
reservation.c:			job_ptr->resv_id = resv_ptr->resv_id;
reservation.c:				    ((job_ptr->details) &&
reservation.c:				     (job_ptr->details->begin_time >
reservation.c:					job_ptr->priority = 0;	/* admin hold */
reservation.c:			if (job_ptr->details->req_node_bitmap &&
reservation.c:			    !bit_super_set(job_ptr->details->req_node_bitmap,
reservation.c:			     __func__, job_ptr, job_ptr->resv_name, nodes);
reservation.c:	job_ptr->resv_ptr = NULL;	/* should be redundant */
reservation.c:			     job_ptr->part_ptr == resv_ptr->part_ptr)) {
reservation.c:			if (job_ptr->details->req_node_bitmap &&
reservation.c:			    bit_overlap(job_ptr->details->req_node_bitmap,
reservation.c:			     job_ptr->details->whole_node == 1)) {
reservation.c:			if (license_list_overlap(job_ptr->license_list,
reservation.c:			    (job_ptr->details->whole_node == 1)) {
reservation.c:			if(!job_ptr->part_ptr ||
reservation.c:			    bit_overlap(job_ptr->part_ptr->node_bitmap,
reservation.c:	if (!job_ptr->resv_ptr)
reservation.c:	xassert(job_ptr->resv_ptr->magic == RESV_MAGIC);
reservation.c:		job_ptr->resv_ptr->job_run_cnt++;
reservation.c:		job_ptr->resv_ptr->job_pend_cnt++;
reservation.c:	if ((job_ptr->resv_ptr != resv_ptr) || !IS_JOB_PENDING(job_ptr))
reservation.c:		     job_ptr, job_ptr->resv_id, resv_ptr->resv_id,
reservation.c:	job_ptr->resv_id = resv_ptr->resv_id;
reservation.c:		    !xstrcmp(job_ptr->resv_name, resv_ptr->name))
controller.c:		if ((rec != job_ptr->assoc_ptr) || (!IS_JOB_PENDING(job_ptr)))
controller.c:		if ((rec != job_ptr->qos_ptr) || (!IS_JOB_PENDING(job_ptr)))
controller.c:	if (assoc_mgr_set_tres_cnt_array(&job_ptr->tres_req_cnt,
controller.c:					 job_ptr->tres_req_str,
controller.c:	if (assoc_mgr_set_tres_cnt_array(&job_ptr->tres_alloc_cnt,
controller.c:					 job_ptr->tres_alloc_str,
controller.c:	update_job_limit_set_tres(&job_ptr->limit_set.tres);
controller.c:		if (job_ptr->assoc_id) {
controller.c:			assoc_rec.id = job_ptr->assoc_id;
controller.c:			      (size_t)job_ptr->assoc_ptr, job_ptr->assoc_id,
controller.c:				    &job_ptr->assoc_ptr, true)) {
controller.c:					job_ptr->assoc_id, job_ptr);
controller.c:			      (size_t)job_ptr->assoc_ptr, job_ptr->assoc_id,
controller.c:		if (job_ptr->qos_id) {
controller.c:			qos_rec.id = job_ptr->qos_id;
controller.c:				    (slurmdb_qos_rec_t **)&job_ptr->qos_ptr,
controller.c:					job_ptr->qos_id, job_ptr);
controller.c:		int job_cnt = (job_ptr->array_recs &&
controller.c:			       job_ptr->array_recs->task_cnt) ?
controller.c:			job_ptr->array_recs->task_cnt : 1;
preempt.c:	if (job_ptr->preempt_time)
preempt.c:	job_ptr->preempt_time = time(NULL);
preempt.c:	job_ptr->end_time = MIN(job_ptr->end_time,
preempt.c:				(job_ptr->preempt_time + (time_t)grace_time));
preempt.c:	if (preempt_send_user_signal && job_ptr->warn_signal &&
preempt.c:	    !(job_ptr->warn_flags & WARN_SENT))
preempt.c:	if (job_ptr->preempt_time) {
preempt.c:		if (time(NULL) >= job_ptr->end_time)
preempt.c:		grace_time = job_ptr->part_ptr->grace_time;
preempt.c:		if (!job_ptr->qos_ptr)
preempt.c:			grace_time = job_ptr->qos_ptr->grace_time;
acct_policy.c:	if (job_ptr->job_resrcs && job_ptr->job_resrcs->node_bitmap) {
acct_policy.c:			job_ptr->job_resrcs->node_bitmap);
acct_policy.c:	if (job_ptr->job_resrcs && job_ptr->job_resrcs->node_bitmap &&
acct_policy.c:			job_ptr->job_resrcs->node_bitmap, grp_node_bitmap);
acct_policy.c:				job_ptr->job_resrcs->node_bitmap);
acct_policy.c:	} else if (job_ptr->details && job_ptr->details->req_node_bitmap &&
acct_policy.c:			job_ptr->details->req_node_bitmap, grp_node_bitmap);
acct_policy.c:	if (!job_ptr->job_resrcs || !job_ptr->job_resrcs->node_bitmap) {
acct_policy.c:		if (IS_JOB_PENDING(job_ptr) && job_ptr->pack_job_id) {
acct_policy.c:		} else if (job_ptr->node_cnt == 0) {
acct_policy.c:		bit_or(*grp_node_bitmap, job_ptr->job_resrcs->node_bitmap);
acct_policy.c:		*grp_node_bitmap = bit_copy(job_ptr->job_resrcs->node_bitmap);
acct_policy.c:	i_first = bit_ffs(job_ptr->job_resrcs->node_bitmap);
acct_policy.c:		i_last = bit_fls(job_ptr->job_resrcs->node_bitmap);
acct_policy.c:		if (bit_test(job_ptr->job_resrcs->node_bitmap, i))
acct_policy.c:	if (!job_ptr->job_resrcs || !job_ptr->job_resrcs->node_bitmap) {
acct_policy.c:		if (IS_JOB_PENDING(job_ptr) && job_ptr->pack_job_id) {
acct_policy.c:		} else if (job_ptr->node_cnt == 0) {
acct_policy.c:	i_first = bit_ffs(job_ptr->job_resrcs->node_bitmap);
acct_policy.c:		i_last = bit_fls(job_ptr->job_resrcs->node_bitmap);
acct_policy.c:		if (!bit_test(job_ptr->job_resrcs->node_bitmap, i))
acct_policy.c:	if ((job_ptr->assoc_ptr == NULL) ||
acct_policy.c:	    (job_ptr->assoc_ptr->id  != job_ptr->assoc_id) ||
acct_policy.c:	    (job_ptr->assoc_ptr->uid != job_ptr->user_id)) {
acct_policy.c:		assoc_rec.acct      = job_ptr->account;
acct_policy.c:		if (job_ptr->part_ptr)
acct_policy.c:			assoc_rec.partition = job_ptr->part_ptr->name;
acct_policy.c:		assoc_rec.uid       = job_ptr->user_id;
acct_policy.c:					    &job_ptr->assoc_ptr, false)) {
acct_policy.c:			     __func__, job_ptr->user_id, job_ptr);
acct_policy.c:		job_ptr->assoc_id = assoc_rec.id;
acct_policy.c:	if (!qos_ptr || !job_ptr->assoc_ptr)
acct_policy.c:		job_ptr->assoc_ptr->acct);
acct_policy.c:		job_ptr->user_id);
acct_policy.c:			used_limits->tres[i] += job_ptr->tres_alloc_cnt[i];
acct_policy.c:			used_limits_a->tres[i] += job_ptr->tres_alloc_cnt[i];
acct_policy.c:				job_ptr->tres_alloc_cnt[i];
acct_policy.c:		if (!job_ptr->tres_alloc_cnt)
acct_policy.c:			if (job_ptr->tres_alloc_cnt[i] >
acct_policy.c:					job_ptr->tres_alloc_cnt[i];
acct_policy.c:			if (job_ptr->tres_alloc_cnt[i] > used_limits->tres[i]) {
acct_policy.c:					job_ptr->tres_alloc_cnt[i];
acct_policy.c:			if (job_ptr->tres_alloc_cnt[i] >
acct_policy.c:					job_ptr->tres_alloc_cnt[i];
acct_policy.c:		uint64_t time_limit_secs = (uint64_t)job_ptr->time_limit * 60;
acct_policy.c:		if (job_ptr->qos_ptr &&
acct_policy.c:		    (job_ptr->qos_ptr->usage_factor >= 0))
acct_policy.c:			time_limit_secs *= job_ptr->qos_ptr->usage_factor;
acct_policy.c:				job_ptr->tres_alloc_cnt[i] * time_limit_secs;
acct_policy.c:		   job_ptr->array_recs && job_ptr->array_recs->task_cnt)
acct_policy.c:		job_cnt = job_ptr->array_recs->task_cnt;
acct_policy.c:	 * (!job_ptr->tres_alloc_str).
acct_policy.c:	    job_ptr->part_ptr_list &&
acct_policy.c:	    (IS_JOB_PENDING(job_ptr) || !job_ptr->tres_alloc_str)) {
acct_policy.c:		if (job_ptr->qos_ptr &&
acct_policy.c:		    (((slurmdb_qos_rec_t *)job_ptr->qos_ptr)->flags
acct_policy.c:			_qos_adjust_limit_usage(type, job_ptr, job_ptr->qos_ptr,
acct_policy.c:			list_push(part_qos_list, job_ptr->qos_ptr);
acct_policy.c:		part_itr = list_iterator_create(job_ptr->part_ptr_list);
acct_policy.c:				     job_ptr->qos_ptr)))
acct_policy.c:			_qos_adjust_limit_usage(type, job_ptr, job_ptr->qos_ptr,
acct_policy.c:		    job_ptr->part_ptr_list) {
acct_policy.c:			if (job_ptr->qos_ptr)
acct_policy.c:				list_push(part_qos_list, job_ptr->qos_ptr);
acct_policy.c:			if (job_ptr->part_ptr && job_ptr->part_ptr->qos_ptr &&
acct_policy.c:			    job_ptr->qos_ptr != job_ptr->part_ptr->qos_ptr)
acct_policy.c:					  job_ptr->part_ptr->qos_ptr);
acct_policy.c:			part_itr = list_iterator_create(job_ptr->part_ptr_list);
acct_policy.c:	assoc_ptr = job_ptr->assoc_ptr;
acct_policy.c:						job_ptr->tres_alloc_cnt[i];
acct_policy.c:				if (job_ptr->tres_alloc_cnt[i] >
acct_policy.c:						job_ptr->tres_alloc_cnt[i];
acct_policy.c:	slurmdb_assoc_rec_t *assoc_ptr = job_ptr->assoc_ptr;
acct_policy.c:		job_ptr->user_id);
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = WAIT_QOS_GRP_JOB;
acct_policy.c:	if ((job_ptr->limit_set.time != ADMIN_SET_LIMIT)
acct_policy.c:			time_limit = job_ptr->time_limit;
acct_policy.c:					job_ptr->part_ptr->max_time,
acct_policy.c:					&job_ptr->limit_set.time);
acct_policy.c:			if ((job_ptr->qos_ptr &&
acct_policy.c:			     (job_ptr->qos_ptr->usage_factor >= 0)) &&
acct_policy.c:			     (job_ptr->qos_ptr->usage_factor < 1.0))) {
acct_policy.c:				time_limit *= job_ptr->qos_ptr->usage_factor;
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = WAIT_QOS_GRP_WALL;
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = WAIT_QOS_GRP_WALL;
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason =
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason =
acct_policy.c:	if ((job_ptr->limit_set.time != ADMIN_SET_LIMIT)
acct_policy.c:			time_limit = job_ptr->time_limit;
acct_policy.c:					job_ptr->part_ptr->max_time,
acct_policy.c:					&job_ptr->limit_set.time);
acct_policy.c:		if ((job_ptr->qos_ptr &&
acct_policy.c:		     (job_ptr->qos_ptr->usage_factor >= 0)) &&
acct_policy.c:		     (job_ptr->qos_ptr->usage_factor < 1.0))) {
acct_policy.c:			time_limit *= job_ptr->qos_ptr->usage_factor;
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason =
acct_policy.c:	slurmdb_assoc_rec_t *assoc_ptr = job_ptr->assoc_ptr;
acct_policy.c:	if (job_ptr->qos_ptr &&
acct_policy.c:	    (job_ptr->qos_ptr->usage_factor >= 0))
acct_policy.c:		usage_factor = job_ptr->qos_ptr->usage_factor;
acct_policy.c:		job_ptr->user_id);
acct_policy.c:		tres_run_mins, tres_usage_mins, job_ptr->limit_set.tres,
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:		NULL, job_ptr->limit_set.tres, true);
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:					   job_ptr->limit_set.tres,
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:					   job_ptr->limit_set.tres,
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:					   job_ptr->limit_set.tres,
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:					   job_ptr->limit_set.tres,
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:		NULL, job_ptr->limit_set.tres, true);
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:		NULL, job_ptr->limit_set.tres, true);
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:		job_ptr->qos_blocking_ptr = qos_ptr;
acct_policy.c:		job_ptr->state_reason = FAIL_TIMEOUT;
acct_policy.c:			job_ptr->state_reason = FAIL_TIMEOUT;
acct_policy.c:		job_ptr->state_reason = FAIL_TIMEOUT;
acct_policy.c:	if (job_ptr->end_time_exp != (time_t)NO_VAL)
acct_policy.c:	if (!IS_JOB_RUNNING(job_ptr) || (job_ptr->time_limit == new_time_limit))
acct_policy.c:	time_limit_secs = (uint64_t)job_ptr->time_limit * 60;
acct_policy.c:			job_ptr->tres_alloc_cnt[i] * time_limit_secs;
acct_policy.c:			job_ptr->tres_alloc_cnt[i] * new_time_limit_secs;
acct_policy.c:	assoc_ptr = job_ptr->assoc_ptr;
acct_policy.c:	if ((job_ptr->state_reason >= WAIT_QOS_GRP_CPU
acct_policy.c:	     && job_ptr->state_reason <= WAIT_ASSOC_MAX_SUB_JOB) ||
acct_policy.c:	    (job_ptr->state_reason == WAIT_ASSOC_JOB_LIMIT) ||
acct_policy.c:	    (job_ptr->state_reason == WAIT_ASSOC_RESOURCE_LIMIT) ||
acct_policy.c:	    (job_ptr->state_reason == WAIT_ASSOC_TIME_LIMIT) ||
acct_policy.c:	    (job_ptr->state_reason == WAIT_QOS_JOB_LIMIT) ||
acct_policy.c:	    (job_ptr->state_reason == WAIT_QOS_TIME_LIMIT)) {
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = FAIL_ACCOUNT;
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = WAIT_NO_REASON;
acct_policy.c:	assoc_ptr = job_ptr->assoc_ptr;
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = WAIT_ASSOC_GRP_JOB;
acct_policy.c:		if ((job_ptr->limit_set.time != ADMIN_SET_LIMIT)
acct_policy.c:				time_limit = job_ptr->time_limit;
acct_policy.c:						job_ptr->part_ptr->max_time,
acct_policy.c:						&job_ptr->limit_set.time);
acct_policy.c:				if ((job_ptr->qos_ptr &&
acct_policy.c:				     (job_ptr->qos_ptr->usage_factor >= 0)) &&
acct_policy.c:				     (job_ptr->qos_ptr->usage_factor < 1.0))) {
acct_policy.c:						job_ptr->qos_ptr->usage_factor;
acct_policy.c:				xfree(job_ptr->state_desc);
acct_policy.c:				job_ptr->state_reason = WAIT_ASSOC_GRP_WALL;
acct_policy.c:				xfree(job_ptr->state_desc);
acct_policy.c:				job_ptr->state_reason = WAIT_ASSOC_GRP_WALL;
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = WAIT_ASSOC_MAX_JOBS;
acct_policy.c:		if ((job_ptr->limit_set.time != ADMIN_SET_LIMIT)
acct_policy.c:				time_limit = job_ptr->time_limit;
acct_policy.c:						job_ptr->part_ptr->max_time,
acct_policy.c:						&job_ptr->limit_set.time);
acct_policy.c:				if ((job_ptr->qos_ptr &&
acct_policy.c:				     (job_ptr->qos_ptr->usage_factor >= 0)) &&
acct_policy.c:				     (job_ptr->qos_ptr->usage_factor < 1.0))) {
acct_policy.c:						job_ptr->qos_ptr->usage_factor;
acct_policy.c:				xfree(job_ptr->state_desc);
acct_policy.c:				job_ptr->state_reason =
acct_policy.c:				       job_ptr, job_ptr->time_limit,
acct_policy.c:	xassert(job_ptr->part_ptr);
acct_policy.c:	/* 	job_ptr->state_reason = FAIL_ACCOUNT; */
acct_policy.c:		xfree(job_ptr->state_desc);
acct_policy.c:		job_ptr->state_reason = WAIT_NO_REASON;
acct_policy.c:	job_ptr->qos_blocking_ptr = NULL;
acct_policy.c:	time_limit = job_ptr->time_limit;
acct_policy.c:	_set_time_limit(&time_limit, job_ptr->part_ptr->max_time,
acct_policy.c:			job_ptr->part_ptr->default_time, NULL);
acct_policy.c:	if ((job_ptr->qos_ptr &&
acct_policy.c:	     (job_ptr->qos_ptr->usage_factor >= 0)) &&
acct_policy.c:	     (job_ptr->qos_ptr->usage_factor < 1.0))) {
acct_policy.c:		usage_factor = job_ptr->qos_ptr->usage_factor;
acct_policy.c:	assoc_ptr = job_ptr->assoc_ptr;
acct_policy.c:			tres_usage_mins, job_ptr->limit_set.tres,
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:			NULL, job_ptr->limit_set.tres, true);
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:			    job_ptr->limit_set.tres,
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:			    job_ptr->limit_set.tres,
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:			    job_ptr->limit_set.tres,
acct_policy.c:			xfree(job_ptr->state_desc);
acct_policy.c:			job_ptr->state_reason = _get_tres_state_reason(
acct_policy.c:	slurmdb_assoc_rec_t *assoc_ptr = job_ptr->assoc_ptr;
acct_policy.c:	details_ptr = job_ptr->details;
acct_policy.c:	memcpy(&acct_policy_limit_set, &job_ptr->limit_set,
acct_policy.c:	memcpy(job_desc.tres_req_cnt, job_ptr->tres_req_cnt,
acct_policy.c:	if (job_ptr->limit_set.time == ADMIN_SET_LIMIT)
acct_policy.c:		acct_policy_limit_set.time = job_ptr->limit_set.time;
acct_policy.c:	else if ((job_ptr->time_limit != NO_VAL) && !job_ptr->limit_set.time)
acct_policy.c:		job_desc.time_limit = job_ptr->time_limit;
acct_policy.c:	if (!acct_policy_validate(&job_desc, job_ptr->part_ptr,
acct_policy.c:				  job_ptr->assoc_ptr, job_ptr->qos_ptr,
acct_policy.c:				  &job_ptr->state_reason,
acct_policy.c:	if (!acct_policy_limit_set.time && (job_ptr->limit_set.time == 1)) {
acct_policy.c:		job_ptr->time_limit = NO_VAL;
acct_policy.c:		job_ptr->limit_set.time = 0;
acct_policy.c:		if (job_ptr->time_limit != job_desc.time_limit) {
acct_policy.c:			job_ptr->time_limit = job_desc.time_limit;
acct_policy.c:		job_ptr->limit_set.time = acct_policy_limit_set.time;
acct_policy.c:	assoc =	job_ptr->assoc_ptr;
acct_policy.c:	time_delta = (uint64_t)(((now - job_ptr->start_time) -
acct_policy.c:				 job_ptr->tot_sus_time) / 60);
acct_policy.c:		if (job_ptr->tres_alloc_cnt[i]) {
acct_policy.c:				(time_delta * job_ptr->tres_alloc_cnt[i]) + 1;
acct_policy.c:			job_ptr->state_reason = FAIL_TIMEOUT;
acct_policy.c:			job_ptr->state_reason = FAIL_TIMEOUT;
acct_policy.c:			job_ptr->state_reason = FAIL_TIMEOUT;
acct_policy.c:	if (job_ptr->state_reason == FAIL_TIMEOUT)
acct_policy.c:	details_ptr = job_ptr->details;
acct_policy.c:	if (!job_ptr->priority || (job_ptr->bit_flags & JOB_DEPENDENT))
acct_policy.c:	assoc_ptr = job_ptr->assoc_ptr;
acct_policy.c:				job_ptr->user_id);
acct_policy.c:				job_ptr->user_id);
acct_policy.c:		if (!(job_ptr->bit_flags & JOB_ACCRUE_OVER) &&
acct_policy.c:			if (job_ptr->array_recs &&
acct_policy.c:			    job_ptr->array_recs->task_cnt)
acct_policy.c:				job_cnt = job_ptr->array_recs->task_cnt;
acct_policy.c:			job_ptr->bit_flags |= JOB_ACCRUE_OVER;
acct_policy.c:			_remove_accrue_time_internal(job_ptr->assoc_ptr,
acct_policy.c:		    !job_ptr->array_recs || !job_ptr->array_recs->task_cnt)
acct_policy.c:	assoc_ptr = job_ptr->assoc_ptr;
acct_policy.c:	    (create_cnt && (!job_ptr->array_recs ||
acct_policy.c:			    !job_ptr->array_recs->task_cnt))) {
acct_policy.c:		    job_ptr->details->begin_time) {
acct_policy.c:			if (job_ptr->array_recs &&
acct_policy.c:			    job_ptr->array_recs->task_cnt)
acct_policy.c:				create_cnt = job_ptr->array_recs->task_cnt;
acct_policy.c:			_add_accrue_time_internal(job_ptr->assoc_ptr,
acct_policy.c:	create_cnt = MIN(create_cnt, job_ptr->array_recs->task_cnt);
acct_policy.c:		details_ptr = old_job_ptr->details;
acct_policy.c:			_add_accrue_time_internal(job_ptr->assoc_ptr,
acct_policy.c:	_add_accrue_time_internal(job_ptr->assoc_ptr,
acct_policy.c:	if (!job_ptr->priority || (job_ptr->bit_flags & JOB_DEPENDENT))
acct_policy.c:	assoc_ptr = job_ptr->assoc_ptr;
acct_policy.c:				job_ptr->user_id);
acct_policy.c:				job_ptr->user_id);
acct_policy.c:	if (job_ptr->array_recs && job_ptr->array_recs->task_cnt)
acct_policy.c:		job_cnt = job_ptr->array_recs->task_cnt;
acct_policy.c:	if (!job_ptr->details || !job_ptr->details->accrue_time)
acct_policy.c:	assoc_ptr = job_ptr->assoc_ptr;
acct_policy.c:				job_ptr->user_id);
acct_policy.c:				job_ptr->user_id);
acct_policy.c:	if (job_ptr->array_recs && job_ptr->array_recs->task_cnt)
acct_policy.c:		job_cnt = job_ptr->array_recs->task_cnt;
acct_policy.c:	job_ptr->details->accrue_time = 0;
acct_policy.c:	job_ptr->bit_flags &= ~JOB_ACCRUE_OVER;
acct_policy.c:	assoc_ptr = job_ptr->assoc_ptr;
acct_policy.c:	time_t start = job_ptr->start_time;
acct_policy.c:	if (job_ptr->qos_ptr) {
acct_policy.c:		if (job_ptr->part_ptr && job_ptr->part_ptr->qos_ptr) {
acct_policy.c:			if (job_ptr->qos_ptr->flags & QOS_FLAG_OVER_PART_QOS) {
acct_policy.c:				*qos_ptr_1 = job_ptr->qos_ptr;
acct_policy.c:				*qos_ptr_2 = job_ptr->part_ptr->qos_ptr;
acct_policy.c:				*qos_ptr_1 = job_ptr->part_ptr->qos_ptr;
acct_policy.c:				*qos_ptr_2 = job_ptr->qos_ptr;
acct_policy.c:			*qos_ptr_1 = job_ptr->qos_ptr;
acct_policy.c:	} else if (job_ptr->part_ptr && job_ptr->part_ptr->qos_ptr)
acct_policy.c:		*qos_ptr_1 = job_ptr->part_ptr->qos_ptr;
node_mgr.c:		if (job_ptr && job_ptr->node_bitmap &&
node_mgr.c:		    ((j = bit_ffs(job_ptr->node_bitmap)) >= 0))
node_mgr.c:		} else if (job_ptr->batch_host == NULL) {
node_mgr.c:			job_ptr->batch_host = xstrdup(front_end_ptr->name);
node_mgr.c:			if (job_ptr->batch_flag) {
node_mgr.c:				job_ptr->time_last_active = now;
node_mgr.c:		else if (difftime(now, job_ptr->end_time) <
node_mgr.c:			      job_state_string(job_ptr->job_state),
node_mgr.c:		    (job_ptr->batch_flag == 0))
node_mgr.c:		if (job_ptr->front_end_ptr != front_end_ptr)
node_mgr.c:		if (difftime(now, job_ptr->time_last_active) <= 5)
node_mgr.c:		job_complete(job_ptr->job_id, slurmctld_conf.slurm_user_id,
node_mgr.c:        if(job_ptr->comment && strcmp(job_ptr->comment,"1")==0){
node_mgr.c:                       job_ptr->job_id,node_ptr->leaf_switch);
node_mgr.c:	if (job_ptr->details && (job_ptr->details->share_res == 0)) {
node_mgr.c:	if ((job_ptr->details &&
node_mgr.c:	     (job_ptr->details->whole_node == WHOLE_NODE_USER)) ||
node_mgr.c:	    (job_ptr->part_ptr &&
node_mgr.c:	     (job_ptr->part_ptr->flags & PART_FLAG_EXCLUSIVE_USER))) {
node_mgr.c:		node_ptr->owner = job_ptr->user_id;
node_mgr.c:		node_ptr->mcs_label = xstrdup(job_ptr->mcs_label);
node_mgr.c:                        if(job_ptr->comment && strcmp(job_ptr->comment,"1")==0){
node_mgr.c:                                      job_ptr->job_id,node_ptr->leaf_switch);
node_mgr.c:		if (job_ptr->details && (job_ptr->details->share_res == 0)) {
node_mgr.c:		if (job_ptr->node_bitmap_cg)
node_mgr.c:			node_bitmap = job_ptr->node_bitmap_cg;
node_mgr.c:			node_bitmap = job_ptr->node_bitmap;
node_mgr.c:		if (job_ptr->node_cnt) {
node_mgr.c:			job_ptr->node_cnt--;
node_mgr.c:			if ((job_ptr->node_cnt == 0) &&
node_mgr.c:			    !job_ptr->epilog_running)
node_mgr.c:		} else if ((job_ptr->total_cpus == 0) &&
node_mgr.c:			   (job_ptr->total_nodes == 0)) {
node_mgr.c:				if(job_ptr->comment && strcmp(job_ptr->comment,"1")==0){
node_mgr.c:						job_ptr->job_id,node_ptr->leaf_switch);
node_mgr.c:	    ((job_ptr->details &&
node_mgr.c:	      (job_ptr->details->whole_node == WHOLE_NODE_USER)) ||
node_mgr.c:	     (job_ptr->part_ptr &&
node_mgr.c:	      (job_ptr->part_ptr->flags & PART_FLAG_EXCLUSIVE_USER)))) {
Binary file job_mgr.o matches
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:		job_ptr->state_reason = FAIL_ACCOUNT;
job_mgr.c:		if (job_ptr->details) {
job_mgr.c:			job_ptr->details->accrue_time = 0;
job_mgr.c:			job_ptr->bit_flags &= ~JOB_ACCRUE_OVER;
job_mgr.c:			job_ptr->details->begin_time = 0;
job_mgr.c:	if (job_ptr->assoc_ptr) {
job_mgr.c:		struct part_record *tmp_part = job_ptr->part_ptr;
job_mgr.c:		List tmp_part_list = job_ptr->part_ptr_list;
job_mgr.c:		slurmdb_qos_rec_t *tmp_qos = job_ptr->qos_ptr;
job_mgr.c:		if (!job_ptr->db_index)
job_mgr.c:		job_ptr->part_ptr = NULL;
job_mgr.c:		job_ptr->part_ptr_list = NULL;
job_mgr.c:		job_ptr->qos_ptr = NULL;
job_mgr.c:		job_ptr->part_ptr = tmp_part;
job_mgr.c:		job_ptr->part_ptr_list = tmp_part_list;
job_mgr.c:		job_ptr->qos_ptr = tmp_qos;
job_mgr.c:		job_ptr->assoc_ptr = NULL;
job_mgr.c:	job_ptr->assoc_id = 0;
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:		job_ptr->state_reason = FAIL_QOS;
job_mgr.c:		if (job_ptr->details) {
job_mgr.c:			job_ptr->details->accrue_time = 0;
job_mgr.c:			job_ptr->bit_flags &= ~JOB_ACCRUE_OVER;
job_mgr.c:			job_ptr->details->begin_time = 0;
job_mgr.c:	if (job_ptr->qos_ptr) {
job_mgr.c:		slurmdb_assoc_rec_t *tmp_assoc = job_ptr->assoc_ptr;
job_mgr.c:		if (!job_ptr->db_index)
job_mgr.c:		job_ptr->assoc_ptr = NULL;
job_mgr.c:		job_ptr->assoc_ptr = tmp_assoc;
job_mgr.c:		job_ptr->qos_ptr = NULL;
job_mgr.c:	job_ptr->qos_id = 0;
job_mgr.c:	if ((job_ptr->array_task_id == NO_VAL) &&
job_mgr.c:	    (job_ptr->array_recs == NULL)) {
job_mgr.c:		if (job_ptr->array_task_id != NO_VAL) {
job_mgr.c:			if (job_ptr->array_task_id <
job_mgr.c:					job_ptr->array_task_id);
job_mgr.c:		} else if (job_ptr->array_recs &&
job_mgr.c:			   job_ptr->array_recs->task_id_bitmap) {
job_mgr.c:			array_size = bit_size(job_ptr->array_recs->
job_mgr.c:			       job_ptr->array_recs->task_id_bitmap);
job_mgr.c:	if (job_ptr->array_task_id != NO_VAL) {
job_mgr.c:		if (job_ptr->array_task_id <
job_mgr.c:				job_ptr->array_task_id);
job_mgr.c:	} else if (job_ptr->array_recs && job_ptr->array_recs->task_id_bitmap) {
job_mgr.c:			bit_copy(job_ptr->array_recs->task_id_bitmap);
job_mgr.c:	job_ptr->magic = JOB_MAGIC;
job_mgr.c:	job_ptr->array_task_id = NO_VAL;
job_mgr.c:	job_ptr->details = detail_ptr;
job_mgr.c:	job_ptr->prio_factors = xmalloc(sizeof(priority_factors_object_t));
job_mgr.c:	job_ptr->site_factor = NICE_OFFSET;
job_mgr.c:	job_ptr->step_list = list_create(NULL);
job_mgr.c:	job_ptr->requid = -1; /* force to -1 for sacct to know this
job_mgr.c:	job_ptr->billable_tres = (double)NO_VAL;
job_mgr.c:	xfree(job_ptr->tres_req_str);
job_mgr.c:	job_ptr->tres_req_str = assoc_mgr_make_tres_str_from_array(
job_mgr.c:		job_ptr->tres_req_cnt, TRES_STR_FLAG_SIMPLE, true);
job_mgr.c:	xfree(job_ptr->tres_fmt_req_str);
job_mgr.c:	job_ptr->tres_fmt_req_str = assoc_mgr_make_tres_str_from_array(
job_mgr.c:		job_ptr->tres_req_cnt, TRES_STR_CONVERT_UNITS, true);
job_mgr.c:	xfree(job_ptr->tres_alloc_str);
job_mgr.c:	job_ptr->tres_alloc_str = assoc_mgr_make_tres_str_from_array(
job_mgr.c:		job_ptr->tres_alloc_cnt, TRES_STR_FLAG_SIMPLE, true);
job_mgr.c:	xfree(job_ptr->tres_fmt_alloc_str);
job_mgr.c:	job_ptr->tres_fmt_alloc_str = assoc_mgr_make_tres_str_from_array(
job_mgr.c:		job_ptr->tres_alloc_cnt, TRES_STR_CONVERT_UNITS, true);
job_mgr.c:	xassert(dump_job_ptr->magic == JOB_MAGIC);
job_mgr.c:	pack32(dump_job_ptr->array_job_id, buffer);
job_mgr.c:	pack32(dump_job_ptr->array_task_id, buffer);
job_mgr.c:	if (dump_job_ptr->array_recs) {
job_mgr.c:		if (dump_job_ptr->array_recs->task_id_bitmap) {
job_mgr.c:			tmp_32 = bit_size(dump_job_ptr->array_recs->
job_mgr.c:			packstr(dump_job_ptr->array_recs->task_id_str, buffer);
job_mgr.c:		pack32(dump_job_ptr->array_recs->array_flags,    buffer);
job_mgr.c:		pack32(dump_job_ptr->array_recs->max_run_tasks,  buffer);
job_mgr.c:		pack32(dump_job_ptr->array_recs->tot_run_tasks,  buffer);
job_mgr.c:		pack32(dump_job_ptr->array_recs->min_exit_code,  buffer);
job_mgr.c:		pack32(dump_job_ptr->array_recs->max_exit_code,  buffer);
job_mgr.c:		pack32(dump_job_ptr->array_recs->tot_comp_tasks, buffer);
job_mgr.c:	pack32(dump_job_ptr->assoc_id, buffer);
job_mgr.c:	packstr(dump_job_ptr->batch_features, buffer);
job_mgr.c:	pack32(dump_job_ptr->delay_boot, buffer);
job_mgr.c:	pack32(dump_job_ptr->job_id, buffer);
job_mgr.c:	pack32(dump_job_ptr->user_id, buffer);
job_mgr.c:	pack32(dump_job_ptr->group_id, buffer);
job_mgr.c:	pack32(dump_job_ptr->time_limit, buffer);
job_mgr.c:	pack32(dump_job_ptr->time_min, buffer);
job_mgr.c:	pack32(dump_job_ptr->priority, buffer);
job_mgr.c:	pack32(dump_job_ptr->alloc_sid, buffer);
job_mgr.c:	pack32(dump_job_ptr->total_cpus, buffer);
job_mgr.c:	if (dump_job_ptr->total_nodes)
job_mgr.c:		pack32(dump_job_ptr->total_nodes, buffer);
job_mgr.c:		pack32(dump_job_ptr->node_cnt_wag, buffer);
job_mgr.c:	pack32(dump_job_ptr->cpu_cnt, buffer);
job_mgr.c:	pack32(dump_job_ptr->exit_code, buffer);
job_mgr.c:	pack32(dump_job_ptr->derived_ec, buffer);
job_mgr.c:	pack64(dump_job_ptr->db_index, buffer);
job_mgr.c:	pack32(dump_job_ptr->resv_id, buffer);
job_mgr.c:	pack32(dump_job_ptr->next_step_id, buffer);
job_mgr.c:	pack32(dump_job_ptr->pack_job_id, buffer);
job_mgr.c:	packstr(dump_job_ptr->pack_job_id_set, buffer);
job_mgr.c:	pack32(dump_job_ptr->pack_job_offset, buffer);
job_mgr.c:	pack32(dump_job_ptr->qos_id, buffer);
job_mgr.c:	pack32(dump_job_ptr->req_switch, buffer);
job_mgr.c:	pack32(dump_job_ptr->wait4switch, buffer);
job_mgr.c:	pack32(dump_job_ptr->profile, buffer);
job_mgr.c:	pack32(dump_job_ptr->db_flags, buffer);
job_mgr.c:	pack_time(dump_job_ptr->last_sched_eval, buffer);
job_mgr.c:	pack_time(dump_job_ptr->preempt_time, buffer);
job_mgr.c:	pack_time(dump_job_ptr->start_time, buffer);
job_mgr.c:	pack_time(dump_job_ptr->end_time, buffer);
job_mgr.c:	pack_time(dump_job_ptr->end_time_exp, buffer);
job_mgr.c:	pack_time(dump_job_ptr->suspend_time, buffer);
job_mgr.c:	pack_time(dump_job_ptr->pre_sus_time, buffer);
job_mgr.c:	pack_time(dump_job_ptr->resize_time, buffer);
job_mgr.c:	pack_time(dump_job_ptr->tot_sus_time, buffer);
job_mgr.c:	pack_time(dump_job_ptr->deadline, buffer);
job_mgr.c:	pack32(dump_job_ptr->site_factor, buffer);
job_mgr.c:	pack16(dump_job_ptr->direct_set_prio, buffer);
job_mgr.c:	pack32(dump_job_ptr->job_state, buffer);
job_mgr.c:	pack16(dump_job_ptr->kill_on_node_fail, buffer);
job_mgr.c:	pack16(dump_job_ptr->batch_flag, buffer);
job_mgr.c:	pack16(dump_job_ptr->mail_type, buffer);
job_mgr.c:	pack32(dump_job_ptr->state_reason, buffer);
job_mgr.c:	pack32(dump_job_ptr->state_reason_prev_db, buffer);
job_mgr.c:	pack8(dump_job_ptr->reboot, buffer);
job_mgr.c:	pack16(dump_job_ptr->restart_cnt, buffer);
job_mgr.c:	pack16(dump_job_ptr->wait_all_nodes, buffer);
job_mgr.c:	pack16(dump_job_ptr->warn_flags, buffer);
job_mgr.c:	pack16(dump_job_ptr->warn_signal, buffer);
job_mgr.c:	pack16(dump_job_ptr->warn_time, buffer);
job_mgr.c:	_pack_acct_policy_limit(&dump_job_ptr->limit_set, buffer,
job_mgr.c:	packstr(dump_job_ptr->state_desc, buffer);
job_mgr.c:	packstr(dump_job_ptr->resp_host, buffer);
job_mgr.c:	pack16(dump_job_ptr->alloc_resp_port, buffer);
job_mgr.c:	pack16(dump_job_ptr->other_port, buffer);
job_mgr.c:	pack8(dump_job_ptr->power_flags, buffer);
job_mgr.c:	pack16(dump_job_ptr->start_protocol_ver, buffer);
job_mgr.c:	packdouble(dump_job_ptr->billable_tres, buffer);
job_mgr.c:		if (dump_job_ptr->nodes_completing == NULL) {
job_mgr.c:			dump_job_ptr->nodes_completing =
job_mgr.c:				bitmap2node_name(dump_job_ptr->node_bitmap);
job_mgr.c:		packstr(dump_job_ptr->nodes_completing, buffer);
job_mgr.c:	packstr(dump_job_ptr->nodes, buffer);
job_mgr.c:	packstr(dump_job_ptr->partition, buffer);
job_mgr.c:	packstr(dump_job_ptr->name, buffer);
job_mgr.c:	packstr(dump_job_ptr->user_name, buffer);
job_mgr.c:	packstr(dump_job_ptr->wckey, buffer);
job_mgr.c:	packstr(dump_job_ptr->alloc_node, buffer);
job_mgr.c:	packstr(dump_job_ptr->account, buffer);
job_mgr.c:	packstr(dump_job_ptr->admin_comment, buffer);
job_mgr.c:	packstr(dump_job_ptr->comment, buffer);
job_mgr.c:	packstr(dump_job_ptr->gres_alloc, buffer);
job_mgr.c:	packstr(dump_job_ptr->gres_req, buffer);
job_mgr.c:	packstr(dump_job_ptr->gres_used, buffer);
job_mgr.c:	packstr(dump_job_ptr->network, buffer);
job_mgr.c:	packstr(dump_job_ptr->licenses, buffer);
job_mgr.c:	packstr(dump_job_ptr->mail_user, buffer);
job_mgr.c:	packstr(dump_job_ptr->mcs_label, buffer);
job_mgr.c:	packstr(dump_job_ptr->resv_name, buffer);
job_mgr.c:	packstr(dump_job_ptr->batch_host, buffer);
job_mgr.c:	packstr(dump_job_ptr->burst_buffer, buffer);
job_mgr.c:	packstr(dump_job_ptr->burst_buffer_state, buffer);
job_mgr.c:	packstr(dump_job_ptr->system_comment, buffer);
job_mgr.c:	select_g_select_jobinfo_pack(dump_job_ptr->select_jobinfo,
job_mgr.c:	pack_job_resources(dump_job_ptr->job_resrcs, buffer,
job_mgr.c:	pack16(dump_job_ptr->ckpt_interval, buffer);
job_mgr.c:	checkpoint_pack_jobinfo(dump_job_ptr->check_job, buffer,
job_mgr.c:	packstr_array(dump_job_ptr->spank_job_env,
job_mgr.c:		      dump_job_ptr->spank_job_env_size, buffer);
job_mgr.c:	(void) gres_plugin_job_state_pack(dump_job_ptr->gres_list, buffer,
job_mgr.c:					  dump_job_ptr->job_id, true,
job_mgr.c:	detail_ptr = dump_job_ptr->details;
job_mgr.c:	list_for_each(dump_job_ptr->step_list, dump_job_step_state, buffer);
job_mgr.c:	pack32(dump_job_ptr->bit_flags, buffer);
job_mgr.c:	packstr(dump_job_ptr->tres_alloc_str, buffer);
job_mgr.c:	packstr(dump_job_ptr->tres_fmt_alloc_str, buffer);
job_mgr.c:	packstr(dump_job_ptr->tres_req_str, buffer);
job_mgr.c:	packstr(dump_job_ptr->tres_fmt_req_str, buffer);
job_mgr.c:	packstr(dump_job_ptr->clusters, buffer);
job_mgr.c:	_dump_job_fed_details(dump_job_ptr->fed_details, buffer);
job_mgr.c:	packstr(dump_job_ptr->origin_cluster, buffer);
job_mgr.c:	packstr(dump_job_ptr->cpus_per_tres, buffer);
job_mgr.c:	packstr(dump_job_ptr->mem_per_tres, buffer);
job_mgr.c:	packstr(dump_job_ptr->tres_bind, buffer);
job_mgr.c:	packstr(dump_job_ptr->tres_freq, buffer);
job_mgr.c:	packstr(dump_job_ptr->tres_per_job, buffer);
job_mgr.c:	packstr(dump_job_ptr->tres_per_node, buffer);
job_mgr.c:	packstr(dump_job_ptr->tres_per_socket, buffer);
job_mgr.c:	packstr(dump_job_ptr->tres_per_task, buffer);
job_mgr.c:			job_ptr->job_id = job_id;
job_mgr.c:			job_ptr->array_job_id = array_job_id;
job_mgr.c:			job_ptr->array_task_id = array_task_id;
job_mgr.c:			job_ptr->job_state = JOB_FAILED;
job_mgr.c:			job_ptr->exit_code = 1;
job_mgr.c:			job_ptr->state_reason = FAIL_SYSTEM;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:			job_ptr->end_time = now;
job_mgr.c:		safe_unpack32(&job_ptr->bit_flags, buffer);
job_mgr.c:		job_ptr->bit_flags &= ~BACKFILL_TEST;
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->origin_cluster, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->cpus_per_tres, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->mem_per_tres, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->tres_bind, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->tres_freq, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->tres_per_job, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->tres_per_node, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->tres_per_socket, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->tres_per_task, &name_len,
job_mgr.c:			job_ptr->job_id = job_id;
job_mgr.c:			job_ptr->array_job_id = array_job_id;
job_mgr.c:			job_ptr->array_task_id = array_task_id;
job_mgr.c:			job_ptr->job_state = JOB_FAILED;
job_mgr.c:			job_ptr->exit_code = 1;
job_mgr.c:			job_ptr->state_reason = FAIL_SYSTEM;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:			job_ptr->end_time = now;
job_mgr.c:		safe_unpack32(&job_ptr->bit_flags, buffer);
job_mgr.c:		job_ptr->bit_flags &= ~BACKFILL_TEST;
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->origin_cluster, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->cpus_per_tres, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->mem_per_tres, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->tres_bind, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->tres_freq, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->tres_per_job, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->tres_per_node, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->tres_per_socket, &name_len,
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->tres_per_task, &name_len,
job_mgr.c:			job_ptr->job_id = job_id;
job_mgr.c:			job_ptr->array_job_id = array_job_id;
job_mgr.c:			job_ptr->array_task_id = array_task_id;
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->tres_per_node, &name_len,
job_mgr.c:			job_ptr->job_state = JOB_FAILED;
job_mgr.c:			job_ptr->exit_code = 1;
job_mgr.c:			job_ptr->state_reason = FAIL_SYSTEM;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:			job_ptr->end_time = now;
job_mgr.c:		safe_unpack32(&job_ptr->bit_flags, buffer);
job_mgr.c:		job_ptr->bit_flags &= ~BACKFILL_TEST;
job_mgr.c:		safe_unpackstr_xmalloc(&job_ptr->origin_cluster, &name_len,
job_mgr.c:	xfree(job_ptr->tres_alloc_str);
job_mgr.c:	job_ptr->tres_alloc_str = tres_alloc_str;
job_mgr.c:	xfree(job_ptr->tres_req_str);
job_mgr.c:	job_ptr->tres_req_str = tres_req_str;
job_mgr.c:	xfree(job_ptr->tres_fmt_alloc_str);
job_mgr.c:	job_ptr->tres_fmt_alloc_str = tres_fmt_alloc_str;
job_mgr.c:	xfree(job_ptr->tres_fmt_req_str);
job_mgr.c:	job_ptr->tres_fmt_req_str = tres_fmt_req_str;
job_mgr.c:	xfree(job_ptr->account);
job_mgr.c:	job_ptr->account = account;
job_mgr.c:	xstrtolower(job_ptr->account);
job_mgr.c:	xfree(job_ptr->alloc_node);
job_mgr.c:	job_ptr->alloc_node   = alloc_node;
job_mgr.c:	job_ptr->alloc_resp_port = alloc_resp_port;
job_mgr.c:	job_ptr->alloc_sid    = alloc_sid;
job_mgr.c:	job_ptr->assoc_id     = assoc_id;
job_mgr.c:	job_ptr->delay_boot   = delay_boot;
job_mgr.c:	xfree(job_ptr->admin_comment);
job_mgr.c:	job_ptr->admin_comment = admin_comment;
job_mgr.c:	xfree(job_ptr->system_comment);
job_mgr.c:	job_ptr->system_comment = system_comment;
job_mgr.c:	xfree(job_ptr->batch_features);
job_mgr.c:	job_ptr->batch_features = batch_features;
job_mgr.c:	job_ptr->batch_flag   = batch_flag;
job_mgr.c:	xfree(job_ptr->batch_host);
job_mgr.c:	job_ptr->batch_host   = batch_host;
job_mgr.c:	xfree(job_ptr->burst_buffer);
job_mgr.c:	job_ptr->burst_buffer = burst_buffer;
job_mgr.c:	xfree(job_ptr->burst_buffer_state);
job_mgr.c:	job_ptr->burst_buffer_state = burst_buffer_state;
job_mgr.c:	xfree(job_ptr->comment);
job_mgr.c:	job_ptr->comment      = comment;
job_mgr.c:	job_ptr->billable_tres = billable_tres;
job_mgr.c:	xfree(job_ptr->gres_alloc);
job_mgr.c:	job_ptr->gres_alloc   = gres_alloc;
job_mgr.c:	xfree(job_ptr->gres_req);
job_mgr.c:	job_ptr->gres_req    = gres_req;
job_mgr.c:	xfree(job_ptr->gres_used);
job_mgr.c:	job_ptr->gres_used    = gres_used;
job_mgr.c:	job_ptr->gres_list    = gres_list;
job_mgr.c:	job_ptr->site_factor = site_factor;
job_mgr.c:	job_ptr->direct_set_prio = direct_set_prio;
job_mgr.c:	job_ptr->db_index     = db_index;
job_mgr.c:	job_ptr->derived_ec   = derived_ec;
job_mgr.c:	job_ptr->end_time_exp = end_time_exp;
job_mgr.c:	job_ptr->end_time     = end_time;
job_mgr.c:	job_ptr->exit_code    = exit_code;
job_mgr.c:	job_ptr->group_id     = group_id;
job_mgr.c:	job_ptr->job_state    = job_state;
job_mgr.c:	job_ptr->kill_on_node_fail = kill_on_node_fail;
job_mgr.c:	xfree(job_ptr->licenses);
job_mgr.c:	job_ptr->licenses     = licenses;
job_mgr.c:	job_ptr->mail_type    = mail_type;
job_mgr.c:	xfree(job_ptr->mail_user);
job_mgr.c:	job_ptr->mail_user    = mail_user;
job_mgr.c:	xfree(job_ptr->mcs_label);
job_mgr.c:	job_ptr->mcs_label    = mcs_label;
job_mgr.c:	xfree(job_ptr->name);		/* in case duplicate record */
job_mgr.c:	job_ptr->name         = name;
job_mgr.c:	xfree(job_ptr->user_name);
job_mgr.c:	job_ptr->user_name    = user_name;
job_mgr.c:	xfree(job_ptr->wckey);		/* in case duplicate record */
job_mgr.c:	job_ptr->wckey        = wckey;
job_mgr.c:	xstrtolower(job_ptr->wckey);
job_mgr.c:	xfree(job_ptr->network);
job_mgr.c:	job_ptr->network      = network;
job_mgr.c:	job_ptr->next_step_id = next_step_id;
job_mgr.c:	xfree(job_ptr->nodes);		/* in case duplicate record */
job_mgr.c:	job_ptr->nodes        = nodes;
job_mgr.c:		xfree(job_ptr->nodes_completing);
job_mgr.c:		job_ptr->nodes_completing = nodes_completing;
job_mgr.c:	job_ptr->other_port   = other_port;
job_mgr.c:	job_ptr->power_flags  = power_flags;
job_mgr.c:	job_ptr->pack_job_id     = pack_job_id;
job_mgr.c:	xfree(job_ptr->pack_job_id_set);
job_mgr.c:	job_ptr->pack_job_id_set = pack_job_id_set;
job_mgr.c:	job_ptr->pack_job_offset = pack_job_offset;
job_mgr.c:	xfree(job_ptr->partition);
job_mgr.c:	job_ptr->partition    = partition;
job_mgr.c:	job_ptr->part_ptr = part_ptr;
job_mgr.c:	job_ptr->part_ptr_list = part_ptr_list;
job_mgr.c:	job_ptr->pre_sus_time = pre_sus_time;
job_mgr.c:	job_ptr->priority     = priority;
job_mgr.c:	job_ptr->qos_id       = qos_id;
job_mgr.c:	job_ptr->reboot       = reboot;
job_mgr.c:	xfree(job_ptr->resp_host);
job_mgr.c:	job_ptr->resp_host    = resp_host;
job_mgr.c:	job_ptr->resize_time  = resize_time;
job_mgr.c:	job_ptr->restart_cnt  = restart_cnt;
job_mgr.c:	job_ptr->resv_id      = resv_id;
job_mgr.c:	job_ptr->resv_name    = resv_name;
job_mgr.c:	job_ptr->select_jobinfo = select_jobinfo;
job_mgr.c:	job_ptr->job_resrcs   = job_resources;
job_mgr.c:	job_ptr->spank_job_env = spank_job_env;
job_mgr.c:	job_ptr->spank_job_env_size = spank_job_env_size;
job_mgr.c:	job_ptr->ckpt_interval = ckpt_interval;
job_mgr.c:	job_ptr->check_job    = check_job;
job_mgr.c:	job_ptr->start_time   = start_time;
job_mgr.c:	job_ptr->state_reason = state_reason;
job_mgr.c:	job_ptr->state_reason_prev_db = state_reason_prev_db;
job_mgr.c:	job_ptr->state_desc   = state_desc;
job_mgr.c:	job_ptr->suspend_time = suspend_time;
job_mgr.c:	job_ptr->deadline     = deadline;
job_mgr.c:		if (!job_ptr->array_recs)
job_mgr.c:			job_ptr->array_recs=xmalloc(sizeof(job_array_struct_t));
job_mgr.c:		FREE_NULL_BITMAP(job_ptr->array_recs->task_id_bitmap);
job_mgr.c:		xfree(job_ptr->array_recs->task_id_str);
job_mgr.c:			job_ptr->array_recs->task_id_bitmap =
job_mgr.c:					job_ptr->array_recs->task_id_bitmap,
job_mgr.c:				job_ptr->array_recs->task_id_str = task_id_str;
job_mgr.c:			job_ptr->array_recs->task_cnt =
job_mgr.c:				bit_set_count(job_ptr->array_recs->
job_mgr.c:			if (job_ptr->array_recs->task_cnt > 1)
job_mgr.c:				job_count += (job_ptr->array_recs->task_cnt-1);
job_mgr.c:		job_ptr->array_recs->array_flags    = array_flags;
job_mgr.c:		job_ptr->array_recs->max_run_tasks  = max_run_tasks;
job_mgr.c:		job_ptr->array_recs->tot_run_tasks  = tot_run_tasks;
job_mgr.c:		job_ptr->array_recs->min_exit_code  = min_exit_code;
job_mgr.c:		job_ptr->array_recs->max_exit_code  = max_exit_code;
job_mgr.c:		job_ptr->array_recs->tot_comp_tasks = tot_comp_tasks;
job_mgr.c:	job_ptr->time_last_active = now;
job_mgr.c:	job_ptr->time_limit   = time_limit;
job_mgr.c:	job_ptr->time_min     = time_min;
job_mgr.c:	job_ptr->total_cpus   = total_cpus;
job_mgr.c:		job_ptr->node_cnt_wag = total_nodes;
job_mgr.c:		job_ptr->total_nodes  = total_nodes;
job_mgr.c:	job_ptr->cpu_cnt      = cpu_cnt;
job_mgr.c:	job_ptr->tot_sus_time = tot_sus_time;
job_mgr.c:	job_ptr->last_sched_eval = last_sched_eval;
job_mgr.c:	job_ptr->preempt_time = preempt_time;
job_mgr.c:	job_ptr->user_id      = user_id;
job_mgr.c:	job_ptr->wait_all_nodes = wait_all_nodes;
job_mgr.c:	job_ptr->warn_flags   = warn_flags;
job_mgr.c:	job_ptr->warn_signal  = warn_signal;
job_mgr.c:	job_ptr->warn_time    = warn_time;
job_mgr.c:	memcpy(&job_ptr->limit_set, &limit_set,
job_mgr.c:	job_ptr->req_switch      = req_switch;
job_mgr.c:	job_ptr->wait4switch     = wait4switch;
job_mgr.c:	job_ptr->profile         = profile;
job_mgr.c:	job_ptr->db_flags        = db_flags;
job_mgr.c:	job_ptr->best_switch     = true;
job_mgr.c:	job_ptr->start_protocol_ver = start_protocol_ver;
job_mgr.c:	if (job_ptr->assoc_id)
job_mgr.c:		assoc_rec.id = job_ptr->assoc_id;
job_mgr.c:		assoc_rec.acct      = job_ptr->account;
job_mgr.c:		if (job_ptr->part_ptr)
job_mgr.c:			assoc_rec.partition = job_ptr->part_ptr->name;
job_mgr.c:		assoc_rec.uid       = job_ptr->user_id;
job_mgr.c:				    &job_ptr->assoc_ptr, true) &&
job_mgr.c:		job_ptr->assoc_id = assoc_rec.id;
job_mgr.c:		info("Recovered %pJ Assoc=%u", job_ptr, job_ptr->assoc_id);
job_mgr.c:		if (!job_ptr->db_index) {
job_mgr.c:			    !(job_ptr->bit_flags & TRES_STR_CALC) &&
job_mgr.c:			    job_ptr->tres_alloc_cnt &&
job_mgr.c:			    (job_ptr->tres_alloc_cnt[TRES_ENERGY] != NO_VAL64))
job_mgr.c:	if (!job_finished && job_ptr->qos_id &&
job_mgr.c:	    (job_ptr->state_reason != FAIL_ACCOUNT)) {
job_mgr.c:		qos_rec.id = job_ptr->qos_id;
job_mgr.c:		job_ptr->qos_ptr = _determine_and_validate_qos(
job_mgr.c:			job_ptr->resv_name, job_ptr->assoc_ptr,
job_mgr.c:			job_ptr->limit_set.qos, &qos_rec,
job_mgr.c:		if ((qos_error != SLURM_SUCCESS) && !job_ptr->limit_set.qos) {
job_mgr.c:			job_ptr->qos_id = qos_rec.id;
job_mgr.c:	if (job_ptr->tres_alloc_str)
job_mgr.c:			&job_ptr->tres_alloc_cnt, job_ptr->tres_alloc_str,
job_mgr.c:	if (job_ptr->tres_req_str)
job_mgr.c:			&job_ptr->tres_req_cnt, job_ptr->tres_req_str, 0, true);
job_mgr.c:	gres_build_job_details(job_ptr->gres_list,
job_mgr.c:			       &job_ptr->gres_detail_cnt,
job_mgr.c:			       &job_ptr->gres_detail_str);
job_mgr.c:	job_ptr->clusters     = clusters;
job_mgr.c:	job_ptr->fed_details  = job_fed_details;
job_mgr.c:		if (job_ptr->job_id == 0)
job_mgr.c:			job_ptr->job_id = NO_VAL;
job_mgr.c:		purge_job_record(job_ptr->job_id);
job_mgr.c:	xfree(job_ptr->details->acctg_freq);
job_mgr.c:	for (i=0; i<job_ptr->details->argc; i++)
job_mgr.c:		xfree(job_ptr->details->argv[i]);
job_mgr.c:	xfree(job_ptr->details->argv);
job_mgr.c:	xfree(job_ptr->details->cpu_bind);
job_mgr.c:	xfree(job_ptr->details->dependency);
job_mgr.c:	xfree(job_ptr->details->orig_dependency);
job_mgr.c:	xfree(job_ptr->details->std_err);
job_mgr.c:	for (i=0; i<job_ptr->details->env_cnt; i++)
job_mgr.c:		xfree(job_ptr->details->env_sup[i]);
job_mgr.c:	xfree(job_ptr->details->env_sup);
job_mgr.c:	xfree(job_ptr->details->exc_nodes);
job_mgr.c:	xfree(job_ptr->details->features);
job_mgr.c:	xfree(job_ptr->details->cluster_features);
job_mgr.c:	xfree(job_ptr->details->std_in);
job_mgr.c:	xfree(job_ptr->details->mem_bind);
job_mgr.c:	xfree(job_ptr->details->std_out);
job_mgr.c:	xfree(job_ptr->details->req_nodes);
job_mgr.c:	xfree(job_ptr->details->work_dir);
job_mgr.c:	xfree(job_ptr->details->ckpt_dir);
job_mgr.c:	xfree(job_ptr->details->restart_dir);
job_mgr.c:	job_ptr->details->acctg_freq = acctg_freq;
job_mgr.c:	job_ptr->details->argc = argc;
job_mgr.c:	job_ptr->details->argv = argv;
job_mgr.c:	job_ptr->details->accrue_time = accrue_time;
job_mgr.c:	job_ptr->details->begin_time = begin_time;
job_mgr.c:	job_ptr->details->contiguous = contiguous;
job_mgr.c:	job_ptr->details->core_spec = core_spec;
job_mgr.c:	job_ptr->details->cpu_bind = cpu_bind;
job_mgr.c:	job_ptr->details->cpu_bind_type = cpu_bind_type;
job_mgr.c:	job_ptr->details->cpu_freq_min = cpu_freq_min;
job_mgr.c:	job_ptr->details->cpu_freq_max = cpu_freq_max;
job_mgr.c:	job_ptr->details->cpu_freq_gov = cpu_freq_gov;
job_mgr.c:	job_ptr->details->cpus_per_task = cpus_per_task;
job_mgr.c:	job_ptr->details->orig_cpus_per_task = cpus_per_task;
job_mgr.c:	job_ptr->details->dependency = dependency;
job_mgr.c:	job_ptr->details->orig_dependency = orig_dependency;
job_mgr.c:	job_ptr->details->env_cnt = env_cnt;
job_mgr.c:	job_ptr->details->env_sup = env_sup;
job_mgr.c:	job_ptr->details->std_err = err;
job_mgr.c:	job_ptr->details->exc_nodes = exc_nodes;
job_mgr.c:	job_ptr->details->features = features;
job_mgr.c:	job_ptr->details->cluster_features = cluster_features;
job_mgr.c:	job_ptr->details->std_in = in;
job_mgr.c:	job_ptr->details->pn_min_cpus = pn_min_cpus;
job_mgr.c:	job_ptr->details->orig_pn_min_cpus = pn_min_cpus;
job_mgr.c:	job_ptr->details->pn_min_memory = pn_min_memory;
job_mgr.c:	job_ptr->details->orig_pn_min_memory = pn_min_memory;
job_mgr.c:	job_ptr->details->pn_min_tmp_disk = pn_min_tmp_disk;
job_mgr.c:	job_ptr->details->max_cpus = max_cpus;
job_mgr.c:	job_ptr->details->orig_max_cpus = max_cpus;
job_mgr.c:	job_ptr->details->max_nodes = max_nodes;
job_mgr.c:	job_ptr->details->mc_ptr = mc_ptr;
job_mgr.c:	job_ptr->details->mem_bind = mem_bind;
job_mgr.c:	job_ptr->details->mem_bind_type = mem_bind_type;
job_mgr.c:	job_ptr->details->min_cpus = min_cpus;
job_mgr.c:	job_ptr->details->orig_min_cpus = min_cpus;
job_mgr.c:	job_ptr->details->min_nodes = min_nodes;
job_mgr.c:	job_ptr->details->nice = nice;
job_mgr.c:	job_ptr->details->ntasks_per_node = ntasks_per_node;
job_mgr.c:	job_ptr->details->num_tasks = num_tasks;
job_mgr.c:	job_ptr->details->open_mode = open_mode;
job_mgr.c:	job_ptr->details->std_out = out;
job_mgr.c:	job_ptr->details->overcommit = overcommit;
job_mgr.c:	job_ptr->details->plane_size = plane_size;
job_mgr.c:	job_ptr->details->prolog_running = prolog_running;
job_mgr.c:	job_ptr->details->req_nodes = req_nodes;
job_mgr.c:	job_ptr->details->requeue = requeue;
job_mgr.c:	job_ptr->details->share_res = share_res;
job_mgr.c:	job_ptr->details->submit_time = submit_time;
job_mgr.c:	job_ptr->details->task_dist = task_dist;
job_mgr.c:	job_ptr->details->whole_node = whole_node;
job_mgr.c:	job_ptr->details->work_dir = work_dir;
job_mgr.c:	job_ptr->details->ckpt_dir = ckpt_dir;
job_mgr.c:	job_ptr->details->restart_dir = restart_dir;
job_mgr.c:	inx = JOB_HASH_INX(job_ptr->job_id);
job_mgr.c:	job_ptr->job_next = job_hash[inx];
job_mgr.c:		xassert(job_ptr->magic == JOB_MAGIC);
job_mgr.c:			job_pptr = &job_ptr->job_next;
job_mgr.c:			job_pptr = &job_ptr->job_array_next_j;
job_mgr.c:			job_pptr = &job_ptr->job_array_next_t;
job_mgr.c:	if (job_ptr->array_task_id == NO_VAL)
job_mgr.c:	inx = JOB_HASH_INX(job_ptr->array_job_id);
job_mgr.c:	job_ptr->job_array_next_j = job_array_hash_j[inx];
job_mgr.c:	inx = JOB_ARRAY_HASH_INX(job_ptr->array_job_id,job_ptr->array_task_id);
job_mgr.c:	job_ptr->job_array_next_t = job_array_hash_t[inx];
job_mgr.c:	job_array_struct_t *array_recs = job_ptr->array_recs;
job_mgr.c:	    (job_ptr->array_task_id != NO_VAL) ||
job_mgr.c:	    (bit_ffs(job_ptr->array_recs->task_id_bitmap) == -1))
job_mgr.c:	job_ptr->job_state |= JOB_UPDATE_DB;
job_mgr.c:		if (job_ptr->array_recs && job_ptr->array_recs->max_exit_code)
job_mgr.c:		if (job_ptr->array_job_id == array_job_id) {
job_mgr.c:		job_ptr = job_ptr->job_array_next_j;
job_mgr.c:		if (job_ptr->array_job_id == array_job_id) {
job_mgr.c:		job_ptr = job_ptr->job_array_next_j;
job_mgr.c:		if ((job_ptr->array_job_id == array_job_id) &&
job_mgr.c:		job_ptr = job_ptr->job_array_next_j;
job_mgr.c:		if (job_ptr->array_job_id == array_job_id) {
job_mgr.c:		job_ptr = job_ptr->job_array_next_j;
job_mgr.c:		if (job_ptr->array_recs && job_ptr->array_recs->task_cnt)
job_mgr.c:		if (job_ptr->array_job_id == array_job_id) {
job_mgr.c:		job_ptr = job_ptr->job_array_next_j;
job_mgr.c:		if ((job_ptr->array_job_id == array_job_id) &&
job_mgr.c:		job_ptr = job_ptr->job_array_next_j;
job_mgr.c:		if (job_ptr && job_ptr->array_recs &&
job_mgr.c:		    (job_ptr->array_job_id == array_job_id))
job_mgr.c:			if (job_ptr->array_job_id == array_job_id) {
job_mgr.c:			job_ptr = job_ptr->job_array_next_j;
job_mgr.c:			if ((job_ptr->array_job_id == array_job_id) &&
job_mgr.c:			    (job_ptr->array_task_id == array_task_id)) {
job_mgr.c:			job_ptr = job_ptr->job_array_next_t;
job_mgr.c:		if (job_ptr && job_ptr->array_recs &&
job_mgr.c:		    job_ptr->array_recs->task_id_bitmap) {
job_mgr.c:			inx = bit_size(job_ptr->array_recs->task_id_bitmap);
job_mgr.c:			    bit_test(job_ptr->array_recs->task_id_bitmap,
job_mgr.c:		if (job_ptr->job_id == job_id)
job_mgr.c:		job_ptr = job_ptr->job_next;
job_mgr.c:	xfree(job_ptr->partition);
job_mgr.c:	if (!job_ptr->part_ptr_list) {
job_mgr.c:		job_ptr->partition = xstrdup(job_ptr->part_ptr->name);
job_mgr.c:		job_ptr->partition = xstrdup(job_ptr->part_ptr->name);
job_mgr.c:	part_iterator = list_iterator_create(job_ptr->part_ptr_list);
job_mgr.c:			job_ptr->part_ptr = part_ptr;
job_mgr.c:		if (job_active && (part_ptr == job_ptr->part_ptr))
job_mgr.c:		if (job_ptr->partition)
job_mgr.c:			xstrcat(job_ptr->partition, ",");
job_mgr.c:		xstrcat(job_ptr->partition, part_ptr->name);
job_mgr.c:	if (job_ptr && job_ptr->pack_job_list &&
job_mgr.c:		cnt = list_count(job_ptr->pack_job_list);
job_mgr.c:		iter = list_iterator_create(job_ptr->pack_job_list);
job_mgr.c:		if (job_ptr->part_ptr_list) {
job_mgr.c:			part_iterator = list_iterator_create(job_ptr->
job_mgr.c:				if (list_count(job_ptr->part_ptr_list) > 0) {
job_mgr.c:					job_ptr->part_ptr =
job_mgr.c:						list_peek(job_ptr->
job_mgr.c:					FREE_NULL_LIST(job_ptr->part_ptr_list);
job_mgr.c:		if (job_ptr->part_ptr != part_ptr)
job_mgr.c:			uint32_t suspend_job_state = job_ptr->job_state;
job_mgr.c:			job_ptr->job_state = JOB_CANCELLED;
job_mgr.c:			job_ptr->job_state = suspend_job_state;
job_mgr.c:			job_ptr->job_state = JOB_NODE_FAIL | JOB_COMPLETING;
job_mgr.c:			job_ptr->state_reason = FAIL_DOWN_PARTITION;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:				job_ptr->end_time = job_ptr->suspend_time;
job_mgr.c:				job_ptr->tot_sus_time +=
job_mgr.c:					difftime(now, job_ptr->suspend_time);
job_mgr.c:				job_ptr->end_time = now;
job_mgr.c:			job_ptr->job_state	= JOB_CANCELLED;
job_mgr.c:			job_ptr->start_time	= now;
job_mgr.c:			job_ptr->end_time	= now;
job_mgr.c:			job_ptr->exit_code	= 1;
job_mgr.c:		job_ptr->part_ptr = NULL;
job_mgr.c:		FREE_NULL_LIST(job_ptr->part_ptr_list);
job_mgr.c:		if (job_ptr->pack_job_id)
job_mgr.c:			pack_leader = find_job_record(job_ptr->pack_job_id);
job_mgr.c:			uint32_t suspend_job_state = job_ptr->job_state;
job_mgr.c:			job_ptr->job_state = JOB_CANCELLED;
job_mgr.c:			job_ptr->job_state = suspend_job_state;
job_mgr.c:			while ((i = bit_ffs(job_ptr->node_bitmap_cg)) >= 0) {
job_mgr.c:				bit_clear(job_ptr->node_bitmap_cg, i);
job_mgr.c:				if (job_ptr->node_cnt)
job_mgr.c:					(job_ptr->node_cnt)--;
job_mgr.c:				if (job_ptr->node_cnt == 0) {
job_mgr.c:			if (job_ptr->batch_flag && job_ptr->details &&
job_mgr.c:			    (job_ptr->details->requeue > 0)) {
job_mgr.c:				job_ptr->time_last_active  = now;
job_mgr.c:					job_ptr->end_time =
job_mgr.c:						job_ptr->suspend_time;
job_mgr.c:					job_ptr->tot_sus_time +=
job_mgr.c:							 job_ptr->
job_mgr.c:					job_ptr->end_time = now;
job_mgr.c:				job_ptr->job_state  = JOB_NODE_FAIL;
job_mgr.c:				//job_ptr->db_index = 0;
job_mgr.c:				//job_ptr->details->submit_time = now;
job_mgr.c:				job_ptr->job_state = JOB_PENDING;
job_mgr.c:				if (job_ptr->node_cnt)
job_mgr.c:					job_ptr->job_state |= JOB_COMPLETING;
job_mgr.c:				if (job_ptr->ckpt_interval &&
job_mgr.c:				    job_ptr->ckpt_time &&
job_mgr.c:				    job_ptr->details->ckpt_dir) {
job_mgr.c:					xfree(job_ptr->details->restart_dir);
job_mgr.c:					job_ptr->details->restart_dir =
job_mgr.c:						xstrdup (job_ptr->details->
job_mgr.c:					xstrfmtcat(job_ptr->details->
job_mgr.c:						   "/%u", job_ptr->job_id);
job_mgr.c:				job_ptr->restart_cnt++;
job_mgr.c:				job_ptr->warn_flags &= ~WARN_SENT;
job_mgr.c:				if (!job_ptr->node_bitmap_cg ||
job_mgr.c:				    bit_set_count(job_ptr->node_bitmap_cg) == 0)
job_mgr.c:				job_ptr->job_state = JOB_NODE_FAIL |
job_mgr.c:				job_ptr->state_reason = FAIL_DOWN_NODE;
job_mgr.c:				xfree(job_ptr->state_desc);
job_mgr.c:					job_ptr->end_time =
job_mgr.c:						job_ptr->suspend_time;
job_mgr.c:					job_ptr->tot_sus_time +=
job_mgr.c:							 job_ptr->suspend_time);
job_mgr.c:					job_ptr->end_time = now;
job_mgr.c:		if (job_ptr->part_ptr == part_ptr) {
job_mgr.c:		if (job_ptr->batch_flag || IS_JOB_FINISHED(job_ptr))
job_mgr.c:		if (job_ptr->alloc_node &&
job_mgr.c:		    (xstrcmp(job_ptr->alloc_node, new_alloc->alloc_node) == 0) &&
job_mgr.c:		    (job_ptr->alloc_sid == new_alloc->alloc_sid))
job_mgr.c:	for (i = 0; i < job_ptr->gres_detail_cnt; i++)
job_mgr.c:		xfree(job_ptr->gres_detail_str[i]);
job_mgr.c:	xfree(job_ptr->gres_detail_str);
job_mgr.c:	job_ptr->gres_detail_cnt = 0;
job_mgr.c:	if (job_ptr->node_bitmap &&
job_mgr.c:	    bit_test(job_ptr->node_bitmap, node_inx))
job_mgr.c:	if (!job_ptr->pack_job_id)
job_mgr.c:	pack_leader = find_job_record(job_ptr->pack_job_id);
job_mgr.c:			uint32_t suspend_job_state = job_ptr->job_state;
job_mgr.c:			job_ptr->job_state = JOB_CANCELLED;
job_mgr.c:			job_ptr->job_state = suspend_job_state;
job_mgr.c:			if (!bit_test(job_ptr->node_bitmap_cg, node_inx))
job_mgr.c:			bit_clear(job_ptr->node_bitmap_cg, node_inx);
job_mgr.c:			if (job_ptr->node_cnt)
job_mgr.c:				(job_ptr->node_cnt)--;
job_mgr.c:			if (job_ptr->node_cnt == 0)
job_mgr.c:			if ((job_ptr->details) &&
job_mgr.c:			    (job_ptr->kill_on_node_fail == 0) &&
job_mgr.c:			    (job_ptr->node_cnt > 1) &&
job_mgr.c:				gres_build_job_details(job_ptr->gres_list,
job_mgr.c:						       &job_ptr->gres_detail_cnt,
job_mgr.c:						       &job_ptr->gres_detail_str);
job_mgr.c:			} else if (job_ptr->batch_flag && job_ptr->details &&
job_mgr.c:				   job_ptr->details->requeue) {
job_mgr.c:				job_ptr->time_last_active  = now;
job_mgr.c:					job_ptr->end_time =
job_mgr.c:						job_ptr->suspend_time;
job_mgr.c:					job_ptr->tot_sus_time +=
job_mgr.c:							 job_ptr->
job_mgr.c:					job_ptr->end_time = now;
job_mgr.c:				job_ptr->job_state = JOB_NODE_FAIL;
job_mgr.c:				//job_ptr->db_index = 0;
job_mgr.c:				//job_ptr->details->submit_time = now;
job_mgr.c:				job_ptr->job_state = JOB_PENDING;
job_mgr.c:				if (job_ptr->node_cnt)
job_mgr.c:					job_ptr->job_state |= JOB_COMPLETING;
job_mgr.c:				if (job_ptr->ckpt_interval &&
job_mgr.c:				    job_ptr->ckpt_time &&
job_mgr.c:				    job_ptr->details->ckpt_dir) {
job_mgr.c:					xfree(job_ptr->details->restart_dir);
job_mgr.c:					job_ptr->details->restart_dir =
job_mgr.c:						xstrdup (job_ptr->details->
job_mgr.c:					xstrfmtcat(job_ptr->details->
job_mgr.c:						   "/%u", job_ptr->job_id);
job_mgr.c:				job_ptr->restart_cnt++;
job_mgr.c:				job_ptr->warn_flags &= ~WARN_SENT;
job_mgr.c:				if (!job_ptr->node_bitmap_cg ||
job_mgr.c:				    bit_set_count(job_ptr->node_bitmap_cg) == 0)
job_mgr.c:				job_ptr->job_state = JOB_NODE_FAIL |
job_mgr.c:				job_ptr->state_reason = FAIL_DOWN_NODE;
job_mgr.c:				xfree(job_ptr->state_desc);
job_mgr.c:					job_ptr->end_time =
job_mgr.c:						job_ptr->suspend_time;
job_mgr.c:					job_ptr->tot_sus_time +=
job_mgr.c:							 job_ptr->suspend_time);
job_mgr.c:					job_ptr->end_time = now;
job_mgr.c:	orig_bitmap = bit_copy(job_ptr->node_bitmap);
job_mgr.c:	xfree(job_ptr->nodes);
job_mgr.c:	job_ptr->nodes = bitmap2node_name(job_ptr->node_bitmap);
job_mgr.c:		if (!bit_test(job_ptr->node_bitmap, i))
job_mgr.c:		memcpy(&job_ptr->node_addr[new_pos],
job_mgr.c:		       &job_ptr->node_addr[orig_pos], sizeof(slurm_addr_t));
job_mgr.c:		 * NOTE: The job's allocation in the job_ptr->job_resrcs
job_mgr.c:	job_ptr->total_nodes = job_ptr->node_cnt = new_pos + 1;
job_mgr.c:	uint64_t save_db_index = job_ptr->db_index;
job_mgr.c:	job_ptr_pend->job_id = job_ptr->job_id;
job_mgr.c:	if (!job_ptr->array_recs) {
job_mgr.c:					   job_ptr->prio_factors);
job_mgr.c:	job_ptr_pend->account = xstrdup(job_ptr->account);
job_mgr.c:	job_ptr_pend->admin_comment = xstrdup(job_ptr->admin_comment);
job_mgr.c:	job_ptr_pend->alias_list = xstrdup(job_ptr->alias_list);
job_mgr.c:	job_ptr_pend->alloc_node = xstrdup(job_ptr->alloc_node);
job_mgr.c:	job_ptr_pend->array_recs = job_ptr->array_recs;
job_mgr.c:	job_ptr->array_recs = NULL;
job_mgr.c:	if (job_ptr->check_job) {
job_mgr.c:			checkpoint_copy_jobinfo(job_ptr->check_job);
job_mgr.c:	job_ptr_pend->burst_buffer = xstrdup(job_ptr->burst_buffer);
job_mgr.c:	job_ptr_pend->burst_buffer_state = xstrdup(job_ptr->burst_buffer_state);
job_mgr.c:	job_ptr_pend->clusters = xstrdup(job_ptr->clusters);
job_mgr.c:	job_ptr_pend->comment = xstrdup(job_ptr->comment);
job_mgr.c:	job_ptr_pend->fed_details = _dup_job_fed_details(job_ptr->fed_details);
job_mgr.c:	if (job_ptr->gres_list) {
job_mgr.c:			gres_plugin_job_state_dup(job_ptr->gres_list);
job_mgr.c:	memcpy(job_ptr_pend->limit_set.tres, job_ptr->limit_set.tres,
job_mgr.c:	job_ptr_pend->licenses = xstrdup(job_ptr->licenses);
job_mgr.c:	job_ptr_pend->license_list = license_job_copy(job_ptr->license_list);
job_mgr.c:	job_ptr_pend->mail_user = xstrdup(job_ptr->mail_user);
job_mgr.c:	job_ptr_pend->mcs_label = xstrdup(job_ptr->mcs_label);
job_mgr.c:	job_ptr_pend->name = xstrdup(job_ptr->name);
job_mgr.c:	job_ptr_pend->network = xstrdup(job_ptr->network);
job_mgr.c:	job_ptr_pend->partition = xstrdup(job_ptr->partition);
job_mgr.c:	job_ptr_pend->part_ptr_list = part_list_copy(job_ptr->part_ptr_list);
job_mgr.c:	if (job_ptr->part_ptr_list && job_ptr->priority_array) {
job_mgr.c:		i = list_count(job_ptr->part_ptr_list) * sizeof(uint32_t);
job_mgr.c:		       job_ptr->priority_array, i);
job_mgr.c:	job_ptr_pend->resv_name = xstrdup(job_ptr->resv_name);
job_mgr.c:	job_ptr_pend->resp_host = xstrdup(job_ptr->resp_host);
job_mgr.c:	if (job_ptr->select_jobinfo) {
job_mgr.c:			select_g_select_jobinfo_copy(job_ptr->select_jobinfo);
job_mgr.c:	if (job_ptr->spank_job_env_size) {
job_mgr.c:			xcalloc((job_ptr->spank_job_env_size + 1),
job_mgr.c:		for (i = 0; i < job_ptr->spank_job_env_size; i++) {
job_mgr.c:				xstrdup(job_ptr->spank_job_env[i]);
job_mgr.c:	job_ptr_pend->state_desc = xstrdup(job_ptr->state_desc);
job_mgr.c:	job_ptr_pend->system_comment = xstrdup(job_ptr->system_comment);
job_mgr.c:	memcpy(job_ptr_pend->tres_req_cnt, job_ptr->tres_req_cnt, i);
job_mgr.c:	job_ptr_pend->tres_req_str = xstrdup(job_ptr->tres_req_str);
job_mgr.c:	job_ptr_pend->tres_fmt_req_str = xstrdup(job_ptr->tres_fmt_req_str);
job_mgr.c:	job_ptr_pend->cpus_per_tres = xstrdup(job_ptr->cpus_per_tres);
job_mgr.c:	job_ptr_pend->mem_per_tres = xstrdup(job_ptr->mem_per_tres);
job_mgr.c:	job_ptr_pend->tres_bind = xstrdup(job_ptr->tres_bind);
job_mgr.c:	job_ptr_pend->tres_freq = xstrdup(job_ptr->tres_freq);
job_mgr.c:	job_ptr_pend->tres_per_job = xstrdup(job_ptr->tres_per_job);
job_mgr.c:	job_ptr_pend->tres_per_node = xstrdup(job_ptr->tres_per_node);
job_mgr.c:	job_ptr_pend->tres_per_socket = xstrdup(job_ptr->tres_per_socket);
job_mgr.c:	job_ptr_pend->tres_per_task = xstrdup(job_ptr->tres_per_task);
job_mgr.c:	job_ptr_pend->user_name = xstrdup(job_ptr->user_name);
job_mgr.c:	job_ptr_pend->wckey = xstrdup(job_ptr->wckey);
job_mgr.c:	job_ptr_pend->deadline = job_ptr->deadline;
job_mgr.c:	job_details = job_ptr->details;
job_mgr.c:	if (job_ptr->fed_details)
job_mgr.c:	job_ptr->array_job_id = job_ptr->job_id;
job_mgr.c:	job_ptr->array_recs = xmalloc(sizeof(job_array_struct_t));
job_mgr.c:	job_ptr->array_recs->task_id_bitmap = job_specs->array_bitmap;
job_mgr.c:	job_ptr->array_recs->task_cnt =
job_mgr.c:		bit_set_count(job_ptr->array_recs->task_id_bitmap);
job_mgr.c:	if (job_ptr->array_recs->task_cnt > 1)
job_mgr.c:		job_count += (job_ptr->array_recs->task_cnt - 1);
job_mgr.c:			job_ptr->array_recs->max_run_tasks = max_run_tasks;
job_mgr.c:	details = job_ptr->details;
job_mgr.c:	if (job_ptr->part_ptr_list) {
job_mgr.c:		list_sort(job_ptr->part_ptr_list, priority_sort_part_tier);
job_mgr.c:		iter = list_iterator_create(job_ptr->part_ptr_list);
job_mgr.c:			job_ptr->part_ptr = part_ptr;
job_mgr.c:			if ((job_ptr->preempt_in_progress) &&
job_mgr.c:		job_ptr->state_reason = WAIT_RESOURCES;
job_mgr.c:		job_ptr->state_reason = WAIT_RESERVATION;
job_mgr.c:		job_ptr->state_reason = WAIT_NODE_NOT_AVAIL;
job_mgr.c:		job_ptr->state_reason = WAIT_QOS_THRES;
job_mgr.c:		job_ptr->state_reason = WAIT_PART_CONFIG;
job_mgr.c:		job_ptr->state_reason = WAIT_POWER_NOT_AVAIL;
job_mgr.c:		job_ptr->state_reason = WAIT_BURST_BUFFER_RESOURCE;
job_mgr.c:		job_ptr->state_reason = WAIT_POWER_RESERVED;
job_mgr.c:		job_ptr->state_reason = WAIT_PART_DOWN;
job_mgr.c:		job_ptr->state_reason = FAIL_QOS;
job_mgr.c:		job_ptr->state_reason = FAIL_ACCOUNT;
job_mgr.c:	if ((job_ptr->deadline) && (job_ptr->deadline != NO_VAL)) {
job_mgr.c:			job_ptr->job_state = JOB_FAILED;
job_mgr.c:			job_ptr->exit_code = 1;
job_mgr.c:			job_ptr->state_reason = FAIL_BAD_CONSTRAINTS;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:			job_ptr->start_time = job_ptr->end_time = now;
job_mgr.c:			      job_reason_string(job_ptr->state_reason));
job_mgr.c:	if (job_ptr->priority == NO_VAL)
job_mgr.c:		job_ptr->job_state  = JOB_FAILED;
job_mgr.c:		job_ptr->exit_code  = 1;
job_mgr.c:		job_ptr->state_reason = FAIL_BAD_CONSTRAINTS;
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:		job_ptr->start_time = job_ptr->end_time = now;
job_mgr.c:			       job_reason_string(job_ptr->state_reason),
job_mgr.c:			       job_reason_string(job_ptr->state_reason),
job_mgr.c:			       job_reason_string(job_ptr->state_reason),
job_mgr.c:		job_desc_msg.job_id = job_ptr->job_id;
job_mgr.c:		job_ptr->job_state  = JOB_FAILED;
job_mgr.c:		job_ptr->exit_code  = 1;
job_mgr.c:		job_ptr->start_time = job_ptr->end_time = now;
job_mgr.c:		purge_job_record(job_ptr->job_id);
job_mgr.c:	test_only = will_run || job_ptr->deadline || (allocate == 0) ||
job_mgr.c:		    job_ptr->fed_details;
job_mgr.c:		(job_ptr->array_recs && job_ptr->array_recs->task_cnt) ?
job_mgr.c:		job_ptr->array_recs->task_cnt : 1;
job_mgr.c:			job_ptr->job_state  = JOB_FAILED;
job_mgr.c:			job_ptr->exit_code  = 1;
job_mgr.c:			job_ptr->state_reason = FAIL_BAD_CONSTRAINTS;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:			job_ptr->start_time = job_ptr->end_time = now;
job_mgr.c:			       job_reason_string(job_ptr->state_reason),
job_mgr.c:			    (job_ptr->batch_flag))) {
job_mgr.c:		job_ptr->job_state  = JOB_FAILED;
job_mgr.c:		job_ptr->exit_code  = 1;
job_mgr.c:		job_ptr->state_reason = FAIL_BAD_CONSTRAINTS;
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:		job_ptr->start_time = job_ptr->end_time = now;
job_mgr.c:		       job_reason_string(job_ptr->state_reason),
job_mgr.c:		job_ptr->job_state  = JOB_FAILED;
job_mgr.c:		job_ptr->exit_code  = 1;
job_mgr.c:		job_ptr->start_time = job_ptr->end_time = now;
job_mgr.c:		purge_job_record(job_ptr->job_id);
job_mgr.c:			     job_ptr, job_ptr->nodes);
job_mgr.c:		uint32_t suspend_job_state = job_ptr->job_state;
job_mgr.c:		job_ptr->job_state = JOB_CANCELLED;
job_mgr.c:		job_ptr->job_state = suspend_job_state;
job_mgr.c:		job_ptr->time_last_active       = now;
job_mgr.c:			job_ptr->end_time       = job_ptr->suspend_time;
job_mgr.c:			job_ptr->tot_sus_time  +=
job_mgr.c:				difftime(now, job_ptr->suspend_time);
job_mgr.c:			job_ptr->end_time       = now;
job_mgr.c:		job_ptr->job_state = job_state | JOB_COMPLETING;
job_mgr.c:		job_ptr->exit_code = 1;
job_mgr.c:		job_ptr->state_reason = FAIL_LAUNCH;
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:		if (job_ptr->node_bitmap) {
job_mgr.c:		job_ptr, job_state_string(job_ptr->job_state));
job_mgr.c:	if (job_ptr->pack_job_id == 0)
job_mgr.c:	pack_leader = find_job_record(job_ptr->pack_job_id);
job_mgr.c:		job_ptr->bit_flags |= JOB_KILL_HURRY;
job_mgr.c:	    job_ptr->fed_details && fed_mgr_fed_rec) {
job_mgr.c:		uint32_t origin_id = fed_mgr_get_cluster_id(job_ptr->job_id);
job_mgr.c:		    job_ptr->fed_details->cluster_lock &&
job_mgr.c:		    (job_ptr->fed_details->cluster_lock !=
job_mgr.c:		job_ptr->requid = uid;
job_mgr.c:		job_ptr->job_state = JOB_CANCELLED | JOB_COMPLETING;
job_mgr.c:		job_ptr->bit_flags |= JOB_KILL_HURRY;
job_mgr.c:		job_ptr->end_time       = now;
job_mgr.c:		job_ptr->job_state      = JOB_CANCELLED | JOB_COMPLETING;
job_mgr.c:			job_ptr->job_state |= JOB_REQUEUE;
job_mgr.c:			job_ptr->job_state &= (~JOB_REQUEUE);
job_mgr.c:		job_ptr->job_state	= JOB_CANCELLED;
job_mgr.c:			job_ptr->job_state |= JOB_REQUEUE;
job_mgr.c:		job_ptr->start_time	= now;
job_mgr.c:		job_ptr->end_time	= now;
job_mgr.c:			job_ptr->job_state &= (~JOB_REQUEUE);
job_mgr.c:		job_ptr->end_time       = job_ptr->suspend_time;
job_mgr.c:		job_ptr->tot_sus_time  += difftime(now, job_ptr->suspend_time);
job_mgr.c:		job_ptr->job_state      = job_term_state | JOB_COMPLETING;
job_mgr.c:			job_ptr->job_state |= JOB_REQUEUE;
job_mgr.c:			job_ptr->job_state &= (~JOB_REQUEUE);
job_mgr.c:					job_ptr->job_state);
job_mgr.c:			job_ptr->job_state |= JOB_SIGNALING;
job_mgr.c:			job_ptr->time_last_active	= now;
job_mgr.c:			job_ptr->end_time		= now;
job_mgr.c:			job_ptr->job_state = job_term_state | JOB_COMPLETING;
job_mgr.c:				job_ptr->job_state |= JOB_REQUEUE;
job_mgr.c:				job_ptr->job_state &= (~JOB_REQUEUE);
job_mgr.c:		} else if (job_ptr->batch_flag && (flags & KILL_JOB_BATCH)) {
job_mgr.c:		} else if ((flags & KILL_JOB_BATCH) && !job_ptr->batch_flag) {
job_mgr.c:				job_ptr->job_state &= ~JOB_SIGNALING;
job_mgr.c:			__func__, signal, job_ptr, job_ptr->job_state);
job_mgr.c:		job_state_string(job_ptr->job_state));
job_mgr.c:	if ((job_ptr->user_id != uid) && !validate_operator(uid) &&
job_mgr.c:					  job_ptr->account)) {
job_mgr.c:		if ((job_ptr->user_id != uid) && !validate_operator(uid) &&
job_mgr.c:						  job_ptr->account)) {
job_mgr.c:		if (job_ptr && (job_ptr->user_id != uid) &&
job_mgr.c:						  job_ptr->account)) {
job_mgr.c:		if (job_ptr && job_ptr->pack_job_list) {   /* Pack leader */
job_mgr.c:		if (job_ptr && job_ptr->pack_job_id && _get_whole_hetjob()) {
job_mgr.c:			pack_leader = find_job_record(job_ptr->pack_job_id);
job_mgr.c:		if (job_ptr && job_ptr->pack_job_id && IS_JOB_PENDING(job_ptr))
job_mgr.c:		if (job_ptr && (job_ptr->array_task_id == NO_VAL) &&
job_mgr.c:		    (job_ptr->array_recs == NULL)) {
job_mgr.c:		if (job_ptr && job_ptr->array_recs) {
job_mgr.c:			if (job_ptr->array_job_id == job_id)
job_mgr.c:			job_ptr = job_ptr->job_array_next_j;
job_mgr.c:			if ((job_ptr->array_job_id == job_id) &&
job_mgr.c:			job_ptr = job_ptr->job_array_next_j;
job_mgr.c:			if (job_ptr->array_job_id == job_id)
job_mgr.c:			job_ptr = job_ptr->job_array_next_j;
job_mgr.c:	    ((job_ptr->array_task_id == NO_VAL) &&
job_mgr.c:	     (job_ptr->array_recs == NULL))) {
job_mgr.c:	if ((job_ptr->user_id != uid) && !validate_operator(uid) &&
job_mgr.c:					  job_ptr->account)) {
job_mgr.c:	    job_ptr->array_recs && job_ptr->array_recs->task_id_bitmap) {
job_mgr.c:		len = bit_size(job_ptr->array_recs->task_id_bitmap);
job_mgr.c:			job_ptr->array_recs->task_id_bitmap = bit_realloc(
job_mgr.c:				job_ptr->array_recs->task_id_bitmap, i_last);
job_mgr.c:				bit_copy(job_ptr->array_recs->task_id_bitmap);
job_mgr.c:			bit_and_not(job_ptr->array_recs->task_id_bitmap,
job_mgr.c:			xfree(job_ptr->array_recs->task_id_str);
job_mgr.c:			orig_task_cnt = job_ptr->array_recs->task_cnt;
job_mgr.c:			new_task_count = bit_set_count(job_ptr->array_recs->
job_mgr.c:				job_ptr->job_state	= JOB_CANCELLED;
job_mgr.c:				job_ptr->start_time	= now;
job_mgr.c:				job_ptr->end_time	= now;
job_mgr.c:				job_ptr->requid		= uid;
job_mgr.c:				if (job_ptr->array_recs->task_cnt >
job_mgr.c:					uint32_t tmp_state = job_ptr->job_state;
job_mgr.c:					job_ptr->job_state = JOB_CANCELLED;
job_mgr.c:					job_ptr->array_recs->task_cnt -=
job_mgr.c:					job_ptr->bit_flags &= ~JOB_ACCRUE_OVER;
job_mgr.c:					job_ptr->job_state = tmp_state;
job_mgr.c:			job_ptr->array_recs->task_cnt = new_task_count;
job_mgr.c:				    job_ptr->array_recs->task_id_bitmap);
job_mgr.c:	xassert(job_ptr->batch_host);
job_mgr.c:	i = bit_ffs(job_ptr->node_bitmap);
job_mgr.c:	if (job_ptr->front_end_ptr)
job_mgr.c:			job_ptr->front_end_ptr->protocol_version;
job_mgr.c:	if ((node_ptr = find_node_record(job_ptr->batch_host)))
job_mgr.c:	agent_args->hostlist	= hostlist_create(job_ptr->batch_host);
job_mgr.c:	signal_tasks_msg->job_id      = job_ptr->job_id;
job_mgr.c:	job_ptr->state_reason = WAIT_NO_REASON;
job_mgr.c:		if (job_ptr->exit_code == 0)
job_mgr.c:			job_ptr->exit_code = job_return_code;
job_mgr.c:		job_ptr->start_time = now;
job_mgr.c:		uint32_t suspend_job_state = job_ptr->job_state;
job_mgr.c:		job_ptr->job_state = JOB_CANCELLED;
job_mgr.c:		job_ptr->job_state = suspend_job_state;
job_mgr.c:	if (job_comp_flag && (job_ptr->node_cnt == 0)) {
job_mgr.c:	if (requeue && job_ptr->details && job_ptr->batch_flag) {
job_mgr.c:		job_ptr->end_time = now;
job_mgr.c:		job_ptr->job_state  = JOB_NODE_FAIL;
job_mgr.c:		//job_ptr->db_index = 0;
job_mgr.c:		//job_ptr->details->submit_time = now + 1;
job_mgr.c:		if (job_ptr->node_bitmap) {
job_mgr.c:			i = bit_ffs(job_ptr->node_bitmap);
job_mgr.c:			job_ptr->batch_flag++;	/* only one retry */
job_mgr.c:		job_ptr->restart_cnt++;
job_mgr.c:		job_ptr->warn_flags &= ~WARN_SENT;
job_mgr.c:		job_ptr->job_state = JOB_PENDING | job_comp_flag;
job_mgr.c:		if (job_ptr->batch_flag > MAX_BATCH_REQUEUE) {
job_mgr.c:			job_ptr->job_state |= JOB_REQUEUE_HOLD;
job_mgr.c:			job_ptr->state_reason = WAIT_MAX_REQUEUE;
job_mgr.c:			job_ptr->batch_flag = 1;
job_mgr.c:			job_ptr->priority = 0;
job_mgr.c:	} else if (IS_JOB_PENDING(job_ptr) && job_ptr->details &&
job_mgr.c:		   job_ptr->batch_flag) {
job_mgr.c:		if (job_ptr->part_ptr &&
job_mgr.c:		    (job_ptr->part_ptr->over_time_limit != NO_VAL16)) {
job_mgr.c:			over_time_limit = job_ptr->part_ptr->over_time_limit;
job_mgr.c:			job_ptr->job_state = JOB_NODE_FAIL | job_comp_flag;
job_mgr.c:			job_ptr->requid = uid;
job_mgr.c:			job_ptr->job_state = JOB_CANCELLED | job_comp_flag;
job_mgr.c:			job_ptr->requid = uid;
job_mgr.c:			job_ptr->job_state = JOB_OOM | job_comp_flag;
job_mgr.c:			job_ptr->exit_code = job_return_code;
job_mgr.c:			job_ptr->state_reason = FAIL_OOM;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:			job_ptr->job_state = JOB_FAILED   | job_comp_flag;
job_mgr.c:			job_ptr->exit_code = job_return_code;
job_mgr.c:			job_ptr->state_reason = FAIL_EXIT_CODE;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:			job_ptr->job_state = JOB_FAILED | job_comp_flag;
job_mgr.c:			job_ptr->exit_code = job_return_code;
job_mgr.c:			job_ptr->state_reason = FAIL_LAUNCH;
job_mgr.c:			   && ((job_ptr->end_time
job_mgr.c:			job_ptr->job_state = JOB_TIMEOUT  | job_comp_flag;
job_mgr.c:			job_ptr->state_reason = FAIL_TIMEOUT;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:			job_ptr->job_state = JOB_COMPLETE | job_comp_flag;
job_mgr.c:			job_ptr->exit_code = job_return_code;
job_mgr.c:			job_ptr->end_time = job_ptr->suspend_time;
job_mgr.c:			job_ptr->tot_sus_time +=
job_mgr.c:				difftime(now, job_ptr->suspend_time);
job_mgr.c:			job_ptr->end_time = now;
job_mgr.c:	job_ptr->time_last_active = now;   /* Timer for resending kill RPC */
job_mgr.c:	if (job_ptr->details && job_ptr->details->prolog_running)
job_mgr.c:		track_script_flush_job(job_ptr->job_id);
job_mgr.c:	debug("Nodes are in the form %s",bitmap2hostlist(job_ptr->node_bitmap));
job_mgr.c:	if ((job_ptr->user_id != uid) && !validate_slurm_user(uid)) {
job_mgr.c:	if (job_ptr->pack_job_list) {
job_mgr.c:		iter = list_iterator_create(job_ptr->pack_job_list);
job_mgr.c:			if (job_ptr->pack_job_id != job_pack_ptr->pack_job_id) {
job_mgr.c:	detail_ptr = job_ptr->details;
job_mgr.c:	part_ptr = job_ptr->part_ptr;
job_mgr.c:	qos_ptr = job_ptr->qos_ptr;
job_mgr.c:	assoc_ptr = job_ptr->assoc_ptr;
job_mgr.c:	job_desc.reservation = job_ptr->resv_name;
job_mgr.c:	job_desc.user_id = job_ptr->user_id;
job_mgr.c:	job_desc.alloc_node = job_ptr->alloc_node;
job_mgr.c:	if (check_min_time && job_ptr->time_min)
job_mgr.c:		job_desc.time_limit = job_ptr->time_min;
job_mgr.c:		job_desc.time_limit = job_ptr->time_limit;
job_mgr.c:				     job_ptr->user_id, qos_ptr,
job_mgr.c:				     job_ptr->account))) {
job_mgr.c:			if (job_ptr->limit_set.time != ADMIN_SET_LIMIT)
job_mgr.c:		if (!job_ptr->prio_factors) {
job_mgr.c:			job_ptr->prio_factors =
job_mgr.c:		if (!job_ptr->prio_factors->priority_fs) {
job_mgr.c:			job_ptr->prio_factors->priority_fs =
job_mgr.c:		if (job_ptr->prio_factors->priority_fs < qos_ptr->usage_thres){
job_mgr.c:		if (job_ptr->bit_flags & JOB_MEM_SET)
job_mgr.c:		job_desc.job_id = job_ptr->job_id;
job_mgr.c:	job_ptr->start_protocol_ver = protocol_version;
job_mgr.c:	job_ptr->part_ptr = part_ptr;
job_mgr.c:	job_ptr->part_ptr_list = part_ptr_list;
job_mgr.c:	job_ptr->bit_flags |= JOB_DEPENDENT;
job_mgr.c:	job_ptr->last_sched_eval = time(NULL);
job_mgr.c:	if ((error_code = checkpoint_alloc_jobinfo(&(job_ptr->check_job)))) {
job_mgr.c:	memcpy(&job_ptr->limit_set, &acct_policy_limit_set,
job_mgr.c:	job_ptr->assoc_id = assoc_rec.id;
job_mgr.c:	job_ptr->assoc_ptr = (void *) assoc_ptr;
job_mgr.c:	job_ptr->qos_ptr = (void *) qos_ptr;
job_mgr.c:	job_ptr->qos_id = qos_rec.id;
job_mgr.c:	job_ptr->priority = job_desc->priority;
job_mgr.c:	if (job_ptr->priority == 0) {
job_mgr.c:			job_ptr->state_reason = WAIT_HELD_USER;
job_mgr.c:			job_ptr->state_reason = WAIT_HELD;
job_mgr.c:	} else if (job_ptr->priority != NO_VAL) {
job_mgr.c:		job_ptr->direct_set_prio = 1;
job_mgr.c:		job_ptr->site_factor = job_desc->site_factor;
job_mgr.c:	job_ptr->details->orig_dependency = xstrdup(job_ptr->details->
job_mgr.c:	if (!job_ptr->details->expanding_jobid) {
job_mgr.c:		job_ptr->gres_list = gres_list;
job_mgr.c:	job_ptr->gres_detail_cnt = 0;
job_mgr.c:	job_ptr->gres_detail_str = NULL;
job_mgr.c:	gres_plugin_job_state_log(job_ptr->gres_list, job_ptr->job_id);
job_mgr.c:							 job_ptr->job_id))) {
job_mgr.c:		job_ptr->batch_flag = 1;
job_mgr.c:		job_ptr->batch_flag = 0;
job_mgr.c:	job_ptr->license_list = license_list;
job_mgr.c:		job_ptr->req_switch = job_desc->req_switch;
job_mgr.c:			job_ptr->wait4switch =
job_mgr.c:			job_ptr->wait4switch = _max_switch_wait(INFINITE);
job_mgr.c:	job_ptr->best_switch = true;
job_mgr.c:		job_ptr->job_state = JOB_FAILED;
job_mgr.c:		job_ptr->exit_code = 1;
job_mgr.c:		job_ptr->state_reason = FAIL_SYSTEM;
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:		job_ptr->start_time = job_ptr->end_time = time(NULL);
job_mgr.c:		purge_job_record(job_ptr->job_id);
job_mgr.c:	use_id = (job_ptr->array_task_id != NO_VAL) ?
job_mgr.c:		job_ptr->array_job_id : job_ptr->job_id;
job_mgr.c:	if (!job_ptr->batch_flag)
job_mgr.c:	use_id = (job_ptr->array_task_id != NO_VAL) ?
job_mgr.c:		job_ptr->array_job_id : job_ptr->job_id;
job_mgr.c:	if (job_ptr->details->env_cnt) {
job_mgr.c:		for (j = 0; j < job_ptr->details->env_cnt; j++)
job_mgr.c:			pos += (strlen(job_ptr->details->env_sup[j]) + 1);
job_mgr.c:	array_ptr = xcalloc((rec_cnt + job_ptr->details->env_cnt),
job_mgr.c:	if (job_ptr->details->env_cnt) {
job_mgr.c:		for (j = 0; j < job_ptr->details->env_cnt; j++) {
job_mgr.c:			tmp_chr = strchr(job_ptr->details->env_sup[j], '=');
job_mgr.c:				      job_ptr->details->env_sup[j]);
job_mgr.c:			env_len  = strlen(job_ptr->details->env_sup[j]) + 1;
job_mgr.c:			name_len = tmp_chr - job_ptr->details->env_sup[j] + 1;
job_mgr.c:					     job_ptr->details->env_sup[j],
job_mgr.c:				       job_ptr->details->env_sup[j], env_len);
job_mgr.c:				       job_ptr->details->env_sup[j], env_len);
job_mgr.c:	job_ptr->partition = xstrdup(job_desc->partition);
job_mgr.c:		job_ptr->profile = job_desc->profile;
job_mgr.c:		job_ptr->job_id = job_desc->job_id;
job_mgr.c:	job_ptr->name = xstrdup(job_desc->name);
job_mgr.c:	job_ptr->wckey = xstrdup(job_desc->wckey);
job_mgr.c:	job_ptr->tres_req_cnt = job_desc->tres_req_cnt;
job_mgr.c:	job_ptr->user_id    = (uid_t) job_desc->user_id;
job_mgr.c:	job_ptr->group_id   = (gid_t) job_desc->group_id;
job_mgr.c:	job_ptr->job_state  = JOB_PENDING;
job_mgr.c:	job_ptr->time_limit = job_desc->time_limit;
job_mgr.c:	job_ptr->deadline   = job_desc->deadline;
job_mgr.c:		job_ptr->delay_boot   = delay_boot;
job_mgr.c:		job_ptr->delay_boot   = job_desc->delay_boot;
job_mgr.c:		job_ptr->time_min = job_desc->time_min;
job_mgr.c:	job_ptr->alloc_sid  = job_desc->alloc_sid;
job_mgr.c:	job_ptr->alloc_node = xstrdup(job_desc->alloc_node);
job_mgr.c:	job_ptr->account    = xstrdup(job_desc->account);
job_mgr.c:	job_ptr->batch_features = xstrdup(job_desc->batch_features);
job_mgr.c:	job_ptr->burst_buffer = xstrdup(job_desc->burst_buffer);
job_mgr.c:	job_ptr->network    = xstrdup(job_desc->network);
job_mgr.c:	job_ptr->resv_name  = xstrdup(job_desc->reservation);
job_mgr.c:	job_ptr->restart_cnt = job_desc->restart_cnt;
job_mgr.c:	job_ptr->comment    = xstrdup(job_desc->comment);
job_mgr.c:	job_ptr->admin_comment = xstrdup(job_desc->admin_comment);
job_mgr.c:		job_ptr->kill_on_node_fail = job_desc->kill_on_node_fail;
job_mgr.c:	job_ptr->resp_host = xstrdup(job_desc->resp_host);
job_mgr.c:	job_ptr->alloc_resp_port = job_desc->alloc_resp_port;
job_mgr.c:	job_ptr->other_port = job_desc->other_port;
job_mgr.c:	job_ptr->power_flags = job_desc->power_flags;
job_mgr.c:	job_ptr->time_last_active = time(NULL);
job_mgr.c:	job_ptr->cr_enabled = 0;
job_mgr.c:	job_ptr->derived_ec = 0;
job_mgr.c:	job_ptr->licenses  = xstrdup(job_desc->licenses);
job_mgr.c:	job_ptr->mail_type = job_desc->mail_type;
job_mgr.c:	job_ptr->mail_user = xstrdup(job_desc->mail_user);
job_mgr.c:	job_ptr->bit_flags = job_desc->bitflags;
job_mgr.c:	job_ptr->bit_flags &= ~BACKFILL_TEST;
job_mgr.c:	job_ptr->ckpt_interval = job_desc->ckpt_interval;
job_mgr.c:	job_ptr->spank_job_env = job_desc->spank_job_env;
job_mgr.c:	job_ptr->spank_job_env_size = job_desc->spank_job_env_size;
job_mgr.c:	job_ptr->mcs_label = xstrdup(job_desc->mcs_label);
job_mgr.c:	job_ptr->origin_cluster = xstrdup(job_desc->origin_cluster);
job_mgr.c:	job_ptr->cpus_per_tres = xstrdup(job_desc->cpus_per_tres);
job_mgr.c:	job_ptr->mem_per_tres = xstrdup(job_desc->mem_per_tres);
job_mgr.c:	job_ptr->tres_bind = xstrdup(job_desc->tres_bind);
job_mgr.c:	job_ptr->tres_freq = xstrdup(job_desc->tres_freq);
job_mgr.c:	job_ptr->tres_per_job = xstrdup(job_desc->tres_per_job);
job_mgr.c:	job_ptr->tres_per_node = xstrdup(job_desc->tres_per_node);
job_mgr.c:	job_ptr->tres_per_socket = xstrdup(job_desc->tres_per_socket);
job_mgr.c:	job_ptr->tres_per_task = xstrdup(job_desc->tres_per_task);
job_mgr.c:		job_ptr->wait_all_nodes = _default_wait_all_nodes(job_desc);
job_mgr.c:		job_ptr->wait_all_nodes = job_desc->wait_all_nodes;
job_mgr.c:	job_ptr->warn_flags  = job_desc->warn_flags;
job_mgr.c:	job_ptr->warn_signal = job_desc->warn_signal;
job_mgr.c:	job_ptr->warn_time   = job_desc->warn_time;
job_mgr.c:	detail_ptr = job_ptr->details;
job_mgr.c:		job_ptr->fed_details = xmalloc(sizeof(job_fed_details_t));
job_mgr.c:		job_ptr->fed_details->siblings_viable =
job_mgr.c:		job_ptr->reboot = MIN(job_desc->reboot, 1);
job_mgr.c:		job_ptr->reboot = 0;
job_mgr.c:	job_ptr->select_jobinfo =
job_mgr.c:	select_g_select_jobinfo_set(job_ptr->select_jobinfo,
job_mgr.c:				    job_ptr->network);
job_mgr.c:	job_ptr->clusters = xstrdup(job_desc->clusters);
job_mgr.c:	if ((job_ptr->bit_flags & SPREAD_JOB) && (detail_ptr->max_nodes == 0) &&
job_mgr.c:	delta_t = difftime(now, job_ptr->start_time);
job_mgr.c:	if ((job_ptr->job_id != boot_job_id) && !IS_JOB_CONFIGURING(job_ptr))
job_mgr.c:		job_ptr->tot_sus_time = delta_t;
job_mgr.c:	if ((job_ptr->time_limit != INFINITE) &&
job_mgr.c:	    ((job_ptr->job_id == boot_job_id) || (delta_t != 0))) {
job_mgr.c:		job_ptr->end_time = now + (job_ptr->time_limit * 60);
job_mgr.c:		job_ptr->end_time_exp = job_ptr->end_time;
job_mgr.c:	if (!job_ptr->pack_job_id) {
job_mgr.c:	pack_leader = find_job_record(job_ptr->pack_job_id);
job_mgr.c:	job_ptr->job_state &= ~JOB_CONFIGURING;
job_mgr.c:		job_ptr->job_state &= ~JOB_POWER_UP_NODE;
job_mgr.c:		job_ptr->start_time = now;
job_mgr.c:		_pack_time_limit_incr(job_ptr, job_ptr->job_id);
job_mgr.c:	if (job_ptr->batch_flag)
job_mgr.c:	if (!job_ptr->node_bitmap)	/* Revoked allocation */
job_mgr.c:	if (bit_overlap(job_ptr->node_bitmap, power_node_bitmap))
job_mgr.c:	if (!job_ptr->batch_flag ||
job_mgr.c:	    job_ptr->wait_all_nodes || job_ptr->burst_buffer) {
job_mgr.c:	} else if (job_ptr->batch_flag) {
job_mgr.c:		int i_first = bit_ffs(job_ptr->node_bitmap);
job_mgr.c:	if ((job_ptr->bit_flags & NODE_MEM_CALC) &&
job_mgr.c:		job_ptr->tres_alloc_cnt[TRES_ARRAY_MEM] =
job_mgr.c:			job_get_tres_mem(job_ptr->job_resrcs,
job_mgr.c:				job_ptr->details->pn_min_memory,
job_mgr.c:				job_ptr->tres_alloc_cnt[TRES_ARRAY_CPU],
job_mgr.c:				job_ptr->tres_alloc_cnt[TRES_ARRAY_NODE]);
job_mgr.c:	if (!job_ptr->pack_job_id)
job_mgr.c:	pack_leader = find_job_record(job_ptr->pack_job_id);
job_mgr.c:		xassert (job_ptr->magic == JOB_MAGIC);
job_mgr.c:		if (job_ptr->details)
job_mgr.c:			prolog = job_ptr->details->prolog_running;
job_mgr.c:			if (job_ptr->bit_flags & NODE_REBOOT) {
job_mgr.c:				job_ptr->bit_flags &= (~NODE_REBOOT);
job_mgr.c:				if (job_ptr->batch_flag)
job_mgr.c:		    (job_ptr->state_reason == FAIL_BAD_CONSTRAINTS) &&
job_mgr.c:		    IS_JOB_PENDING(job_ptr) && (job_ptr->priority == 0)) {
job_mgr.c:			job_ptr->state_reason = WAIT_NO_REASON;
job_mgr.c:		if (job_ptr->preempt_time) {
job_mgr.c:			if (job_ptr->end_time <= now) {
job_mgr.c:				job_ptr->job_state = JOB_PREEMPTED |
job_mgr.c:				xfree(job_ptr->state_desc);
job_mgr.c:		    (job_ptr->batch_flag == 0)    &&
job_mgr.c:		    (job_ptr->time_last_active <= old) &&
job_mgr.c:		    (job_ptr->other_port) &&
job_mgr.c:		    (job_ptr->part_ptr) &&
job_mgr.c:		    (!(job_ptr->part_ptr->flags & PART_FLAG_ROOT_ONLY))) {
job_mgr.c:			job_ptr->state_reason = FAIL_INACTIVE_LIMIT;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:		if (job_ptr->time_limit != INFINITE) {
job_mgr.c:			if ((job_ptr->mail_type & MAIL_JOB_TIME100) &&
job_mgr.c:			    (now >= job_ptr->end_time)) {
job_mgr.c:				job_ptr->mail_type &= (~MAIL_JOB_TIME100);
job_mgr.c:			if ((job_ptr->mail_type & MAIL_JOB_TIME90) &&
job_mgr.c:			    (now + (job_ptr->time_limit * 60 * 0.1) >=
job_mgr.c:			     job_ptr->end_time)) {
job_mgr.c:				job_ptr->mail_type &= (~MAIL_JOB_TIME90);
job_mgr.c:			if ((job_ptr->mail_type & MAIL_JOB_TIME80) &&
job_mgr.c:			    (now + (job_ptr->time_limit * 60 * 0.2) >=
job_mgr.c:			     job_ptr->end_time)) {
job_mgr.c:				job_ptr->mail_type &= (~MAIL_JOB_TIME80);
job_mgr.c:			if ((job_ptr->mail_type & MAIL_JOB_TIME50) &&
job_mgr.c:			    (now + (job_ptr->time_limit * 60 * 0.5) >=
job_mgr.c:			     job_ptr->end_time)) {
job_mgr.c:				job_ptr->mail_type &= (~MAIL_JOB_TIME50);
job_mgr.c:			if (job_ptr->part_ptr &&
job_mgr.c:			    (job_ptr->part_ptr->over_time_limit != NO_VAL16)) {
job_mgr.c:					job_ptr->part_ptr->over_time_limit;
job_mgr.c:			if (job_ptr->end_time <= over_run) {
job_mgr.c:				job_ptr->state_reason = FAIL_TIMEOUT;
job_mgr.c:				xfree(job_ptr->state_desc);
job_mgr.c:		if (job_ptr->resv_ptr &&
job_mgr.c:		    !(job_ptr->resv_ptr->flags & RESERVE_FLAG_FLEX) &&
job_mgr.c:		    (job_ptr->resv_ptr->end_time + resv_over_run) < time(NULL)){
job_mgr.c:			job_ptr->state_reason = FAIL_TIMEOUT;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:		if (job_ptr->step_list &&
job_mgr.c:		    (list_count(job_ptr->step_list) > 0))
job_mgr.c:		if (job_ptr->state_reason == FAIL_TIMEOUT) {
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:		if (job_ptr->end_time <= (now + PERIODIC_TIMEOUT * 2))
job_mgr.c:	xfree(job_ptr->tres_req_str);
job_mgr.c:	xfree(job_ptr->tres_fmt_req_str);
job_mgr.c:	xfree(job_ptr->tres_req_cnt);
job_mgr.c:	job_ptr->tres_req_cnt = xcalloc(g_tres_count, sizeof(uint64_t));
job_mgr.c:	if (job_ptr->details) {
job_mgr.c:		node_cnt = job_ptr->details->min_nodes;
job_mgr.c:		cpu_cnt = job_ptr->details->min_cpus;
job_mgr.c:		if (job_ptr->details->pn_min_memory)
job_mgr.c:			mem_cnt = job_ptr->details->pn_min_memory;
job_mgr.c:	if (job_ptr->total_cpus)
job_mgr.c:		cpu_cnt = job_ptr->total_cpus;
job_mgr.c:	if (job_ptr->node_cnt)
job_mgr.c:		node_cnt = job_ptr->node_cnt;
job_mgr.c:	job_ptr->tres_req_cnt[TRES_ARRAY_NODE] = (uint64_t)node_cnt;
job_mgr.c:	job_ptr->tres_req_cnt[TRES_ARRAY_CPU] = (uint64_t)cpu_cnt;
job_mgr.c:	job_ptr->tres_req_cnt[TRES_ARRAY_MEM] = job_get_tres_mem(
job_mgr.c:							job_ptr->job_resrcs,
job_mgr.c:	license_set_job_tres_cnt(job_ptr->license_list,
job_mgr.c:				 job_ptr->tres_req_cnt,
job_mgr.c:	gres_set_job_tres_cnt(job_ptr->gres_list,
job_mgr.c:			      job_ptr->tres_req_cnt,
job_mgr.c:			      job_ptr->tres_req_cnt,
job_mgr.c:	if (job_ptr->part_ptr)
job_mgr.c:		job_ptr->tres_req_cnt[TRES_ARRAY_BILLING] =
job_mgr.c:				job_ptr->tres_req_cnt,
job_mgr.c:				job_ptr->part_ptr->billing_weights,
job_mgr.c:	xfree(job_ptr->tres_alloc_str);
job_mgr.c:	xfree(job_ptr->tres_alloc_cnt);
job_mgr.c:	xfree(job_ptr->tres_fmt_alloc_str);
job_mgr.c:	job_ptr->tres_alloc_cnt = xcalloc(slurmctld_tres_cnt, sizeof(uint64_t));
job_mgr.c:	job_ptr->tres_alloc_cnt[TRES_ARRAY_CPU] = (uint64_t)job_ptr->total_cpus;
job_mgr.c:	alloc_nodes = job_ptr->node_cnt;
job_mgr.c:	job_ptr->tres_alloc_cnt[TRES_ARRAY_NODE] = (uint64_t)alloc_nodes;
job_mgr.c:	job_ptr->tres_alloc_cnt[TRES_ARRAY_MEM] =
job_mgr.c:			job_ptr->job_resrcs,
job_mgr.c:			job_ptr->details->pn_min_memory,
job_mgr.c:			job_ptr->tres_alloc_cnt[TRES_ARRAY_CPU],
job_mgr.c:			job_ptr->tres_alloc_cnt[TRES_ARRAY_NODE]);
job_mgr.c:	job_ptr->tres_alloc_cnt[TRES_ARRAY_ENERGY] = NO_VAL64;
job_mgr.c:	license_set_job_tres_cnt(job_ptr->license_list,
job_mgr.c:				 job_ptr->tres_alloc_cnt,
job_mgr.c:	gres_set_job_tres_cnt(job_ptr->gres_list,
job_mgr.c:			      job_ptr->tres_alloc_cnt,
job_mgr.c:			      job_ptr->tres_alloc_cnt,
job_mgr.c:	job_ptr->tres_alloc_cnt[TRES_ARRAY_BILLING] =
job_mgr.c:		calc_job_billable_tres(job_ptr, job_ptr->start_time, true);
job_mgr.c:	if (job_ptr->details->whole_node == 1) {
job_mgr.c:				job_ptr->job_resrcs, node_inx)) < 0) {
job_mgr.c:			job_ptr->cpu_cnt = 0;
job_mgr.c:		cpu_cnt = job_ptr->job_resrcs->cpus[offset];
job_mgr.c:	if (cpu_cnt > job_ptr->cpu_cnt) {
job_mgr.c:		      cpu_cnt, job_ptr->cpu_cnt, job_ptr);
job_mgr.c:		job_ptr->cpu_cnt = 0;
job_mgr.c:		job_ptr->cpu_cnt -= cpu_cnt;
job_mgr.c:		if (cpu_cnt > job_ptr->total_cpus) {
job_mgr.c:			job_ptr->total_cpus = 0;
job_mgr.c:			job_ptr->total_cpus -= cpu_cnt;
job_mgr.c:	if (job_ptr->details) {
job_mgr.c:		job_ptr->end_time           = now;
job_mgr.c:		job_ptr->time_last_active   = now;
job_mgr.c:		if (!job_ptr->preempt_time)
job_mgr.c:			job_ptr->job_state = JOB_TIMEOUT | JOB_COMPLETING;
job_mgr.c:	xassert (job_ptr->magic == JOB_MAGIC);
job_mgr.c:	job_ptr->magic = 0;	/* make sure we don't delete record twice */
job_mgr.c:	fed_mgr_remove_fed_job_info(job_ptr->job_id);
job_mgr.c:	if (job_ptr->array_recs) {
job_mgr.c:		job_array_size = MAX(1, job_ptr->array_recs->task_cnt);
job_mgr.c:	if (job_ptr->array_task_id != NO_VAL) {
job_mgr.c:	xfree(job_ptr->account);
job_mgr.c:	xfree(job_ptr->admin_comment);
job_mgr.c:	xfree(job_ptr->alias_list);
job_mgr.c:	xfree(job_ptr->alloc_node);
job_mgr.c:	if (job_ptr->array_recs) {
job_mgr.c:		FREE_NULL_BITMAP(job_ptr->array_recs->task_id_bitmap);
job_mgr.c:		xfree(job_ptr->array_recs->task_id_str);
job_mgr.c:		xfree(job_ptr->array_recs);
job_mgr.c:	xfree(job_ptr->batch_features);
job_mgr.c:	xfree(job_ptr->batch_host);
job_mgr.c:	xfree(job_ptr->burst_buffer);
job_mgr.c:	checkpoint_free_jobinfo(job_ptr->check_job);
job_mgr.c:	xfree(job_ptr->comment);
job_mgr.c:	xfree(job_ptr->clusters);
job_mgr.c:	xfree(job_ptr->cpus_per_tres);
job_mgr.c:	free_job_fed_details(&job_ptr->fed_details);
job_mgr.c:	free_job_resources(&job_ptr->job_resrcs);
job_mgr.c:	xfree(job_ptr->gres_alloc);
job_mgr.c:	xfree(job_ptr->gres_req);
job_mgr.c:	xfree(job_ptr->gres_used);
job_mgr.c:	FREE_NULL_LIST(job_ptr->gres_list);
job_mgr.c:	xfree(job_ptr->licenses);
job_mgr.c:	FREE_NULL_LIST(job_ptr->license_list);
job_mgr.c:	xfree(job_ptr->limit_set.tres);
job_mgr.c:	xfree(job_ptr->mail_user);
job_mgr.c:	xfree(job_ptr->mcs_label);
job_mgr.c:	xfree(job_ptr->mem_per_tres);
job_mgr.c:	xfree(job_ptr->name);
job_mgr.c:	xfree(job_ptr->network);
job_mgr.c:	xfree(job_ptr->node_addr);
job_mgr.c:	FREE_NULL_BITMAP(job_ptr->node_bitmap);
job_mgr.c:	FREE_NULL_BITMAP(job_ptr->node_bitmap_cg);
job_mgr.c:	xfree(job_ptr->nodes);
job_mgr.c:	xfree(job_ptr->nodes_completing);
job_mgr.c:	xfree(job_ptr->origin_cluster);
job_mgr.c:	if (job_ptr->pack_details && job_ptr->pack_job_id) {
job_mgr.c:		if (job_ptr->pack_job_offset == 0)
job_mgr.c:			xfree(job_ptr->pack_details);
job_mgr.c:			job_ptr->pack_details = NULL;
job_mgr.c:	xfree(job_ptr->pack_job_id_set);
job_mgr.c:	FREE_NULL_LIST(job_ptr->pack_job_list);
job_mgr.c:	xfree(job_ptr->partition);
job_mgr.c:	FREE_NULL_LIST(job_ptr->part_ptr_list);
job_mgr.c:	xfree(job_ptr->priority_array);
job_mgr.c:	slurm_destroy_priority_factors_object(job_ptr->prio_factors);
job_mgr.c:	xfree(job_ptr->resp_host);
job_mgr.c:	xfree(job_ptr->resv_name);
job_mgr.c:	xfree(job_ptr->sched_nodes);
job_mgr.c:	for (i = 0; i < job_ptr->spank_job_env_size; i++)
job_mgr.c:		xfree(job_ptr->spank_job_env[i]);
job_mgr.c:	xfree(job_ptr->spank_job_env);
job_mgr.c:	xfree(job_ptr->state_desc);
job_mgr.c:	xfree(job_ptr->system_comment);
job_mgr.c:	xfree(job_ptr->tres_alloc_cnt);
job_mgr.c:	xfree(job_ptr->tres_alloc_str);
job_mgr.c:	xfree(job_ptr->tres_bind);
job_mgr.c:	xfree(job_ptr->tres_freq);
job_mgr.c:	xfree(job_ptr->tres_fmt_alloc_str);
job_mgr.c:	xfree(job_ptr->tres_per_job);
job_mgr.c:	xfree(job_ptr->tres_per_node);
job_mgr.c:	xfree(job_ptr->tres_per_socket);
job_mgr.c:	xfree(job_ptr->tres_per_task);
job_mgr.c:	xfree(job_ptr->tres_req_cnt);
job_mgr.c:	xfree(job_ptr->tres_req_str);
job_mgr.c:	xfree(job_ptr->tres_fmt_req_str);
job_mgr.c:	select_g_select_jobinfo_free(job_ptr->select_jobinfo);
job_mgr.c:	xfree(job_ptr->user_name);
job_mgr.c:	xfree(job_ptr->wckey);
job_mgr.c:	job_ptr->job_id = 0;
job_mgr.c:	if (key && job_ptr->pack_job_id)
job_mgr.c:		if (job_ptr->time_last_active < kill_age) {
job_mgr.c:			job_ptr->time_last_active = now;
job_mgr.c:	if (job_ptr->epilog_running)
job_mgr.c:	if (fed_mgr_fed_rec && job_ptr->fed_details &&
job_mgr.c:		uint32_t origin_id = fed_mgr_get_cluster_id(job_ptr->job_id);
job_mgr.c:	if (job_ptr->end_time > min_age)
job_mgr.c:	if (job_ptr->step_list && list_count(job_ptr->step_list)) {
job_mgr.c:		      job_ptr, list_count(job_ptr->step_list));
job_mgr.c:		if (job_ptr->end_time <= min_age) {
job_mgr.c:			     job_ptr, job_ptr->nodes);
job_mgr.c:	if (job_ptr->array_recs) {
job_mgr.c:		if (job_ptr->array_recs->tot_run_tasks ||
job_mgr.c:		    !_test_job_array_purged(job_ptr->array_job_id)) {
job_mgr.c:	select_g_select_jobinfo_get(job_ptr->select_jobinfo,
job_mgr.c:	if (with_slurmdbd && !job_ptr->db_index)
job_mgr.c:	if (job_ptr->part_ptr_list) {
job_mgr.c:		part_iterator = list_iterator_create(job_ptr->part_ptr_list);
job_mgr.c:	if (job_ptr->part_ptr && part_is_visible(job_ptr->part_ptr, uid))
job_mgr.c:	    (job_ptr->user_id != uid) && !validate_operator(uid) &&
job_mgr.c:					    job_ptr->account)) ||
job_mgr.c:	      (mcs_g_check_mcs_label(uid, job_ptr->mcs_label) != 0))))
job_mgr.c:	xassert (job_ptr->magic == JOB_MAGIC);
job_mgr.c:	    (pack_info->filter_uid != job_ptr->user_id))
job_mgr.c:	iter = list_iterator_create(job_ptr->pack_job_list);
job_mgr.c:		if (pack_ptr->pack_job_id == job_ptr->pack_job_id) {
job_mgr.c:	if (job_ptr && job_ptr->pack_job_list) {
job_mgr.c:	} else if (job_ptr && (job_ptr->array_task_id == NO_VAL) &&
job_mgr.c:		   !job_ptr->array_recs) {
job_mgr.c:			if ((job_ptr->job_id == job_id) && packed_head) {
job_mgr.c:			} else if (job_ptr->array_job_id == job_id) {
job_mgr.c:			job_ptr = job_ptr->job_array_next_j;
job_mgr.c:	    (dump_job_ptr->gres_list == NULL)) {
job_mgr.c:	packstr_array(dump_job_ptr->gres_detail_str,
job_mgr.c:		      dump_job_ptr->gres_detail_cnt, buffer);
job_mgr.c:		detail_ptr = dump_job_ptr->details;
job_mgr.c:		pack32(dump_job_ptr->array_job_id, buffer);
job_mgr.c:		pack32(dump_job_ptr->array_task_id, buffer);
job_mgr.c:		if (dump_job_ptr->array_recs) {
job_mgr.c:			packstr(dump_job_ptr->array_recs->task_id_str, buffer);
job_mgr.c:			pack32(dump_job_ptr->array_recs->max_run_tasks, buffer);
job_mgr.c:			if (dump_job_ptr->array_job_id) {
job_mgr.c:						dump_job_ptr->array_job_id);
job_mgr.c:		pack32(dump_job_ptr->assoc_id, buffer);
job_mgr.c:		pack32(dump_job_ptr->delay_boot, buffer);
job_mgr.c:		pack32(dump_job_ptr->job_id,   buffer);
job_mgr.c:		pack32(dump_job_ptr->user_id,  buffer);
job_mgr.c:		pack32(dump_job_ptr->group_id, buffer);
job_mgr.c:		pack32(dump_job_ptr->pack_job_id, buffer);
job_mgr.c:		packstr(dump_job_ptr->pack_job_id_set, buffer);
job_mgr.c:		pack32(dump_job_ptr->pack_job_offset, buffer);
job_mgr.c:		pack32(dump_job_ptr->profile,  buffer);
job_mgr.c:		pack32(dump_job_ptr->job_state,    buffer);
job_mgr.c:		pack16(dump_job_ptr->batch_flag,   buffer);
job_mgr.c:		if ((dump_job_ptr->state_reason == WAIT_NO_REASON) &&
job_mgr.c:			pack16(dump_job_ptr->state_reason_prev, buffer);
job_mgr.c:			pack16(dump_job_ptr->state_reason, buffer);
job_mgr.c:		pack8(dump_job_ptr->power_flags,   buffer);
job_mgr.c:		pack8(dump_job_ptr->reboot,        buffer);
job_mgr.c:		pack16(dump_job_ptr->restart_cnt,  buffer);
job_mgr.c:		pack_time(dump_job_ptr->deadline, buffer);
job_mgr.c:		pack32(dump_job_ptr->alloc_sid, buffer);
job_mgr.c:		if ((dump_job_ptr->time_limit == NO_VAL)
job_mgr.c:		    && dump_job_ptr->part_ptr)
job_mgr.c:			time_limit = dump_job_ptr->part_ptr->max_time;
job_mgr.c:			time_limit = dump_job_ptr->time_limit;
job_mgr.c:		pack32(dump_job_ptr->time_min, buffer);
job_mgr.c:		if (dump_job_ptr->details) {
job_mgr.c:			pack32(dump_job_ptr->details->nice,  buffer);
job_mgr.c:			pack_time(dump_job_ptr->details->submit_time, buffer);
job_mgr.c:			begin_time = dump_job_ptr->details->begin_time;
job_mgr.c:			accrue_time = dump_job_ptr->details->accrue_time;
job_mgr.c:			start_time = dump_job_ptr->start_time;
job_mgr.c:			end_time = dump_job_ptr->end_time;
job_mgr.c:		} else if (dump_job_ptr->start_time != 0) {
job_mgr.c:			start_time = MAX(dump_job_ptr->start_time, time(NULL));
job_mgr.c:				end_time = MAX(dump_job_ptr->end_time,
job_mgr.c:				end_time = MAX(dump_job_ptr->end_time,
job_mgr.c:		pack_time(dump_job_ptr->suspend_time, buffer);
job_mgr.c:		pack_time(dump_job_ptr->pre_sus_time, buffer);
job_mgr.c:		pack_time(dump_job_ptr->resize_time, buffer);
job_mgr.c:		pack_time(dump_job_ptr->last_sched_eval, buffer);
job_mgr.c:		pack_time(dump_job_ptr->preempt_time, buffer);
job_mgr.c:		pack32(dump_job_ptr->priority, buffer);
job_mgr.c:		packdouble(dump_job_ptr->billable_tres, buffer);
job_mgr.c:			packstr(dump_job_ptr->nodes, buffer);
job_mgr.c:				bitmap2node_name(dump_job_ptr->node_bitmap_cg);
job_mgr.c:		packstr(dump_job_ptr->sched_nodes, buffer);
job_mgr.c:		if (!IS_JOB_PENDING(dump_job_ptr) && dump_job_ptr->part_ptr)
job_mgr.c:			packstr(dump_job_ptr->part_ptr->name, buffer);
job_mgr.c:			packstr(dump_job_ptr->partition, buffer);
job_mgr.c:		packstr(dump_job_ptr->account, buffer);
job_mgr.c:		packstr(dump_job_ptr->admin_comment, buffer);
job_mgr.c:		pack32(dump_job_ptr->site_factor, buffer);
job_mgr.c:		packstr(dump_job_ptr->network, buffer);
job_mgr.c:		packstr(dump_job_ptr->comment, buffer);
job_mgr.c:		packstr(dump_job_ptr->batch_features, buffer);
job_mgr.c:		packstr(dump_job_ptr->batch_host, buffer);
job_mgr.c:		packstr(dump_job_ptr->burst_buffer, buffer);
job_mgr.c:		packstr(dump_job_ptr->burst_buffer_state, buffer);
job_mgr.c:		packstr(dump_job_ptr->system_comment, buffer);
job_mgr.c:		if (dump_job_ptr->qos_ptr)
job_mgr.c:			packstr(dump_job_ptr->qos_ptr->name, buffer);
job_mgr.c:							dump_job_ptr->qos_id),
job_mgr.c:		packstr(dump_job_ptr->licenses, buffer);
job_mgr.c:		packstr(dump_job_ptr->state_desc, buffer);
job_mgr.c:		packstr(dump_job_ptr->resv_name, buffer);
job_mgr.c:		packstr(dump_job_ptr->mcs_label, buffer);
job_mgr.c:		pack32(dump_job_ptr->exit_code, buffer);
job_mgr.c:		pack32(dump_job_ptr->derived_ec, buffer);
job_mgr.c:			pack_job_resources(dump_job_ptr->job_resrcs, buffer,
job_mgr.c:		packstr(dump_job_ptr->name, buffer);
job_mgr.c:		packstr(dump_job_ptr->user_name, buffer);
job_mgr.c:		packstr(dump_job_ptr->wckey, buffer);
job_mgr.c:		pack32(dump_job_ptr->req_switch, buffer);
job_mgr.c:		pack32(dump_job_ptr->wait4switch, buffer);
job_mgr.c:		packstr(dump_job_ptr->alloc_node, buffer);
job_mgr.c:			pack_bit_str_hex(dump_job_ptr->node_bitmap, buffer);
job_mgr.c:			pack_bit_str_hex(dump_job_ptr->node_bitmap_cg, buffer);
job_mgr.c:		select_g_select_jobinfo_pack(dump_job_ptr->select_jobinfo,
job_mgr.c:		pack32(dump_job_ptr->bit_flags, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_fmt_alloc_str, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_fmt_req_str, buffer);
job_mgr.c:		pack16(dump_job_ptr->start_protocol_ver, buffer);
job_mgr.c:		if (dump_job_ptr->fed_details) {
job_mgr.c:			packstr(dump_job_ptr->fed_details->origin_str, buffer);
job_mgr.c:			pack64(dump_job_ptr->fed_details->siblings_active,
job_mgr.c:			packstr(dump_job_ptr->fed_details->siblings_active_str,
job_mgr.c:			pack64(dump_job_ptr->fed_details->siblings_viable,
job_mgr.c:			packstr(dump_job_ptr->fed_details->siblings_viable_str,
job_mgr.c:		packstr(dump_job_ptr->cpus_per_tres, buffer);
job_mgr.c:		packstr(dump_job_ptr->mem_per_tres, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_bind, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_freq, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_per_job, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_per_node, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_per_socket, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_per_task, buffer);
job_mgr.c:		detail_ptr = dump_job_ptr->details;
job_mgr.c:		pack32(dump_job_ptr->array_job_id, buffer);
job_mgr.c:		pack32(dump_job_ptr->array_task_id, buffer);
job_mgr.c:		if (dump_job_ptr->array_recs) {
job_mgr.c:			packstr(dump_job_ptr->array_recs->task_id_str, buffer);
job_mgr.c:			pack32(dump_job_ptr->array_recs->max_run_tasks, buffer);
job_mgr.c:		pack32(dump_job_ptr->assoc_id, buffer);
job_mgr.c:		pack32(dump_job_ptr->delay_boot, buffer);
job_mgr.c:		pack32(dump_job_ptr->job_id,   buffer);
job_mgr.c:		pack32(dump_job_ptr->user_id,  buffer);
job_mgr.c:		pack32(dump_job_ptr->group_id, buffer);
job_mgr.c:		pack32(dump_job_ptr->pack_job_id, buffer);
job_mgr.c:		packstr(dump_job_ptr->pack_job_id_set, buffer);
job_mgr.c:		pack32(dump_job_ptr->pack_job_offset, buffer);
job_mgr.c:		pack32(dump_job_ptr->profile,  buffer);
job_mgr.c:		pack32(dump_job_ptr->job_state,    buffer);
job_mgr.c:		pack16(dump_job_ptr->batch_flag,   buffer);
job_mgr.c:		if ((dump_job_ptr->state_reason == WAIT_NO_REASON) &&
job_mgr.c:			pack16(dump_job_ptr->state_reason_prev, buffer);
job_mgr.c:			pack16(dump_job_ptr->state_reason, buffer);
job_mgr.c:		pack8(dump_job_ptr->power_flags,   buffer);
job_mgr.c:		pack8(dump_job_ptr->reboot,        buffer);
job_mgr.c:		pack16(dump_job_ptr->restart_cnt,  buffer);
job_mgr.c:		pack_time(dump_job_ptr->deadline, buffer);
job_mgr.c:		pack32(dump_job_ptr->alloc_sid, buffer);
job_mgr.c:		if ((dump_job_ptr->time_limit == NO_VAL)
job_mgr.c:		    && dump_job_ptr->part_ptr)
job_mgr.c:			time_limit = dump_job_ptr->part_ptr->max_time;
job_mgr.c:			time_limit = dump_job_ptr->time_limit;
job_mgr.c:		pack32(dump_job_ptr->time_min, buffer);
job_mgr.c:		if (dump_job_ptr->details) {
job_mgr.c:			pack32(dump_job_ptr->details->nice,  buffer);
job_mgr.c:			pack_time(dump_job_ptr->details->submit_time, buffer);
job_mgr.c:			begin_time = dump_job_ptr->details->begin_time;
job_mgr.c:			accrue_time = dump_job_ptr->details->accrue_time;
job_mgr.c:			start_time = dump_job_ptr->start_time;
job_mgr.c:			end_time = dump_job_ptr->end_time;
job_mgr.c:		} else if (dump_job_ptr->start_time != 0) {
job_mgr.c:			start_time = MAX(dump_job_ptr->start_time, time(NULL));
job_mgr.c:				end_time = MAX(dump_job_ptr->end_time,
job_mgr.c:				end_time = MAX(dump_job_ptr->end_time,
job_mgr.c:		pack_time(dump_job_ptr->suspend_time, buffer);
job_mgr.c:		pack_time(dump_job_ptr->pre_sus_time, buffer);
job_mgr.c:		pack_time(dump_job_ptr->resize_time, buffer);
job_mgr.c:		pack_time(dump_job_ptr->last_sched_eval, buffer);
job_mgr.c:		pack_time(dump_job_ptr->preempt_time, buffer);
job_mgr.c:		pack32(dump_job_ptr->priority, buffer);
job_mgr.c:		packdouble(dump_job_ptr->billable_tres, buffer);
job_mgr.c:			packstr(dump_job_ptr->nodes, buffer);
job_mgr.c:				bitmap2node_name(dump_job_ptr->node_bitmap_cg);
job_mgr.c:		packstr(dump_job_ptr->sched_nodes, buffer);
job_mgr.c:		if (!IS_JOB_PENDING(dump_job_ptr) && dump_job_ptr->part_ptr)
job_mgr.c:			packstr(dump_job_ptr->part_ptr->name, buffer);
job_mgr.c:			packstr(dump_job_ptr->partition, buffer);
job_mgr.c:		packstr(dump_job_ptr->account, buffer);
job_mgr.c:		packstr(dump_job_ptr->admin_comment, buffer);
job_mgr.c:		packstr(dump_job_ptr->network, buffer);
job_mgr.c:		packstr(dump_job_ptr->comment, buffer);
job_mgr.c:		packstr(dump_job_ptr->batch_features, buffer);
job_mgr.c:		packstr(dump_job_ptr->batch_host, buffer);
job_mgr.c:		packstr(dump_job_ptr->burst_buffer, buffer);
job_mgr.c:		packstr(dump_job_ptr->burst_buffer_state, buffer);
job_mgr.c:		packstr(dump_job_ptr->system_comment, buffer);
job_mgr.c:		if (dump_job_ptr->qos_ptr)
job_mgr.c:			packstr(dump_job_ptr->qos_ptr->name, buffer);
job_mgr.c:							dump_job_ptr->qos_id),
job_mgr.c:		packstr(dump_job_ptr->licenses, buffer);
job_mgr.c:		packstr(dump_job_ptr->state_desc, buffer);
job_mgr.c:		packstr(dump_job_ptr->resv_name, buffer);
job_mgr.c:		packstr(dump_job_ptr->mcs_label, buffer);
job_mgr.c:		pack32(dump_job_ptr->exit_code, buffer);
job_mgr.c:		pack32(dump_job_ptr->derived_ec, buffer);
job_mgr.c:			pack_job_resources(dump_job_ptr->job_resrcs, buffer,
job_mgr.c:		packstr(dump_job_ptr->name, buffer);
job_mgr.c:		packstr(dump_job_ptr->user_name, buffer);
job_mgr.c:		packstr(dump_job_ptr->wckey, buffer);
job_mgr.c:		pack32(dump_job_ptr->req_switch, buffer);
job_mgr.c:		pack32(dump_job_ptr->wait4switch, buffer);
job_mgr.c:		packstr(dump_job_ptr->alloc_node, buffer);
job_mgr.c:			pack_bit_str_hex(dump_job_ptr->node_bitmap, buffer);
job_mgr.c:			pack_bit_str_hex(dump_job_ptr->node_bitmap_cg, buffer);
job_mgr.c:		select_g_select_jobinfo_pack(dump_job_ptr->select_jobinfo,
job_mgr.c:		pack32(dump_job_ptr->bit_flags, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_fmt_alloc_str, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_fmt_req_str, buffer);
job_mgr.c:		pack16(dump_job_ptr->start_protocol_ver, buffer);
job_mgr.c:		if (dump_job_ptr->fed_details) {
job_mgr.c:			packstr(dump_job_ptr->fed_details->origin_str, buffer);
job_mgr.c:			pack64(dump_job_ptr->fed_details->siblings_active,
job_mgr.c:			packstr(dump_job_ptr->fed_details->siblings_active_str,
job_mgr.c:			pack64(dump_job_ptr->fed_details->siblings_viable,
job_mgr.c:			packstr(dump_job_ptr->fed_details->siblings_viable_str,
job_mgr.c:		packstr(dump_job_ptr->cpus_per_tres, buffer);
job_mgr.c:		packstr(dump_job_ptr->mem_per_tres, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_bind, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_freq, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_per_job, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_per_node, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_per_socket, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_per_task, buffer);
job_mgr.c:		detail_ptr = dump_job_ptr->details;
job_mgr.c:		pack32(dump_job_ptr->array_job_id, buffer);
job_mgr.c:		pack32(dump_job_ptr->array_task_id, buffer);
job_mgr.c:		if (dump_job_ptr->array_recs) {
job_mgr.c:			packstr(dump_job_ptr->array_recs->task_id_str, buffer);
job_mgr.c:			pack32(dump_job_ptr->array_recs->max_run_tasks, buffer);
job_mgr.c:		pack32(dump_job_ptr->assoc_id, buffer);
job_mgr.c:		pack32(dump_job_ptr->delay_boot, buffer);
job_mgr.c:		pack32(dump_job_ptr->job_id,   buffer);
job_mgr.c:		pack32(dump_job_ptr->user_id,  buffer);
job_mgr.c:		pack32(dump_job_ptr->group_id, buffer);
job_mgr.c:		pack32(dump_job_ptr->pack_job_id, buffer);
job_mgr.c:		packstr(dump_job_ptr->pack_job_id_set, buffer);
job_mgr.c:		pack32(dump_job_ptr->pack_job_offset, buffer);
job_mgr.c:		pack32(dump_job_ptr->profile,  buffer);
job_mgr.c:		pack32(dump_job_ptr->job_state,    buffer);
job_mgr.c:		pack16(dump_job_ptr->batch_flag,   buffer);
job_mgr.c:		if ((dump_job_ptr->state_reason == WAIT_NO_REASON) &&
job_mgr.c:			pack16(dump_job_ptr->state_reason_prev, buffer);
job_mgr.c:			pack16(dump_job_ptr->state_reason, buffer);
job_mgr.c:		pack8(dump_job_ptr->power_flags,   buffer);
job_mgr.c:		pack8(dump_job_ptr->reboot,        buffer);
job_mgr.c:		pack16(dump_job_ptr->restart_cnt,  buffer);
job_mgr.c:		pack_time(dump_job_ptr->deadline, buffer);
job_mgr.c:		pack32(dump_job_ptr->alloc_sid, buffer);
job_mgr.c:		if ((dump_job_ptr->time_limit == NO_VAL)
job_mgr.c:		    && dump_job_ptr->part_ptr)
job_mgr.c:			time_limit = dump_job_ptr->part_ptr->max_time;
job_mgr.c:			time_limit = dump_job_ptr->time_limit;
job_mgr.c:		pack32(dump_job_ptr->time_min, buffer);
job_mgr.c:		if (dump_job_ptr->details) {
job_mgr.c:			pack32(dump_job_ptr->details->nice,  buffer);
job_mgr.c:			pack_time(dump_job_ptr->details->submit_time, buffer);
job_mgr.c:			begin_time = dump_job_ptr->details->begin_time;
job_mgr.c:			start_time = dump_job_ptr->start_time;
job_mgr.c:			end_time = dump_job_ptr->end_time;
job_mgr.c:		} else if (dump_job_ptr->start_time != 0) {
job_mgr.c:			start_time = MAX(dump_job_ptr->start_time, time(NULL));
job_mgr.c:				end_time = MAX(dump_job_ptr->end_time,
job_mgr.c:				end_time = MAX(dump_job_ptr->end_time,
job_mgr.c:		pack_time(dump_job_ptr->suspend_time, buffer);
job_mgr.c:		pack_time(dump_job_ptr->pre_sus_time, buffer);
job_mgr.c:		pack_time(dump_job_ptr->resize_time, buffer);
job_mgr.c:		pack_time(dump_job_ptr->last_sched_eval, buffer);
job_mgr.c:		pack_time(dump_job_ptr->preempt_time, buffer);
job_mgr.c:		pack32(dump_job_ptr->priority, buffer);
job_mgr.c:		packdouble(dump_job_ptr->billable_tres, buffer);
job_mgr.c:			packstr(dump_job_ptr->nodes, buffer);
job_mgr.c:				bitmap2node_name(dump_job_ptr->node_bitmap_cg);
job_mgr.c:		packstr(dump_job_ptr->sched_nodes, buffer);
job_mgr.c:		if (!IS_JOB_PENDING(dump_job_ptr) && dump_job_ptr->part_ptr)
job_mgr.c:			packstr(dump_job_ptr->part_ptr->name, buffer);
job_mgr.c:			packstr(dump_job_ptr->partition, buffer);
job_mgr.c:		packstr(dump_job_ptr->account, buffer);
job_mgr.c:		packstr(dump_job_ptr->admin_comment, buffer);
job_mgr.c:		packstr(dump_job_ptr->network, buffer);
job_mgr.c:		packstr(dump_job_ptr->comment, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_per_node, buffer);
job_mgr.c:		packstr(dump_job_ptr->batch_host, buffer);
job_mgr.c:		packstr(dump_job_ptr->burst_buffer, buffer);
job_mgr.c:		packstr(dump_job_ptr->burst_buffer_state, buffer);
job_mgr.c:		if (dump_job_ptr->qos_ptr)
job_mgr.c:			packstr(dump_job_ptr->qos_ptr->name, buffer);
job_mgr.c:							dump_job_ptr->qos_id),
job_mgr.c:		packstr(dump_job_ptr->licenses, buffer);
job_mgr.c:		packstr(dump_job_ptr->state_desc, buffer);
job_mgr.c:		packstr(dump_job_ptr->resv_name, buffer);
job_mgr.c:		packstr(dump_job_ptr->mcs_label, buffer);
job_mgr.c:		pack32(dump_job_ptr->exit_code, buffer);
job_mgr.c:		pack32(dump_job_ptr->derived_ec, buffer);
job_mgr.c:			pack_job_resources(dump_job_ptr->job_resrcs, buffer,
job_mgr.c:		packstr(dump_job_ptr->name, buffer);
job_mgr.c:		packstr(dump_job_ptr->user_name, buffer);
job_mgr.c:		packstr(dump_job_ptr->wckey, buffer);
job_mgr.c:		pack32(dump_job_ptr->req_switch, buffer);
job_mgr.c:		pack32(dump_job_ptr->wait4switch, buffer);
job_mgr.c:		packstr(dump_job_ptr->alloc_node, buffer);
job_mgr.c:			pack_bit_str_hex(dump_job_ptr->node_bitmap, buffer);
job_mgr.c:			pack_bit_str_hex(dump_job_ptr->node_bitmap_cg, buffer);
job_mgr.c:		select_g_select_jobinfo_pack(dump_job_ptr->select_jobinfo,
job_mgr.c:		pack32(dump_job_ptr->bit_flags, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_fmt_alloc_str, buffer);
job_mgr.c:		packstr(dump_job_ptr->tres_fmt_req_str, buffer);
job_mgr.c:		pack16(dump_job_ptr->start_protocol_ver, buffer);
job_mgr.c:		if (dump_job_ptr->fed_details) {
job_mgr.c:			packstr(dump_job_ptr->fed_details->origin_str, buffer);
job_mgr.c:			pack64(dump_job_ptr->fed_details->siblings_active,
job_mgr.c:			packstr(dump_job_ptr->fed_details->siblings_active_str,
job_mgr.c:			pack64(dump_job_ptr->fed_details->siblings_viable,
job_mgr.c:			packstr(dump_job_ptr->fed_details->siblings_viable_str,
job_mgr.c:	struct job_details *detail_ptr = job_ptr->details;
job_mgr.c:	else if (job_ptr->part_ptr) {
job_mgr.c:		if (job_ptr->part_ptr->flags & PART_FLAG_EXCLUSIVE_USER)
job_mgr.c:		else if ((job_ptr->part_ptr->max_share & SHARED_FORCE) &&
job_mgr.c:			 ((job_ptr->part_ptr->max_share & (~SHARED_FORCE)) > 1))
job_mgr.c:		else if (job_ptr->part_ptr->max_share == 0)
job_mgr.c:	if (job_ptr->part_ptr && job_ptr->part_ptr->max_cpu_cnt) {
job_mgr.c:		max_cpu_cnt  = job_ptr->part_ptr->max_cpu_cnt;
job_mgr.c:		max_core_cnt = job_ptr->part_ptr->max_core_cnt;
job_mgr.c:			if (IS_JOB_COMPLETING(job_ptr) && job_ptr->cpu_cnt) {
job_mgr.c:				pack32(job_ptr->cpu_cnt, buffer);
job_mgr.c:			} else if (job_ptr->total_cpus &&
job_mgr.c:				pack32(job_ptr->total_cpus, buffer);
job_mgr.c:			if (IS_JOB_COMPLETING(job_ptr) && job_ptr->node_cnt) {
job_mgr.c:				pack32(job_ptr->node_cnt, buffer);
job_mgr.c:			} else if (job_ptr->total_nodes) {
job_mgr.c:				pack32(job_ptr->total_nodes, buffer);
job_mgr.c:			} else if (job_ptr->node_cnt_wag) {
job_mgr.c:				pack32(job_ptr->node_cnt_wag, buffer);
job_mgr.c:				pack32(job_ptr->node_cnt, buffer);
job_mgr.c:			if (job_ptr->total_cpus)
job_mgr.c:				pack32(job_ptr->total_cpus, buffer);
job_mgr.c:				pack32(job_ptr->cpu_cnt, buffer);
job_mgr.c:			pack32(job_ptr->node_cnt, buffer);
job_mgr.c:	if (job_ptr->pack_job_id == job_filter->pack_job_id)
job_mgr.c:			if (job_ptr->bit_flags & KILL_INV_DEP) {
job_mgr.c:			} else if (job_ptr->bit_flags & NO_KILL_INV_DEP) {
job_mgr.c:				job_ptr->state_reason = WAIT_DEP_INVALID;
job_mgr.c:				xfree(job_ptr->state_desc);
job_mgr.c:				job_ptr->state_reason = WAIT_DEP_INVALID;
job_mgr.c:				xfree(job_ptr->state_desc);
job_mgr.c:		if (job_ptr->state_reason == WAIT_DEP_INVALID) {
job_mgr.c:			if (job_ptr->bit_flags & KILL_INV_DEP) {
job_mgr.c:			} else if (job_ptr->bit_flags & NO_KILL_INV_DEP) {
job_mgr.c:		xassert (job_ptr->magic == JOB_MAGIC);
job_mgr.c:		if (job_ptr->partition == NULL) {
job_mgr.c:			part_ptr = find_part_record(job_ptr->partition);
job_mgr.c:						job_ptr->partition,
job_mgr.c:		job_ptr->part_ptr = part_ptr;
job_mgr.c:		FREE_NULL_LIST(job_ptr->part_ptr_list);
job_mgr.c:			job_ptr->part_ptr_list = part_ptr_list;
job_mgr.c:		FREE_NULL_BITMAP(job_ptr->node_bitmap_cg);
job_mgr.c:		if (job_ptr->nodes_completing &&
job_mgr.c:		    node_name2bitmap(job_ptr->nodes_completing,
job_mgr.c:				     false,  &job_ptr->node_bitmap_cg)) {
job_mgr.c:			      job_ptr->nodes_completing, job_ptr);
job_mgr.c:		FREE_NULL_BITMAP(job_ptr->node_bitmap);
job_mgr.c:		if (job_ptr->nodes &&
job_mgr.c:		    node_name2bitmap(job_ptr->nodes, false,
job_mgr.c:				     &job_ptr->node_bitmap) && !job_fail) {
job_mgr.c:			      job_ptr->nodes, job_ptr);
job_mgr.c:		    job_ptr->job_resrcs && (cr_flag || gang_flag) &&
job_mgr.c:		    valid_job_resources(job_ptr->job_resrcs,
job_mgr.c:		    gres_plugin_job_revalidate(job_ptr->gres_list)) {
job_mgr.c:		if (!job_fail && job_ptr->job_resrcs &&
job_mgr.c:		    gres_plugin_job_revalidate2(job_ptr->job_id,
job_mgr.c:					job_ptr->gres_list,
job_mgr.c:					job_ptr->job_resrcs->node_bitmap)) {
job_mgr.c:				job_ptr->start_time =
job_mgr.c:					job_ptr->end_time = time(NULL);
job_mgr.c:				job_ptr->job_state = JOB_NODE_FAIL;
job_mgr.c:				job_ptr->end_time = time(NULL);
job_mgr.c:				job_ptr->job_state = JOB_NODE_FAIL |
job_mgr.c:				job_ptr->end_time = job_ptr->suspend_time;
job_mgr.c:				job_ptr->job_state = JOB_NODE_FAIL |
job_mgr.c:				job_ptr->tot_sus_time +=
job_mgr.c:					difftime(now, job_ptr->suspend_time);
job_mgr.c:			job_ptr->state_reason = FAIL_DOWN_NODE;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:			if (job_ptr->job_state == JOB_NODE_FAIL) {
job_mgr.c:	if (job_ptr->details == NULL)
job_mgr.c:	FREE_NULL_BITMAP(job_ptr->details->req_node_bitmap);
job_mgr.c:	if ((job_ptr->details->req_nodes) &&
job_mgr.c:	    (node_name2bitmap(job_ptr->details->req_nodes, false,
job_mgr.c:			      &job_ptr->details->req_node_bitmap))) {
job_mgr.c:		      job_ptr->details->req_nodes, job_ptr);
job_mgr.c:	FREE_NULL_BITMAP(job_ptr->details->exc_node_bitmap);
job_mgr.c:	if ((job_ptr->details->exc_nodes) &&
job_mgr.c:	    (node_name2bitmap(job_ptr->details->exc_nodes, true,
job_mgr.c:			      &job_ptr->details->exc_node_bitmap))) {
job_mgr.c:		      job_ptr->details->exc_nodes, job_ptr);
job_mgr.c:	step_iterator = list_iterator_create (job_ptr->step_list);
job_mgr.c:	xassert (job_ptr->magic == JOB_MAGIC);
job_mgr.c:		job_ptr->job_id = new_id;
job_mgr.c:		job_ptr->db_index = 0;
job_mgr.c:	job_ptr->job_id = NO_VAL;
job_mgr.c:	xassert (job_ptr->magic == JOB_MAGIC);
job_mgr.c:	job_ptr->priority = slurm_sched_g_initial_priority(lowest_prio,
job_mgr.c:	if ((job_ptr->priority == 0) || (job_ptr->direct_set_prio))
job_mgr.c:	relative_prio = job_ptr->priority;
job_mgr.c:	if (job_ptr->details && (job_ptr->details->nice != NICE_OFFSET)) {
job_mgr.c:		int64_t offset = job_ptr->details->nice;
job_mgr.c:		if ((job_ptr->priority) && (job_ptr->direct_set_prio == 0))
job_mgr.c:			job_ptr->priority += prio_boost;
job_mgr.c:	struct job_details *detail_ptr = job_ptr->details;
job_mgr.c:	if (job_ptr->priority == 0)	/* user held */
job_mgr.c:			if ((pack_job_offset != NO_VAL) && (job_ptr->job_id ==
job_mgr.c:			if ((job_ptr2->resv_name && (!job_ptr->resv_name)) ||
job_mgr.c:			    ((!job_ptr2->resv_name) && job_ptr->resv_name))
job_mgr.c:			if (job_ptr2->resv_name && job_ptr->resv_name &&
job_mgr.c:				      job_ptr->resv_name))) {
job_mgr.c:				if (job_ptr2->priority <= job_ptr->priority)
job_mgr.c:			if (job_ptr2->part_ptr == job_ptr->part_ptr) {
job_mgr.c:				if (job_ptr2->priority <= job_ptr->priority)
job_mgr.c:			if (bit_overlap(job_ptr->part_ptr->node_bitmap,
job_mgr.c:			     (job_ptr2->priority >  job_ptr->priority))) {
job_mgr.c:		if (job_ptr->priority == 0) {		/* user/admin hold */
job_mgr.c:			if (job_ptr->state_reason != FAIL_BAD_CONSTRAINTS
job_mgr.c:			    && (job_ptr->state_reason != WAIT_RESV_DELETED)
job_mgr.c:			    && (job_ptr->state_reason != FAIL_BURST_BUFFER_OP)
job_mgr.c:			    && (job_ptr->state_reason != FAIL_ACCOUNT)
job_mgr.c:			    && (job_ptr->state_reason != FAIL_QOS)
job_mgr.c:			    && (job_ptr->state_reason != WAIT_HELD)
job_mgr.c:			    && (job_ptr->state_reason != WAIT_HELD_USER)
job_mgr.c:			    && job_ptr->state_reason != WAIT_MAX_REQUEUE) {
job_mgr.c:				job_ptr->state_reason = WAIT_HELD;
job_mgr.c:				xfree(job_ptr->state_desc);
job_mgr.c:		} else if (job_ptr->state_reason == WAIT_NO_REASON &&
job_mgr.c:			job_ptr->state_reason = WAIT_PRIORITY;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:	if (!shrink_job_ptr->licenses)		/* No licenses to add */
job_mgr.c:	if (!expand_job_ptr->licenses) {	/* Just transfer licenses */
job_mgr.c:		expand_job_ptr->licenses = shrink_job_ptr->licenses;
job_mgr.c:		shrink_job_ptr->licenses = NULL;
job_mgr.c:		FREE_NULL_LIST(expand_job_ptr->license_list);
job_mgr.c:		expand_job_ptr->license_list = shrink_job_ptr->license_list;
job_mgr.c:		shrink_job_ptr->license_list = NULL;
job_mgr.c:	xstrcat(expand_job_ptr->licenses, ",");
job_mgr.c:	xstrcat(expand_job_ptr->licenses, shrink_job_ptr->licenses);
job_mgr.c:	xfree(shrink_job_ptr->licenses);
job_mgr.c:	FREE_NULL_LIST(expand_job_ptr->license_list);
job_mgr.c:	FREE_NULL_LIST(shrink_job_ptr->license_list);
job_mgr.c:	job_ptr->direct_set_prio = 1;
job_mgr.c:	job_ptr->priority = 0;
job_mgr.c:	if (job_ptr->part_ptr_list && job_ptr->priority_array) {
job_mgr.c:		j = list_count(job_ptr->part_ptr_list);
job_mgr.c:			job_ptr->priority_array[i] = 0;
job_mgr.c:	if (job_ptr->pack_job_id && _get_whole_hetjob())
job_mgr.c:		pack_leader = find_job_record(job_ptr->pack_job_id);
job_mgr.c:	job_ptr->direct_set_prio = 0;
job_mgr.c:	job_ptr->state_reason = WAIT_NO_REASON;
job_mgr.c:	job_ptr->state_reason_prev = WAIT_NO_REASON;
job_mgr.c:	job_ptr->job_state &= ~JOB_SPECIAL_EXIT;
job_mgr.c:	xfree(job_ptr->state_desc);
job_mgr.c:	job_ptr->exit_code = 0;
job_mgr.c:	if (job_ptr->pack_job_id && _get_whole_hetjob())
job_mgr.c:		pack_leader = find_job_record(job_ptr->pack_job_id);
job_mgr.c:	} else if (job_ptr->part_ptr)
job_mgr.c:		assoc_rec.partition = job_ptr->part_ptr->name;
job_mgr.c:		assoc_rec.acct = job_ptr->account;
job_mgr.c:	assoc_rec.uid = job_ptr->user_id;
job_mgr.c:	if (!job_ptr->job_resrcs || !job_ptr->job_resrcs->node_bitmap)
job_mgr.c:	i_first = bit_ffs(job_ptr->job_resrcs->node_bitmap);
job_mgr.c:		i_last = bit_fls(job_ptr->job_resrcs->node_bitmap);
job_mgr.c:		if (!bit_test(job_ptr->job_resrcs->node_bitmap, i) ||
job_mgr.c:	if (job_ptr->db_index == NO_VAL64)
job_mgr.c:			xfree(job_ptr->burst_buffer);
job_mgr.c:	if (job_specs->array_inx && job_ptr->array_recs) {
job_mgr.c:			job_ptr->array_recs->max_run_tasks = throttle;
job_mgr.c:		job_specs->user_id = job_ptr->user_id;
job_mgr.c:							     job_ptr->account);
job_mgr.c:	if ((job_ptr->user_id != uid) && !operator) {
job_mgr.c:	detail_ptr = job_ptr->details;
job_mgr.c:	memcpy(tres_req_cnt, job_ptr->tres_req_cnt, sizeof(tres_req_cnt));
job_mgr.c:		if (!acct_policy_validate(job_specs, job_ptr->part_ptr,
job_mgr.c:					  job_ptr->assoc_ptr, job_ptr->qos_ptr,
job_mgr.c:	    !xstrcmp(job_specs->partition, job_ptr->partition)) {
job_mgr.c:			 !xstrcmp(new_part_ptr->name, job_ptr->partition)) {
job_mgr.c:	use_part_ptr = new_part_ptr ? new_part_ptr : job_ptr->part_ptr;
job_mgr.c:			else if (new_assoc_ptr == job_ptr->assoc_ptr) {
job_mgr.c:					    __func__, job_ptr->job_id);
job_mgr.c:	use_assoc_ptr = new_assoc_ptr ?	new_assoc_ptr : job_ptr->assoc_ptr;
job_mgr.c:			resv_name = job_ptr->resv_name;
job_mgr.c:			if (job_ptr->qos_ptr == new_qos_ptr) {
job_mgr.c:	use_qos_ptr = new_qos_ptr ? new_qos_ptr : job_ptr->qos_ptr;
job_mgr.c:	 * Must check req_nodes to set the job_ptr->details->req_node_bitmap
job_mgr.c:		    !bit_super_set(new_req_bitmap, job_ptr->node_bitmap) ||
job_mgr.c:		    (job_ptr->details && job_ptr->details->expanding_jobid)) {
job_mgr.c:			i_first = bit_ffs(job_ptr->node_bitmap);
job_mgr.c:				i_last  = bit_fls(job_ptr->node_bitmap);
job_mgr.c:			rem_nodes = bit_alloc(bit_size(job_ptr->node_bitmap));
job_mgr.c:				    !bit_test(job_ptr->node_bitmap, i))
job_mgr.c:			gres_build_job_details(job_ptr->gres_list,
job_mgr.c:					       &job_ptr->gres_detail_cnt,
job_mgr.c:					       &job_ptr->gres_detail_str);
job_mgr.c:	    && (!xstrcmp(job_specs->reservation, job_ptr->resv_name) ||
job_mgr.c:		(!job_ptr->resv_name && job_specs->reservation[0] == '\0'))) {
job_mgr.c:		gres_list = gres_plugin_job_state_dup(job_ptr->gres_list);
job_mgr.c:			job_ptr->tres_req_cnt[TRES_ARRAY_CPU];
job_mgr.c:			license_set_job_tres_cnt(job_ptr->license_list,
job_mgr.c:		job_ptr->tres_req_cnt[TRES_ARRAY_CPU],
job_mgr.c:					    job_ptr->licenses)) {
job_mgr.c:			    __func__, job_ptr->licenses);
job_mgr.c:	    (job_specs->min_nodes > job_ptr->node_cnt) &&
job_mgr.c:		job_ptr->req_switch = job_specs->req_switch;
job_mgr.c:		job_ptr->wait4switch = _max_switch_wait(job_specs->wait4switch);
job_mgr.c:		     __func__, job_ptr->wait4switch, job_ptr);
job_mgr.c:			xfree(job_ptr->admin_comment);
job_mgr.c:			job_ptr->admin_comment =
job_mgr.c:			     __func__, job_ptr->admin_comment, job_ptr);
job_mgr.c:		xfree(job_ptr->comment);
job_mgr.c:		job_ptr->comment = xstrdup(job_specs->comment);
job_mgr.c:		     __func__, job_ptr->comment, job_ptr);
job_mgr.c:			    (job_ptr->time_min != 0)) {
job_mgr.c:				job_specs->time_min = job_ptr->time_min;
job_mgr.c:				job_specs->time_limit = job_ptr->time_limit;
job_mgr.c:				job_specs->reservation = job_ptr->resv_name;
job_mgr.c:				     job_ptr->details->req_node_bitmap,
job_mgr.c:				     part_ptr_list : job_ptr->part_ptr_list,
job_mgr.c:		job_ptr->qos_id = new_qos_ptr->id;
job_mgr.c:		job_ptr->qos_ptr = new_qos_ptr;
job_mgr.c:		job_ptr->limit_set.qos = acct_policy_limit_set.qos;
job_mgr.c:		if (job_ptr->state_reason == FAIL_QOS) {
job_mgr.c:			job_ptr->state_reason = WAIT_NO_REASON;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:		xfree(job_ptr->account);
job_mgr.c:		job_ptr->account = xstrdup(new_assoc_ptr->acct);
job_mgr.c:		job_ptr->assoc_id = new_assoc_ptr->id;
job_mgr.c:		job_ptr->assoc_ptr = new_assoc_ptr;
job_mgr.c:		if (job_ptr->state_reason == FAIL_ACCOUNT) {
job_mgr.c:			job_ptr->state_reason = WAIT_NO_REASON;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:		     __func__, job_ptr->account, job_ptr);
job_mgr.c:		job_ptr->part_ptr = new_part_ptr;
job_mgr.c:		FREE_NULL_LIST(job_ptr->part_ptr_list);
job_mgr.c:		job_ptr->part_ptr_list = part_ptr_list;
job_mgr.c:		xfree(job_ptr->priority_array);
job_mgr.c:		job_ptr->resv_name = xstrdup(new_resv_ptr->name);
job_mgr.c:		job_ptr->resv_ptr = new_resv_ptr;
job_mgr.c:			   job_ptr->resv_name, job_ptr);
job_mgr.c:		   job_ptr->resv_name) {
job_mgr.c:		xfree(job_ptr->resv_name);
job_mgr.c:		job_ptr->resv_id    = 0;
job_mgr.c:		job_ptr->resv_ptr   = NULL;
job_mgr.c:		job_ptr->limit_set.tres[TRES_ARRAY_CPU] =
job_mgr.c:		job_ptr->limit_set.tres[TRES_ARRAY_CPU] =
job_mgr.c:		job_ptr->limit_set.tres[TRES_ARRAY_NODE] =
job_mgr.c:		job_ptr->limit_set.tres[TRES_ARRAY_NODE] =
job_mgr.c:		if (IS_JOB_FINISHED(job_ptr) || job_ptr->preempt_time)
job_mgr.c:		else if (job_ptr->time_limit == job_specs->time_limit) {
job_mgr.c:			   (job_ptr->time_limit > job_specs->time_limit)) {
job_mgr.c:			time_t old_time =  job_ptr->time_limit;
job_mgr.c:			job_ptr->time_limit = job_specs->time_limit;
job_mgr.c:				if (job_ptr->preempt_time) {
job_mgr.c:				} else if (job_ptr->time_limit == INFINITE) {
job_mgr.c:					job_ptr->end_time = now +
job_mgr.c:					job_ptr->end_time = job_ptr->end_time +
job_mgr.c:						((job_ptr->time_limit -
job_mgr.c:				if (job_ptr->end_time < now)
job_mgr.c:					job_ptr->end_time = now;
job_mgr.c:				    (list_is_empty(job_ptr->step_list) == 0)) {
job_mgr.c:				job_ptr->end_time_exp = job_ptr->end_time;
job_mgr.c:			job_ptr->limit_set.time = acct_policy_limit_set.time;
job_mgr.c:		} else if (IS_JOB_PENDING(job_ptr) && job_ptr->part_ptr &&
job_mgr.c:			   (job_ptr->part_ptr->max_time >=
job_mgr.c:			job_ptr->time_limit = job_specs->time_limit;
job_mgr.c:			job_ptr->limit_set.time = acct_policy_limit_set.time;
job_mgr.c:		if (job_specs->time_min > job_ptr->time_limit) {
job_mgr.c:			     __func__, job_specs->time_min, job_ptr->time_limit);
job_mgr.c:		} else if (job_ptr->time_min != job_specs->time_min) {
job_mgr.c:			job_ptr->time_min = job_specs->time_min;
job_mgr.c:		if (!IS_JOB_RUNNING(job_ptr) || job_ptr->preempt_time) {
job_mgr.c:			   (job_ptr->end_time > job_specs->end_time)) {
job_mgr.c:			int delta_t  = job_specs->end_time - job_ptr->end_time;
job_mgr.c:			job_ptr->end_time = job_specs->end_time;
job_mgr.c:			job_ptr->time_limit += (delta_t+30)/60; /* Sec->min */
job_mgr.c:				   __func__, job_ptr->time_limit, job_ptr);
job_mgr.c:			job_ptr->limit_set.time = acct_policy_limit_set.time;
job_mgr.c:		slurm_make_time_str(&job_ptr->deadline, time_str,
job_mgr.c:			job_ptr->deadline = job_specs->deadline;
job_mgr.c:			job_ptr->limit_set.time = acct_policy_limit_set.time;
job_mgr.c:		job_ptr->delay_boot = job_specs->delay_boot;
job_mgr.c:		else if (job_ptr->priority == job_specs->priority) {
job_mgr.c:			if ((job_ptr->priority == 0) && operator) {
job_mgr.c:					job_ptr->state_reason = WAIT_HELD_USER;
job_mgr.c:					job_ptr->state_reason = WAIT_HELD;
job_mgr.c:		} else if ((job_ptr->priority == 0) &&
job_mgr.c:			    (job_ptr->state_reason == WAIT_RESV_DELETED) ||
job_mgr.c:			    (job_ptr->state_reason == WAIT_HELD_USER))) {
job_mgr.c:		} else if ((job_ptr->priority == 0) &&
job_mgr.c:			 (job_ptr->priority > job_specs->priority)) {
job_mgr.c:				job_ptr->details->nice = NICE_OFFSET;
job_mgr.c:				job_ptr->direct_set_prio = 0;
job_mgr.c:					job_ptr->direct_set_prio = 1;
job_mgr.c:				job_ptr->priority = job_specs->priority;
job_mgr.c:				if (job_ptr->part_ptr_list &&
job_mgr.c:				    job_ptr->priority_array) {
job_mgr.c:						job_ptr->part_ptr_list);
job_mgr.c:						job_ptr->priority_array[i] =
job_mgr.c:				   __func__, job_ptr->priority, job_ptr);
job_mgr.c:			if (job_ptr->priority == 0) {
job_mgr.c:					job_ptr->state_reason = WAIT_HELD_USER;
job_mgr.c:					job_ptr->state_reason = WAIT_HELD;
job_mgr.c:				xfree(job_ptr->state_desc);
job_mgr.c:		} else if ((job_ptr->priority != 0) &&
job_mgr.c:	} else if (job_ptr->state_reason == FAIL_BAD_CONSTRAINTS) {
job_mgr.c:		job_ptr->direct_set_prio = 0;
job_mgr.c:		job_ptr->state_reason = WAIT_NO_REASON;
job_mgr.c:		if (IS_JOB_FINISHED(job_ptr) || (job_ptr->details == NULL))
job_mgr.c:		else if (job_ptr->details &&
job_mgr.c:			 (job_ptr->details->nice == job_specs->nice))
job_mgr.c:		else if (job_ptr->direct_set_prio && job_ptr->priority != 0)
job_mgr.c:				int64_t new_prio = job_ptr->priority;
job_mgr.c:				new_prio += job_ptr->details->nice;
job_mgr.c:				job_ptr->priority = MAX(new_prio, 2);
job_mgr.c:					   __func__, job_ptr->details->nice,
job_mgr.c:					   job_ptr->priority, job_ptr);
job_mgr.c:			job_ptr->details->nice = job_specs->nice;
job_mgr.c:			job_ptr->bit_flags |= JOB_MEM_SET;
job_mgr.c:				   job_ptr->job_id);
job_mgr.c:			job_ptr->limit_set.tres[TRES_ARRAY_MEM] =
job_mgr.c:			xfree(job_ptr->cpus_per_tres);
job_mgr.c:			job_ptr->cpus_per_tres = job_specs->cpus_per_tres;
job_mgr.c:			xfree(job_ptr->tres_per_job);
job_mgr.c:			job_ptr->tres_per_job = job_specs->tres_per_job;
job_mgr.c:			xfree(job_ptr->tres_per_node);
job_mgr.c:			job_ptr->tres_per_node = job_specs->tres_per_node;
job_mgr.c:			xfree(job_ptr->tres_per_socket);
job_mgr.c:			job_ptr->tres_per_socket = job_specs->tres_per_socket;
job_mgr.c:			xfree(job_ptr->tres_per_task);
job_mgr.c:			job_ptr->tres_per_task = job_specs->tres_per_task;
job_mgr.c:			xfree(job_ptr->mem_per_tres);
job_mgr.c:			job_ptr->mem_per_tres = job_specs->mem_per_tres;
job_mgr.c:		FREE_NULL_LIST(job_ptr->gres_list);
job_mgr.c:		job_ptr->gres_list = gres_list;
job_mgr.c:		gres_build_job_details(job_ptr->gres_list,
job_mgr.c:				       &job_ptr->gres_detail_cnt,
job_mgr.c:				       &job_ptr->gres_detail_str);
job_mgr.c:		} else if (!xstrcmp(job_specs->name, job_ptr->name)) {
job_mgr.c:			xfree(job_ptr->name);
job_mgr.c:			job_ptr->name = xstrdup(job_specs->name);
job_mgr.c:				   __func__, job_ptr->name, job_ptr);
job_mgr.c:	    && !xstrcmp(job_specs->wckey, job_ptr->wckey)) {
job_mgr.c:		if ((job_specs->min_nodes == 0) && (job_ptr->node_cnt > 0) &&
job_mgr.c:		    job_ptr->details && job_ptr->details->expanding_jobid) {
job_mgr.c:			expand_job_ptr = find_job_record(job_ptr->details->
job_mgr.c:				     job_ptr->details->expanding_jobid);
job_mgr.c:			if ((job_ptr->step_list != NULL) &&
job_mgr.c:			    (list_count(job_ptr->step_list) != 0)) {
job_mgr.c:			xassert(job_ptr->job_resrcs);
job_mgr.c:			xassert(job_ptr->job_resrcs->node_bitmap);
job_mgr.c:			xassert(expand_job_ptr->job_resrcs->node_bitmap);
job_mgr.c:			orig_job_node_bitmap = bit_copy(job_ptr->node_bitmap);
job_mgr.c:			orig_jobx_node_bitmap = bit_copy(expand_job_ptr->
job_mgr.c:				FREE_NULL_BITMAP(job_ptr->node_bitmap);
job_mgr.c:				job_ptr->node_bitmap = orig_job_node_bitmap;
job_mgr.c:				bit_clear_all(job_ptr->node_bitmap);
job_mgr.c:				job_ptr->job_state &= JOB_STATE_FLAGS;
job_mgr.c:				job_ptr->job_state |= JOB_COMPLETE;
job_mgr.c:			   (job_specs->min_nodes > job_ptr->node_cnt) ||
job_mgr.c:			   job_ptr->details->expanding_jobid) {
job_mgr.c:		} else if (job_specs->min_nodes == job_ptr->node_cnt) {
job_mgr.c:			i_first = bit_ffs(job_ptr->node_bitmap);
job_mgr.c:				i_last  = bit_fls(job_ptr->node_bitmap);
job_mgr.c:			rem_nodes = bit_alloc(bit_size(job_ptr->node_bitmap));
job_mgr.c:				if (!bit_test(job_ptr->node_bitmap, i))
job_mgr.c:				   __func__, job_ptr->nodes, job_ptr);
job_mgr.c:		gres_build_job_details(job_ptr->gres_list,
job_mgr.c:				       &job_ptr->gres_detail_cnt,
job_mgr.c:				       &job_ptr->gres_detail_str);
job_mgr.c:		if ((!IS_JOB_PENDING(job_ptr)) || (job_ptr->details == NULL))
job_mgr.c:				job_ptr->bit_flags &= ~INVALID_DEPEND;
job_mgr.c:				job_ptr->details->orig_dependency =
job_mgr.c:					xstrdup(job_ptr->details->dependency);
job_mgr.c:					   job_ptr->details->dependency,
job_mgr.c:			FREE_NULL_LIST(job_ptr->license_list);
job_mgr.c:			job_ptr->license_list = license_list;
job_mgr.c:				   __func__, job_ptr->licenses,
job_mgr.c:			xfree(job_ptr->licenses);
job_mgr.c:			job_ptr->licenses = xstrdup(job_specs->licenses);
job_mgr.c:			FREE_NULL_LIST(job_ptr->license_list);
job_mgr.c:			job_ptr->license_list = license_list;
job_mgr.c:				   __func__, job_ptr->licenses,
job_mgr.c:			xfree(job_ptr->licenses);
job_mgr.c:			job_ptr->licenses = xstrdup(job_specs->licenses);
job_mgr.c:			if ((job_ptr->state_reason != WAIT_HELD) &&
job_mgr.c:			    (job_ptr->state_reason != WAIT_HELD_USER) &&
job_mgr.c:			    (job_ptr->state_reason != WAIT_RESV_DELETED)) {
job_mgr.c:				job_ptr->state_reason = fail_reason;
job_mgr.c:				xfree(job_ptr->state_desc);
job_mgr.c:	} else if ((job_ptr->state_reason != WAIT_HELD)
job_mgr.c:		   && (job_ptr->state_reason != WAIT_HELD_USER)
job_mgr.c:		   && (job_ptr->state_reason != WAIT_RESV_DELETED)
job_mgr.c:		   && (job_ptr->state_reason != WAIT_MAX_REQUEUE)) {
job_mgr.c:		job_ptr->state_reason = WAIT_NO_REASON;
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:				job_ptr->reboot = 0;
job_mgr.c:				job_ptr->reboot = MAX(1, job_specs->reboot);
job_mgr.c:					   job_ptr->network)) {
job_mgr.c:			    __func__, job_ptr->network);
job_mgr.c:		xfree(job_ptr->network);
job_mgr.c:			job_ptr->network = xstrdup(job_specs->network);
job_mgr.c:				   __func__, job_ptr->network, job_ptr);
job_mgr.c:				job_ptr->select_jobinfo,
job_mgr.c:				job_ptr->network);
job_mgr.c:		if (!job_ptr->fed_details) {
job_mgr.c:		     __func__, job_ptr->fed_details->siblings_viable,
job_mgr.c:		job_ptr->fed_details->siblings_viable =
job_mgr.c:		xfree(job_ptr->cpus_per_tres);
job_mgr.c:			job_ptr->cpus_per_tres =
job_mgr.c:				   __func__, job_ptr->cpus_per_tres, job_ptr);
job_mgr.c:		xfree(job_ptr->mem_per_tres);
job_mgr.c:			job_ptr->mem_per_tres =
job_mgr.c:				   __func__, job_ptr->mem_per_tres, job_ptr);
job_mgr.c:		xfree(job_ptr->tres_bind);
job_mgr.c:			job_ptr->tres_bind = xstrdup(job_specs->tres_bind);
job_mgr.c:				   __func__, job_ptr->tres_bind, job_ptr);
job_mgr.c:		xfree(job_ptr->tres_freq);
job_mgr.c:			job_ptr->tres_freq = xstrdup(job_specs->tres_freq);
job_mgr.c:				   __func__, job_ptr->tres_freq, job_ptr);
job_mgr.c:		xfree(job_ptr->tres_per_job);
job_mgr.c:			job_ptr->tres_per_job =
job_mgr.c:				   __func__, job_ptr->tres_per_job, job_ptr);
job_mgr.c:		xfree(job_ptr->tres_per_node);
job_mgr.c:			job_ptr->tres_per_node =
job_mgr.c:				   __func__, job_ptr->tres_per_node, job_ptr);
job_mgr.c:		xfree(job_ptr->tres_per_socket);
job_mgr.c:			job_ptr->tres_per_socket =
job_mgr.c:				   __func__, job_ptr->tres_per_socket, job_ptr);
job_mgr.c:		xfree(job_ptr->tres_per_task);
job_mgr.c:			job_ptr->tres_per_task =
job_mgr.c:				   __func__, job_ptr->tres_per_task, job_ptr);
job_mgr.c:		job_ptr->site_factor = job_specs->site_factor;
job_mgr.c:			     job_ptr->tres_req_cnt[tres_pos]))
job_mgr.c:			job_ptr->tres_req_cnt[tres_pos] =
job_mgr.c:			job_ptr->tres_req_cnt[TRES_ARRAY_BILLING] =
job_mgr.c:					job_ptr->tres_req_cnt,
job_mgr.c:					job_ptr->part_ptr->billing_weights,
job_mgr.c:	if ((job_ptr->priority != 0) &&
job_mgr.c:	    job_ptr->fed_details && fed_mgr_is_origin_job(job_ptr)) {
job_mgr.c:			job_ptr->fed_details->siblings_viable;
job_mgr.c:		fed_mgr_update_job(job_ptr->job_id, job_specs,
job_mgr.c:				   job_ptr->fed_details->siblings_active, uid);
job_mgr.c:		if (job_ptr && job_ptr->pack_job_list) {
job_mgr.c:			iter = list_iterator_create(job_ptr->pack_job_list);
job_mgr.c:				if (job_ptr->pack_job_id !=
job_mgr.c:		    (((job_ptr->array_task_id == NO_VAL) &&
job_mgr.c:		      (job_ptr->array_recs == NULL)) ||
job_mgr.c:		     ((job_ptr->array_task_id != NO_VAL) &&
job_mgr.c:		      (job_ptr->array_job_id  != job_id)))) {
job_mgr.c:		if (job_ptr && job_ptr->array_recs) {
job_mgr.c:			if ((job_ptr->array_job_id == job_id) &&
job_mgr.c:			job_ptr = job_ptr->job_array_next_j;
job_mgr.c:	    job_ptr->array_recs && job_ptr->array_recs->task_id_bitmap) {
job_mgr.c:		len = bit_size(job_ptr->array_recs->task_id_bitmap);
job_mgr.c:			job_ptr->array_recs->task_id_bitmap = bit_realloc(
job_mgr.c:				job_ptr->array_recs->task_id_bitmap, i_last);
job_mgr.c:		if (!bit_overlap(job_ptr->array_recs->task_id_bitmap,
job_mgr.c:		} else if (bit_super_set(job_ptr->array_recs->task_id_bitmap,
job_mgr.c:				    job_ptr->array_recs->task_id_bitmap);
job_mgr.c:			tmp_bitmap = bit_copy(job_ptr->array_recs->
job_mgr.c:				job_ptr->array_task_id = i;
job_mgr.c:	xassert(job_ptr->details);
job_mgr.c:		gres_plugin_epilog_build_env(job_ptr->gres_list,job_ptr->nodes);
job_mgr.c:	kill_job->job_id    = job_ptr->job_id;
job_mgr.c:	kill_job->pack_jobid = job_ptr->pack_job_id;
job_mgr.c:	kill_job->job_state = job_ptr->job_state;
job_mgr.c:	kill_job->job_uid   = job_ptr->user_id;
job_mgr.c:	kill_job->nodes     = xstrdup(job_ptr->nodes);
job_mgr.c:	kill_job->start_time = job_ptr->start_time;
job_mgr.c:			job_ptr->select_jobinfo);
job_mgr.c:	kill_job->spank_job_env = xduparray(job_ptr->spank_job_env_size,
job_mgr.c:					    job_ptr->spank_job_env);
job_mgr.c:	kill_job->spank_job_env_size = job_ptr->spank_job_env_size;
job_mgr.c:	if (job_ptr->batch_host &&
job_mgr.c:	    (front_end_ptr = job_ptr->front_end_ptr)) {
job_mgr.c:		hostlist_push_host(agent_args->hostlist, job_ptr->batch_host);
job_mgr.c:	if (!job_ptr->node_bitmap_cg)
job_mgr.c:		if (!bit_test(job_ptr->node_bitmap_cg, i))
job_mgr.c:		if (job_ptr->details->expanding_jobid == 0) {
job_mgr.c:	if ((!job_ptr->db_index || job_ptr->db_index == NO_VAL64)
job_mgr.c:	    && !job_ptr->resize_time)
job_mgr.c:	job_ptr->job_state |= JOB_RESIZING;
job_mgr.c:	time_t org_submit = job_ptr->details->submit_time;
job_mgr.c:	if (job_ptr->resize_time)
job_mgr.c:		job_ptr->details->submit_time = job_ptr->resize_time;
job_mgr.c:	job_ptr->resize_time = time(NULL);
job_mgr.c:	job_ptr->details->submit_time = org_submit;
job_mgr.c:	job_ptr->job_state &= (~JOB_RESIZING);
job_mgr.c:	job_ptr->end_time_exp = job_ptr->end_time;
job_mgr.c:	if (job_ptr->step_list && (list_count(job_ptr->step_list) > 0))
job_mgr.c:		job_ptr->bit_flags |= JOB_RESIZED;
job_mgr.c:			if (bit_test(job_ptr->node_bitmap, node_inx)) {
job_mgr.c:				if ((job_ptr->batch_flag) &&
job_mgr.c:						job_ptr->node_bitmap))) {
job_mgr.c:					job_ptr->time_last_active = now;
job_mgr.c:				     __func__, job_ptr->nodes,
job_mgr.c:				     job_ptr->node_cnt, node_inx);
job_mgr.c:		else if (difftime(now, job_ptr->end_time) <
job_mgr.c:			      job_state_string(job_ptr->job_state),
job_mgr.c:		    (!bit_test(job_ptr->node_bitmap, node_inx)))
job_mgr.c:		if ((job_ptr->batch_flag != 0)			&&
job_mgr.c:		    (job_ptr->start_time < node_boot_time)) {
job_mgr.c:		if ((job_ptr->batch_flag != 0)			&&
job_mgr.c:		    (job_ptr->pack_job_offset == 0)		&&
job_mgr.c:		    (job_ptr->time_last_active < startup_time)	&&
job_mgr.c:		    (job_ptr->start_time       < startup_time)	&&
job_mgr.c:		    (node_ptr == find_node_record(job_ptr->batch_host))) {
job_mgr.c:			if (job_ptr->details && job_ptr->details->requeue) {
job_mgr.c:			     job_ptr, job_ptr->batch_host, requeue_msg);
job_mgr.c:			job_ptr->exit_code = 1;
job_mgr.c:			job_complete(job_ptr->job_id,
job_mgr.c:	step_iterator = list_iterator_create (job_ptr->step_list);
job_mgr.c:			     node_name, job_ptr->job_id, step_ptr->step_id);
job_mgr.c:			gres_plugin_epilog_build_env(job_ptr->gres_list,
job_mgr.c:						     job_ptr->nodes);
job_mgr.c:		kill_req->pack_jobid	= job_ptr->pack_job_id;
job_mgr.c:		kill_req->start_time = job_ptr->start_time;
job_mgr.c:			select_g_select_jobinfo_copy(job_ptr->select_jobinfo);
job_mgr.c:		kill_req->spank_job_env = xduparray(job_ptr->spank_job_env_size,
job_mgr.c:						    job_ptr->spank_job_env);
job_mgr.c:		kill_req->spank_job_env_size = job_ptr->spank_job_env_size;
job_mgr.c:	if (job_ptr && job_ptr->front_end_ptr)
job_mgr.c:			job_ptr->front_end_ptr->protocol_version;
job_mgr.c:			gres_plugin_epilog_build_env(job_ptr->gres_list,
job_mgr.c:						     job_ptr->nodes);
job_mgr.c:		kill_req->job_id	= job_ptr->job_id;
job_mgr.c:		kill_req->pack_jobid	= job_ptr->pack_job_id;
job_mgr.c:		kill_req->start_time	= job_ptr->start_time;
job_mgr.c:			select_g_select_jobinfo_copy(job_ptr->select_jobinfo);
job_mgr.c:		kill_req->spank_job_env = xduparray(job_ptr->spank_job_env_size,
job_mgr.c:						    job_ptr->spank_job_env);
job_mgr.c:		kill_req->spank_job_env_size = job_ptr->spank_job_env_size;
job_mgr.c:		gres_plugin_epilog_build_env(job_ptr->gres_list,job_ptr->nodes);
job_mgr.c:	kill_req->pack_jobid	= job_ptr->pack_job_id;
job_mgr.c:	kill_req->job_id	= job_ptr->job_id;
job_mgr.c:	kill_req->start_time	= job_ptr->start_time;
job_mgr.c:			select_g_select_jobinfo_copy(job_ptr->select_jobinfo);
job_mgr.c:	kill_req->job_state	= job_ptr->job_state;
job_mgr.c:	kill_req->spank_job_env = xduparray(job_ptr->spank_job_env_size,
job_mgr.c:					    job_ptr->spank_job_env);
job_mgr.c:	kill_req->spank_job_env_size = job_ptr->spank_job_env_size;
job_mgr.c:	xassert(job_ptr->batch_host);
job_mgr.c:	if (job_ptr->front_end_ptr)
job_mgr.c:			job_ptr->front_end_ptr->protocol_version;
job_mgr.c:	agent_info->hostlist	= hostlist_create(job_ptr->batch_host);
job_mgr.c:	      job_ptr, job_ptr->batch_host);
job_mgr.c:	if (!job_ptr->pack_job_list)
job_mgr.c:	iter = list_iterator_create(job_ptr->pack_job_list);
job_mgr.c:	    (job_ptr->user_id != uid) && !validate_operator(uid) &&
job_mgr.c:					    job_ptr->account)) ||
job_mgr.c:	      (mcs_g_check_mcs_label(uid, job_ptr->mcs_label) != 0))))
job_mgr.c:	if (job_ptr->details)
job_mgr.c:		prolog = job_ptr->details->prolog_running;
job_mgr.c:	if (job_ptr->alias_list && !xstrcmp(job_ptr->alias_list, "TBD") &&
job_mgr.c:	    (prolog == 0) && job_ptr->node_bitmap &&
job_mgr.c:	    (bit_overlap(power_node_bitmap, job_ptr->node_bitmap) == 0)) {
job_mgr.c:	job_ptr->bit_flags &= ~HAS_STATE_DIR;
job_mgr.c:	if (job_ptr->bit_flags & HAS_STATE_DIR) {
job_mgr.c:		job_ptr->bit_flags &= ~HAS_STATE_DIR;
job_mgr.c:	if (!job_ptr->batch_flag || !IS_JOB_PENDING(job_ptr) ||
job_mgr.c:	    (job_ptr->pack_job_offset > 0))
job_mgr.c:	job_ptr->job_state = JOB_FAILED;
job_mgr.c:	job_ptr->exit_code = 1;
job_mgr.c:	job_ptr->state_reason = FAIL_SYSTEM;
job_mgr.c:	xfree(job_ptr->state_desc);
job_mgr.c:	job_ptr->start_time = job_ptr->end_time = time(NULL);
job_mgr.c:			job_ptr->bit_flags |= HAS_STATE_DIR;
job_mgr.c:		if (job_ptr && job_ptr->array_recs) { /* Update all tasks */
job_mgr.c:			array_job_id = job_ptr->array_job_id;
job_mgr.c:				if (job_ptr->array_job_id == array_job_id)
job_mgr.c:					job_ptr->bit_flags |= HAS_STATE_DIR;
job_mgr.c:				job_ptr = job_ptr->job_array_next_j;
job_mgr.c:	job_time_msg_ptr->job_id          = job_ptr->job_id;
job_mgr.c:	job_time_msg_ptr->expiration_time = job_ptr->end_time;
job_mgr.c:	xassert(job_ptr->batch_host);
job_mgr.c:	if (job_ptr->front_end_ptr)
job_mgr.c:			job_ptr->front_end_ptr->protocol_version;
job_mgr.c:	hostlist_push_host(agent_args->hostlist, job_ptr->batch_host);
job_mgr.c:		if (bit_test(job_ptr->node_bitmap, i) == 0)
job_mgr.c:	    (job_ptr->node_bitmap == NULL)) {
job_mgr.c:		} else if (job_ptr->restart_cnt) {
job_mgr.c:	xassert(job_ptr->batch_host);
job_mgr.c:		      __func__, job_ptr, job_ptr->batch_host);
job_mgr.c:	if (job_ptr->front_end_ptr && IS_JOB_COMPLETING(job_ptr)) {
job_mgr.c:		front_end_record_t *front_end_ptr = job_ptr->front_end_ptr;
job_mgr.c:	if ((job_ptr->total_nodes == 0) && IS_JOB_COMPLETING(job_ptr)) {
job_mgr.c:		front_end_record_t *front_end_ptr = job_ptr->front_end_ptr;
job_mgr.c:			if (!bit_test(job_ptr->node_bitmap, i))
job_mgr.c:	xfree(job_ptr->nodes_completing);
job_mgr.c:	    !IS_JOB_PENDING(job_ptr) || !job_ptr->batch_flag)
job_mgr.c:	job_ptr->start_time = 0;
job_mgr.c:	job_ptr->end_time_exp = job_ptr->end_time = 0;
job_mgr.c:	job_ptr->total_cpus = 0;
job_mgr.c:	job_ptr->pre_sus_time = 0;
job_mgr.c:	job_ptr->suspend_time = 0;
job_mgr.c:	job_ptr->tot_sus_time = 0;
job_mgr.c:	//job_ptr->next_step_id = 0;
job_mgr.c:	job_ptr->node_cnt = 0;
job_mgr.c:	xfree(job_ptr->nodes);
job_mgr.c:	xfree(job_ptr->nodes_completing);
job_mgr.c:	FREE_NULL_BITMAP(job_ptr->node_bitmap);
job_mgr.c:	FREE_NULL_BITMAP(job_ptr->node_bitmap_cg);
job_mgr.c:	if (job_ptr->details) {
job_mgr.c:		if (job_ptr->details->begin_time <= now) {
job_mgr.c:			job_ptr->details->begin_time = now + cred_lifetime + 1;
job_mgr.c:		if (now == job_ptr->details->submit_time)
job_mgr.c:		job_ptr->details->submit_time = now;
job_mgr.c:		job_ptr->bit_flags &= ~JOB_ACCRUE_OVER;
job_mgr.c:		job_ptr->details->accrue_time = 0;
job_mgr.c:	if (job_ptr->resv_ptr)
job_mgr.c:		job_ptr->resv_id = job_ptr->resv_ptr->resv_id;
job_mgr.c:	job_ptr->db_index = 0;
job_mgr.c:	if ((job_ptr->array_task_id != NO_VAL) || job_ptr->array_recs) {
job_mgr.c:		base_job_ptr = find_job_record(job_ptr->array_job_id);
job_mgr.c:		if (base_job_ptr && base_job_ptr->array_recs) {
job_mgr.c:			base_job_ptr->array_recs->tot_run_tasks++;
job_mgr.c:	if ((job_ptr->array_task_id != NO_VAL) || job_ptr->array_recs) {
job_mgr.c:		base_job_ptr = find_job_record(job_ptr->array_job_id);
job_mgr.c:		if (base_job_ptr && base_job_ptr->array_recs &&
job_mgr.c:		    (base_job_ptr->array_recs->max_run_tasks != 0) &&
job_mgr.c:		    (base_job_ptr->array_recs->tot_run_tasks >=
job_mgr.c:		     base_job_ptr->array_recs->max_run_tasks)) {
job_mgr.c:			if (job_ptr->details &&
job_mgr.c:			    (job_ptr->details->begin_time <= now))
job_mgr.c:				job_ptr->details->begin_time = (time_t) 0;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:			job_ptr->state_reason = WAIT_ARRAY_TASK_LIMIT;
job_mgr.c:	if ((job_ptr->array_task_id != NO_VAL) || job_ptr->array_recs) {
job_mgr.c:		status = job_ptr->exit_code;
job_mgr.c:		base_job_ptr = find_job_record(job_ptr->array_job_id);
job_mgr.c:		if (base_job_ptr && base_job_ptr->array_recs) {
job_mgr.c:			if (base_job_ptr->array_recs->tot_comp_tasks == 0) {
job_mgr.c:				base_job_ptr->array_recs->min_exit_code =
job_mgr.c:				base_job_ptr->array_recs->max_exit_code =
job_mgr.c:				base_job_ptr->array_recs->min_exit_code =
job_mgr.c:					MIN(status, base_job_ptr->
job_mgr.c:				base_job_ptr->array_recs->max_exit_code =
job_mgr.c:					MAX(status, base_job_ptr->
job_mgr.c:			    base_job_ptr->array_recs->tot_run_tasks)
job_mgr.c:				base_job_ptr->array_recs->tot_run_tasks--;
job_mgr.c:			base_job_ptr->array_recs->tot_comp_tasks++;
job_mgr.c:				base_job_ptr->array_recs->array_flags |=
job_mgr.c:	if (job_ptr->nodes && ((job_ptr->bit_flags & JOB_KILL_HURRY) == 0)
job_mgr.c:	} else if (job_ptr->nodes && IS_JOB_RESIZING(job_ptr)){
job_mgr.c:	if (job_ptr->bit_flags & JOB_WAS_RUNNING) {
job_mgr.c:		job_ptr->bit_flags &= ~JOB_WAS_RUNNING;
job_mgr.c:	    ((job_ptr->array_task_id == NO_VAL) ||
job_mgr.c:	     (job_ptr->mail_type & MAIL_ARRAY_TASKS) ||
job_mgr.c:	     (arr_finished = test_job_array_finished(job_ptr->array_job_id)))) {
job_mgr.c:		job_ptr->job_state &= ~JOB_CONFIGURING;
job_mgr.c:		if (!job_ptr->fed_details ||
job_mgr.c:			master_job = find_job_record(job_ptr->array_job_id);
job_mgr.c:				    (job_ptr->mail_type & MAIL_JOB_REQUEUE)) {
job_mgr.c:				    (job_ptr->mail_type & MAIL_JOB_FAIL)) {
job_mgr.c:				} else if (job_ptr->mail_type & MAIL_JOB_END) {
job_mgr.c:			base_state = job_ptr->job_state & JOB_STATE_BASE;
job_mgr.c:				    (job_ptr->mail_type & MAIL_JOB_REQUEUE)) {
job_mgr.c:				} else if (job_ptr->mail_type & MAIL_JOB_END) {
job_mgr.c:				if (job_ptr->mail_type & MAIL_JOB_FAIL)
job_mgr.c:				else if (job_ptr->mail_type & MAIL_JOB_END)
job_mgr.c:	if (!with_slurmdbd && !job_ptr->db_index)
job_mgr.c:	if (!(job_ptr->bit_flags & TRES_STR_CALC) &&
job_mgr.c:	    job_ptr->tres_alloc_cnt &&
job_mgr.c:	    (job_ptr->tres_alloc_cnt[TRES_ENERGY] != NO_VAL64))
job_mgr.c:	struct job_details *detail_ptr = job_ptr->details;
job_mgr.c:	if ((job_ptr->state_reason == FAIL_BURST_BUFFER_OP) ||
job_mgr.c:	    (job_ptr->state_reason == FAIL_ACCOUNT) ||
job_mgr.c:	    (job_ptr->state_reason == FAIL_QOS) ||
job_mgr.c:	    (job_ptr->state_reason == WAIT_HELD) ||
job_mgr.c:	    (job_ptr->state_reason == WAIT_HELD_USER) ||
job_mgr.c:	    (job_ptr->state_reason == WAIT_MAX_REQUEUE) ||
job_mgr.c:	    (job_ptr->state_reason == WAIT_RESV_DELETED) ||
job_mgr.c:	    (job_ptr->state_reason == WAIT_DEP_INVALID))
job_mgr.c:		job_ptr->state_reason = WAIT_DEPENDENCY;
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:		if (job_ptr->bit_flags & KILL_INV_DEP) {
job_mgr.c:		} else if (job_ptr->bit_flags & NO_KILL_INV_DEP) {
job_mgr.c:			job_ptr->state_reason = WAIT_DEP_INVALID;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:			job_ptr->state_reason = WAIT_DEP_INVALID;
job_mgr.c:			xfree(job_ptr->state_desc);
job_mgr.c:	if (job_ptr->state_reason == WAIT_DEPENDENCY) {
job_mgr.c:		job_ptr->state_reason = WAIT_NO_REASON;
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:		job_ptr->state_reason = WAIT_TIME;
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:		job_ptr->state_reason = WAIT_RESERVATION;
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:	    (job_ptr->priority != 0))) {
job_mgr.c:	} else if (job_ptr->state_reason == WAIT_TIME) {
job_mgr.c:		job_ptr->state_reason = WAIT_NO_REASON;
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:	if (job_ptr->details && job_ptr->details->prolog_running)
job_mgr.c:	    job_ptr->alias_list && !xstrcmp(job_ptr->alias_list, "TBD") &&
job_mgr.c:	    job_ptr->node_bitmap &&
job_mgr.c:	    (bit_overlap(power_node_bitmap, job_ptr->node_bitmap) == 0)) {
job_mgr.c:		step_iterator = list_iterator_create(job_ptr->step_list);
job_mgr.c:			job_step_signal(job_ptr->job_id, step_ptr->step_id,
job_mgr.c:	signal_job_msg->job_id = job_ptr->job_id;
job_mgr.c:	xassert(job_ptr->batch_host);
job_mgr.c:	if (job_ptr->front_end_ptr)
job_mgr.c:			job_ptr->front_end_ptr->protocol_version;
job_mgr.c:	hostlist_push_host(agent_args->hostlist, job_ptr->batch_host);
job_mgr.c:		if (bit_test(job_ptr->node_bitmap, i) == 0)
job_mgr.c:	step_iterator = list_iterator_create (job_ptr->step_list);
job_mgr.c:	sus_ptr->job_core_spec = job_ptr->details->core_spec;
job_mgr.c:	sus_ptr->job_id = job_ptr->job_id;
job_mgr.c:	xassert(job_ptr->batch_host);
job_mgr.c:	if (job_ptr->front_end_ptr) {
job_mgr.c:			job_ptr->front_end_ptr->protocol_version;
job_mgr.c:	hostlist_push_host(agent_args->hostlist, job_ptr->batch_host);
job_mgr.c:		if (bit_test(job_ptr->node_bitmap, i) == 0)
job_mgr.c:	i_first = bit_ffs(job_ptr->node_bitmap);
job_mgr.c:		i_last = bit_fls(job_ptr->node_bitmap);
job_mgr.c:		if (!bit_test(job_ptr->node_bitmap, i))
job_mgr.c:                        if(job_ptr->comment && strcmp(job_ptr->comment,"1")==0){
job_mgr.c:                                      job_ptr->job_id,node_ptr->leaf_switch);
job_mgr.c:		if (job_ptr->details && (job_ptr->details->share_res == 0)) {
job_mgr.c:	i_first = bit_ffs(job_ptr->node_bitmap);
job_mgr.c:		i_last = bit_fls(job_ptr->node_bitmap);
job_mgr.c:		if (!bit_test(job_ptr->node_bitmap, i))
job_mgr.c:		if (!bit_test(job_ptr->node_bitmap, i))
job_mgr.c:                if(job_ptr->comment && strcmp(job_ptr->comment,"1")==0){
job_mgr.c:                               job_ptr->job_id,node_ptr->leaf_switch);
job_mgr.c:		if (job_ptr->details &&
job_mgr.c:		    (job_ptr->details->share_res == 0)) {
job_mgr.c:	step_iterator = list_iterator_create(job_ptr->step_list);
job_mgr.c:	if ((job_ptr->details == NULL) ||
job_mgr.c:	    (job_ptr->details->core_spec == NO_VAL16) ||
job_mgr.c:	    (job_ptr->node_bitmap == NULL))
job_mgr.c:		if (test_job_ptr->details &&
job_mgr.c:		    (test_job_ptr->details->core_spec != NO_VAL16) &&
job_mgr.c:		    test_job_ptr->node_bitmap &&
job_mgr.c:		    bit_overlap(test_job_ptr->node_bitmap,
job_mgr.c:				job_ptr->node_bitmap)) {
job_mgr.c:			job_ptr->priority = 0;	/* Prevent gang sched resume */
job_mgr.c:		job_ptr->job_state = JOB_SUSPENDED;
job_mgr.c:			job_ptr->priority = 0;
job_mgr.c:		if (job_ptr->suspend_time) {
job_mgr.c:			job_ptr->pre_sus_time +=
job_mgr.c:				difftime(now, job_ptr->suspend_time);
job_mgr.c:			job_ptr->pre_sus_time +=
job_mgr.c:				difftime(now, job_ptr->start_time);
job_mgr.c:		if (job_ptr->priority == 0) {
job_mgr.c:		job_ptr->job_state = JOB_RUNNING;
job_mgr.c:		job_ptr->tot_sus_time +=
job_mgr.c:			difftime(now, job_ptr->suspend_time);
job_mgr.c:		if ((job_ptr->time_limit != INFINITE) &&
job_mgr.c:		    (!job_ptr->preempt_time)) {
job_mgr.c:			job_ptr->end_time_exp = job_ptr->end_time =
job_mgr.c:				now + (job_ptr->time_limit * 60)
job_mgr.c:				- job_ptr->pre_sus_time;
job_mgr.c:	job_ptr->time_last_active = now;
job_mgr.c:	job_ptr->suspend_time = now;
job_mgr.c:	if (job_ptr->pack_job_id && !job_ptr->pack_job_list)
job_mgr.c:	if (job_ptr->pack_job_list) {
job_mgr.c:		iter = list_iterator_create(job_ptr->pack_job_list);
job_mgr.c:			if (job_ptr->pack_job_id != pack_job->pack_job_id) {
job_mgr.c:		    (((job_ptr->array_task_id == NO_VAL) &&
job_mgr.c:		      (job_ptr->array_recs == NULL)) ||
job_mgr.c:		     ((job_ptr->array_task_id != NO_VAL) &&
job_mgr.c:		      (job_ptr->array_job_id  != job_id)))) {
job_mgr.c:		if (job_ptr && job_ptr->array_recs) {
job_mgr.c:			if ((job_ptr->array_job_id == job_id) &&
job_mgr.c:			job_ptr = job_ptr->job_array_next_j;
job_mgr.c:	if ((uid != job_ptr->user_id) && !validate_operator(uid) &&
job_mgr.c:					  job_ptr->account)) {
job_mgr.c:		node_features_g_get_node(job_ptr->nodes);
job_mgr.c:	if (!job_ptr->part_ptr || !job_ptr->details
job_mgr.c:	    || !job_ptr->details->requeue) {
job_mgr.c:	if (job_ptr->batch_flag == 0) {
job_mgr.c:	    (!job_ptr->fed_details || !job_ptr->fed_details->cluster_lock))
job_mgr.c:	if (job_ptr->fed_details) {
job_mgr.c:		if (job_ptr->job_state & JOB_REQUEUE_FED)
job_mgr.c:		completing_flags = job_ptr->job_state & JOB_STATE_FLAGS;
job_mgr.c:		uint32_t suspend_job_state = job_ptr->job_state;
job_mgr.c:		job_ptr->job_state = JOB_REQUEUE;
job_mgr.c:		job_ptr->job_state = suspend_job_state;
job_mgr.c:	job_ptr->time_last_active  = now;
job_mgr.c:		job_ptr->end_time = job_ptr->suspend_time;
job_mgr.c:		job_ptr->end_time = now;
job_mgr.c:			job_ptr->job_state = JOB_PREEMPTED;
job_mgr.c:			job_ptr->job_state = JOB_REQUEUE;
job_mgr.c:			job_ptr->job_state = JOB_REQUEUE;
job_mgr.c:	job_ptr->restart_cnt++;
job_mgr.c:		job_ptr->job_state = JOB_PENDING | completing_flags;
job_mgr.c:		job_ptr->job_state |= JOB_COMPLETING;
job_mgr.c:		job_ptr->job_state &= (~JOB_COMPLETING);
job_mgr.c:	//job_ptr->db_index = 0;
job_mgr.c:	//job_ptr->details->submit_time = now;
job_mgr.c:	job_ptr->job_state = JOB_PENDING;
job_mgr.c:	if (job_ptr->node_cnt)
job_mgr.c:		job_ptr->job_state |= JOB_COMPLETING;
job_mgr.c:	if (job_ptr->fed_details && !is_completed) {
job_mgr.c:		job_ptr->job_state |= JOB_COMPLETING;
job_mgr.c:		job_ptr->job_state |= JOB_REQUEUE_FED;
job_mgr.c:	if (job_ptr->limit_set.time == 1) {
job_mgr.c:		job_ptr->time_limit = NO_VAL;
job_mgr.c:		job_ptr->limit_set.time = 0;
job_mgr.c:	job_ptr->pre_sus_time = (time_t) 0;
job_mgr.c:	job_ptr->suspend_time = (time_t) 0;
job_mgr.c:	job_ptr->tot_sus_time = (time_t) 0;
job_mgr.c:	job_ptr->db_flags = 0;
job_mgr.c:	job_ptr->warn_flags &= ~WARN_SENT;
job_mgr.c:		job_ptr->job_state |= JOB_SPECIAL_EXIT;
job_mgr.c:		job_ptr->state_reason = WAIT_HELD_USER;
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:		job_ptr->state_desc =
job_mgr.c:		job_ptr->priority = 0;
job_mgr.c:		job_ptr->state_reason = WAIT_HELD_USER;
job_mgr.c:		xfree(job_ptr->state_desc);
job_mgr.c:			job_ptr->state_desc
job_mgr.c:			job_ptr->state_desc
job_mgr.c:		job_ptr->priority = 0;
job_mgr.c:	      __func__, job_ptr, job_ptr->job_state,
job_mgr.c:	      job_ptr->state_reason, job_ptr->priority);
job_mgr.c:	if (job_ptr->pack_job_id && !job_ptr->pack_job_list)
job_mgr.c:	if (job_ptr->pack_job_list) {
job_mgr.c:		iter = list_iterator_create(job_ptr->pack_job_list);
job_mgr.c:			if (job_ptr->pack_job_id != pack_job->pack_job_id) {
job_mgr.c:		    (((job_ptr->array_task_id == NO_VAL) &&
job_mgr.c:		      (job_ptr->array_recs == NULL)) ||
job_mgr.c:		     ((job_ptr->array_task_id != NO_VAL) &&
job_mgr.c:		      (job_ptr->array_job_id  != job_id)))) {
job_mgr.c:		if (job_ptr && job_ptr->array_recs) {
job_mgr.c:			if ((job_ptr->array_job_id == job_id) &&
job_mgr.c:			job_ptr = job_ptr->job_array_next_j;
job_mgr.c:	job_ptr->bit_flags &= (~TOP_PRIO_TMP);
job_mgr.c:		if ((job_ptr->user_id != uid) && (uid != 0)) {
job_mgr.c:		if (!IS_JOB_PENDING(job_ptr) || (job_ptr->details == NULL)) {
job_mgr.c:		if (job_ptr->part_ptr_list) {
job_mgr.c:		if (job_ptr->priority == 0) {
job_mgr.c:		if (job_ptr->bit_flags & TOP_PRIO_TMP) {
job_mgr.c:		job_ptr->bit_flags |= TOP_PRIO_TMP;
job_mgr.c:		*prio_elem = job_ptr->priority;
job_mgr.c:		if ((job_ptr->bit_flags & TOP_PRIO_TMP) ||
job_mgr.c:		    (job_ptr->details == NULL) ||
job_mgr.c:		    (job_ptr->part_ptr_list)   ||
job_mgr.c:		    (job_ptr->priority <= 1)   ||
job_mgr.c:		    (job_ptr->assoc_ptr != first_job_ptr->assoc_ptr) ||
job_mgr.c:		    (job_ptr->part_ptr  != first_job_ptr->part_ptr)  ||
job_mgr.c:		    (job_ptr->qos_ptr   != first_job_ptr->qos_ptr)   ||
job_mgr.c:		    (job_ptr->user_id   != first_job_ptr->user_id)   ||
job_mgr.c:		job_ptr->bit_flags |= TOP_PRIO_TMP;
job_mgr.c:		*prio_elem = job_ptr->priority;
job_mgr.c:		delta_prio = (int64_t) next_prio - job_ptr->priority;
job_mgr.c:		delta_nice = MIN(job_ptr->details->nice, delta_prio);
job_mgr.c:		job_ptr->priority = next_prio;
job_mgr.c:		job_ptr->details->nice -= delta_nice;
job_mgr.c:		job_ptr->bit_flags &= (~TOP_PRIO_TMP);
job_mgr.c:			next_prio = job_ptr->priority - delta_prio;
job_mgr.c:				delta_prio = job_ptr->priority - next_prio;
job_mgr.c:			job_ptr->priority = next_prio;
job_mgr.c:			job_ptr->details->nice += delta_nice;
job_mgr.c:			job_ptr->bit_flags &= (~TOP_PRIO_TMP);
job_mgr.c:	timeout_msg->timeout = job_ptr->end_time;
job_mgr.c:		    (job_ptr->node_bitmap == NULL))
job_mgr.c:		xfree(job_ptr->nodes_completing);
job_mgr.c:		if (job_ptr->node_bitmap_cg) {
job_mgr.c:			job_ptr->nodes_completing =
job_mgr.c:				bitmap2node_name(job_ptr->node_bitmap_cg);
job_mgr.c:			job_ptr->nodes_completing =
job_mgr.c:				bitmap2node_name(job_ptr->node_bitmap);
job_mgr.c:		if (job_ptr->assoc_id != assoc_id)
job_mgr.c:		if (job_ptr->qos_blocking_ptr &&
job_mgr.c:		    ((slurmdb_qos_rec_t *)job_ptr->qos_blocking_ptr)->id
job_mgr.c:			job_ptr->qos_blocking_ptr = NULL;
job_mgr.c:		if (job_ptr->qos_id != qos_id)
job_mgr.c:	if ((!IS_JOB_PENDING(job_ptr)) || (job_ptr->details == NULL)) {
job_mgr.c:	wckey_rec.uid       = job_ptr->user_id;
job_mgr.c:			      job_ptr->user_id);
job_mgr.c:	xfree(job_ptr->wckey);
job_mgr.c:		job_ptr->wckey = xstrdup(wckey_rec.name);
job_mgr.c:		if (!job_ptr->assoc_id) {
job_mgr.c:			assoc_rec.acct      = job_ptr->account;
job_mgr.c:			if (job_ptr->part_ptr)
job_mgr.c:				assoc_rec.partition = job_ptr->part_ptr->name;
job_mgr.c:			assoc_rec.uid       = job_ptr->user_id;
job_mgr.c:				   &job_ptr->assoc_ptr, false) &&
job_mgr.c:				job_ptr->assoc_id = assoc_rec.id;
job_mgr.c:		if (job_ptr->db_index || IS_JOB_FINISHED(job_ptr))
job_mgr.c:	if ((uid != job_ptr->user_id) && !validate_slurm_user(uid)) {
job_mgr.c:	if (job_ptr->batch_flag) { /* operate on batch job */
job_mgr.c:			if (job_ptr->details == NULL) {
job_mgr.c:				if (job_ptr->details->ckpt_dir == NULL) {
job_mgr.c:				ckpt_ptr->image_dir = xstrdup(job_ptr->details
job_mgr.c:		xstrfmtcat(ckpt_ptr->image_dir, "/%u", job_ptr->job_id);
job_mgr.c:		step_iterator = list_iterator_create (job_ptr->step_list);
job_mgr.c:			xstrfmtcat(image_dir, "/%u.%u", job_ptr->job_id,
job_mgr.c:	xstrfmtcat(ckpt_file, "/%u.ckpt", job_ptr->job_id);
job_mgr.c:	packstr(job_ptr->nodes, buffer);
job_mgr.c:	struct job_details *details = job_ptr->details;
job_mgr.c:	job_desc->account           = xstrdup(job_ptr->account);
job_mgr.c:	job_desc->alloc_node        = xstrdup(job_ptr->alloc_node);
job_mgr.c:	 * job_desc->alloc_resp_port   = job_ptr->alloc_resp_port;
job_mgr.c:	 * job_desc->alloc_sid         = job_ptr->alloc_sid;
job_mgr.c:	job_desc->bitflags 	    = job_ptr->bit_flags;
job_mgr.c:	job_desc->ckpt_interval     = job_ptr->ckpt_interval;
job_mgr.c:	job_desc->clusters          = xstrdup(job_ptr->clusters);
job_mgr.c:	job_desc->comment           = xstrdup(job_ptr->comment);
job_mgr.c:	job_desc->deadline          = job_ptr->deadline;
job_mgr.c:	job_desc->group_id          = job_ptr->group_id;
job_mgr.c:	job_desc->job_id            = job_ptr->job_id;
job_mgr.c:	job_desc->kill_on_node_fail = job_ptr->kill_on_node_fail;
job_mgr.c:	job_desc->licenses          = xstrdup(job_ptr->licenses);
job_mgr.c:	job_desc->mail_type         = job_ptr->mail_type;
job_mgr.c:	job_desc->mail_user         = xstrdup(job_ptr->mail_user);
job_mgr.c:	job_desc->mcs_label	    = xstrdup(job_ptr->mcs_label);
job_mgr.c:	job_desc->name              = xstrdup(job_ptr->name);
job_mgr.c:	job_desc->network           = xstrdup(job_ptr->network);
job_mgr.c:	job_desc->origin_cluster    = xstrdup(job_ptr->origin_cluster);
job_mgr.c:	job_desc->other_port        = job_ptr->other_port;
job_mgr.c:	job_desc->power_flags       = job_ptr->power_flags;
job_mgr.c:	job_desc->partition         = xstrdup(job_ptr->partition);
job_mgr.c:	job_desc->priority          = job_ptr->priority;
job_mgr.c:	if (job_ptr->qos_ptr)
job_mgr.c:		job_desc->qos       = xstrdup(job_ptr->qos_ptr->name);
job_mgr.c:	job_desc->resp_host         = xstrdup(job_ptr->resp_host);
job_mgr.c:	job_desc->reservation       = xstrdup(job_ptr->resv_name);
job_mgr.c:	job_desc->restart_cnt       = job_ptr->restart_cnt;
job_mgr.c:	job_desc->spank_job_env_size = job_ptr->spank_job_env_size;
job_mgr.c:		job_desc->spank_job_env[i]= xstrdup(job_ptr->spank_job_env[i]);
job_mgr.c:	job_desc->time_limit        = job_ptr->time_limit;
job_mgr.c:	job_desc->time_min          = job_ptr->time_min;
job_mgr.c:	job_desc->user_id           = job_ptr->user_id;
job_mgr.c:	job_desc->wait_all_nodes    = job_ptr->wait_all_nodes;
job_mgr.c:	job_desc->warn_flags        = job_ptr->warn_flags;
job_mgr.c:	job_desc->warn_signal       = job_ptr->warn_signal;
job_mgr.c:	job_desc->warn_time         = job_ptr->warn_time;
job_mgr.c:	job_desc->wckey             = xstrdup(job_ptr->wckey);
job_mgr.c:	job_desc->cpus_per_tres     = xstrdup(job_ptr->cpus_per_tres);
job_mgr.c:	job_desc->mem_per_tres      = xstrdup(job_ptr->mem_per_tres);
job_mgr.c:	job_desc->tres_bind         = xstrdup(job_ptr->tres_bind);
job_mgr.c:	job_desc->tres_freq         = xstrdup(job_ptr->tres_freq);
job_mgr.c:	job_desc->tres_per_job      = xstrdup(job_ptr->tres_per_job);
job_mgr.c:	job_desc->tres_per_node     = xstrdup(job_ptr->tres_per_node);
job_mgr.c:	job_desc->tres_per_socket   = xstrdup(job_ptr->tres_per_socket);
job_mgr.c:	job_desc->tres_per_task     = xstrdup(job_ptr->tres_per_task);
job_mgr.c:	if (job_ptr->fed_details) {
job_mgr.c:			job_ptr->fed_details->siblings_active;
job_mgr.c:			job_ptr->fed_details->siblings_viable;
job_mgr.c:		job_ptr->details->restart_dir = image_dir;
job_mgr.c:	FREE_NULL_BITMAP(job_ptr->node_bitmap_cg);
job_mgr.c:	if (job_ptr->node_bitmap) {
job_mgr.c:		job_ptr->node_bitmap_cg = bit_copy(job_ptr->node_bitmap);
job_mgr.c:		if (bit_set_count(job_ptr->node_bitmap_cg) == 0)
job_mgr.c:			job_ptr->job_state &= (~JOB_COMPLETING);
job_mgr.c:		job_ptr->node_bitmap_cg = bit_alloc(node_record_count);
job_mgr.c:		job_ptr->job_state &= (~JOB_COMPLETING);
job_mgr.c:	state = job_ptr->job_state;
job_mgr.c:	if (!(job_ptr->bit_flags & TRES_STR_CALC) &&
job_mgr.c:	    job_ptr->tres_alloc_cnt &&
job_mgr.c:	    (job_ptr->tres_alloc_cnt[TRES_ENERGY] != NO_VAL64))
job_mgr.c:	flags = job_ptr->job_state & JOB_STATE_FLAGS;
job_mgr.c:	job_ptr->job_state = JOB_PENDING | flags;
job_mgr.c:	job_ptr->restart_cnt++;
job_mgr.c:	job_ptr->warn_flags &= ~WARN_SENT;
job_mgr.c:		job_ptr->job_state |= JOB_SPECIAL_EXIT;
job_mgr.c:		job_ptr->state_reason = WAIT_HELD_USER;
job_mgr.c:		job_ptr->priority = 0;
job_mgr.c:	job_ptr->job_state &= ~JOB_REQUEUE;
job_mgr.c:	if (((job_ptr->array_task_id != NO_VAL) || job_ptr->array_recs) &&
job_mgr.c:	    (base_job_ptr = find_job_record(job_ptr->array_job_id)) &&
job_mgr.c:	    base_job_ptr->array_recs) {
job_mgr.c:		base_job_ptr->array_recs->array_flags |= ARRAY_TASK_REQUEUED;
job_mgr.c:	      __func__, job_ptr, job_ptr->job_state,
job_mgr.c:	      job_ptr->state_reason, job_ptr->priority);
job_mgr.c:	exit_code = WEXITSTATUS(job_ptr->exit_code);
job_mgr.c:		job_ptr->job_state |= JOB_REQUEUE;
job_mgr.c:		job_ptr->job_state |= JOB_REQUEUE;
job_mgr.c:		job_ptr->job_state |= JOB_SPECIAL_EXIT;
job_mgr.c:	if (job_ptr->preempt_time)
job_mgr.c:	if (job_ptr->time_limit == INFINITE) {
job_mgr.c:		job_ptr->end_time = job_ptr->start_time +
job_mgr.c:		job_ptr->end_time = job_ptr->start_time +
job_mgr.c:				    (job_ptr->time_limit * 60);	/* secs */
job_mgr.c:	job_ptr->end_time_exp = job_ptr->end_time;
job_mgr.c:	if (!job_ptr->array_recs || !job_ptr->array_recs->task_id_bitmap)
job_mgr.c:	i = bit_ffs(job_ptr->array_recs->task_id_bitmap);
job_mgr.c:		if (job_ptr->restart_cnt == 0) {
job_mgr.c:		FREE_NULL_BITMAP(job_ptr->array_recs->task_id_bitmap);
job_mgr.c:	job_ptr->array_job_id  = job_ptr->job_id;
job_mgr.c:	job_ptr->array_task_id = i;
job_mgr.c:	if (!job_ptr->array_recs || !job_ptr->array_recs->task_id_bitmap)
job_mgr.c:	if (job_ptr->array_recs->task_cnt <= 1) {
job_mgr.c:		if (job_ptr->array_recs->task_cnt) {
job_mgr.c:			job_ptr->array_recs->task_cnt--;
job_mgr.c:		} else if (job_ptr->restart_cnt) {
job_mgr.c:		xfree(job_ptr->array_recs->task_id_str);
job_mgr.c:		if (job_ptr->array_recs->task_cnt == 0)
job_mgr.c:			FREE_NULL_BITMAP(job_ptr->array_recs->task_id_bitmap);
job_mgr.c:		job_ptr->job_state |= JOB_UPDATE_DB;
job_mgr.c:		if (!find_job_array_rec(job_ptr->array_job_id,
job_mgr.c:					job_ptr->array_task_id)) {
job_mgr.c:			new_job_ptr->job_state = JOB_PENDING;
job_mgr.c:			new_job_ptr->start_time = (time_t) 0;
job_mgr.c:	job_ptr->job_state = JOB_CANCELLED;
job_mgr.c:	xfree(job_ptr->state_desc);
job_mgr.c:	job_ptr->start_time = now;
job_mgr.c:	job_ptr->end_time = now;
job_mgr.c:	xassert(job_ptr->fed_details);
job_mgr.c:	xfree(job_ptr->fed_details->siblings_active_str);
job_mgr.c:	xfree(job_ptr->fed_details->siblings_viable_str);
job_mgr.c:	job_ptr->fed_details->siblings_active_str =
job_mgr.c:					job_ptr->fed_details->siblings_active);
job_mgr.c:	job_ptr->fed_details->siblings_viable_str =
job_mgr.c:					job_ptr->fed_details->siblings_viable);
job_mgr.c:	if (!job_ptr->fed_details->origin_str)
job_mgr.c:		job_ptr->fed_details->origin_str =
job_mgr.c:				fed_mgr_get_cluster_id(job_ptr->job_id));
job_mgr.c:	if (job_ptr->node_cnt &&
job_mgr.c:		if (job_ptr->fed_details &&
job_mgr.c:		resp->node_addr = xcalloc(job_ptr->node_cnt,
job_mgr.c:		memcpy(resp->node_addr, job_ptr->node_addr,
job_mgr.c:		       (sizeof(slurm_addr_t) * job_ptr->node_cnt));
job_mgr.c:	if (!job_ptr->job_resrcs) {
job_mgr.c:	} else if (bit_equal(job_ptr->node_bitmap,
job_mgr.c:			     job_ptr->job_resrcs->node_bitmap)) {
job_mgr.c:			job_ptr->job_resrcs->cpu_array_cnt;
job_mgr.c:			xcalloc(job_ptr->job_resrcs->cpu_array_cnt,
job_mgr.c:		       job_ptr->job_resrcs->cpu_array_reps,
job_mgr.c:		       (sizeof(uint32_t) * job_ptr->job_resrcs->cpu_array_cnt));
job_mgr.c:			xcalloc(job_ptr->job_resrcs->cpu_array_cnt,
job_mgr.c:		       job_ptr->job_resrcs->cpu_array_value,
job_mgr.c:		       (sizeof(uint16_t) * job_ptr->job_resrcs->cpu_array_cnt));
job_mgr.c:		job_info_resp_msg->num_cpu_groups = job_ptr->node_cnt;
job_mgr.c:		job_info_resp_msg->cpu_count_reps = xcalloc(job_ptr->node_cnt,
job_mgr.c:		job_info_resp_msg->cpus_per_node = xcalloc(job_ptr->node_cnt,
job_mgr.c:		for (i = 0, j = -1; i < job_ptr->job_resrcs->nhosts; i++) {
job_mgr.c:			if (job_ptr->job_resrcs->cpus[i] == 0)
job_mgr.c:			     job_ptr->job_resrcs->cpus[i])) {
job_mgr.c:					job_ptr->job_resrcs->cpus[i];
job_mgr.c:	job_info_resp_msg->account        = xstrdup(job_ptr->account);
job_mgr.c:	job_info_resp_msg->alias_list     = xstrdup(job_ptr->alias_list);
job_mgr.c:	job_info_resp_msg->job_id         = job_ptr->job_id;
job_mgr.c:	job_info_resp_msg->node_cnt       = job_ptr->node_cnt;
job_mgr.c:	job_info_resp_msg->node_list      = xstrdup(job_ptr->nodes);
job_mgr.c:	job_info_resp_msg->partition      = xstrdup(job_ptr->partition);
job_mgr.c:	if (job_ptr->qos_ptr) {
job_mgr.c:		qos = (slurmdb_qos_rec_t *)job_ptr->qos_ptr;
job_mgr.c:	job_info_resp_msg->resv_name      = xstrdup(job_ptr->resv_name);
job_mgr.c:		select_g_select_jobinfo_copy(job_ptr->select_jobinfo);
job_mgr.c:	if (job_ptr->details) {
job_mgr.c:		if (job_ptr->bit_flags & JOB_MEM_SET) {
job_mgr.c:				job_ptr->details->pn_min_memory;
job_mgr.c:		if (job_ptr->details->mc_ptr) {
job_mgr.c:				job_ptr->details->mc_ptr->ntasks_per_board;
job_mgr.c:				job_ptr->details->mc_ptr->ntasks_per_core;
job_mgr.c:				job_ptr->details->mc_ptr->ntasks_per_socket;
job_mgr.c:	if (job_ptr->details && job_ptr->details->env_cnt) {
job_mgr.c:		job_info_resp_msg->env_size = job_ptr->details->env_cnt;
job_mgr.c:				xstrdup(job_ptr->details->env_sup[i]);
job_mgr.c: * is defined, return total_cpus. This is cached on job_ptr->billable_tres and
job_mgr.c:	struct part_record *part_ptr = job_ptr->part_ptr;
job_mgr.c:	if (!job_ptr->tres_alloc_cnt)
job_mgr.c:	if ((!fuzzy_equal(job_ptr->billable_tres, NO_VAL)) &&
job_mgr.c:	    difftime(job_ptr->resize_time, start_time) < 0.0)
job_mgr.c:		return job_ptr->billable_tres;
job_mgr.c:		job_ptr->billable_tres = job_ptr->total_cpus;
job_mgr.c:		return job_ptr->billable_tres;
job_mgr.c:		     job_ptr->part_ptr->name);
job_mgr.c:	job_ptr->billable_tres =
job_mgr.c:		assoc_mgr_tres_weighted(job_ptr->tres_alloc_cnt,
job_mgr.c:		     job_ptr->billable_tres);
job_mgr.c:	return job_ptr->billable_tres;
job_mgr.c:	if (job_ptr->warn_signal &&
job_mgr.c:	    !(job_ptr->warn_flags & WARN_SENT) &&
job_mgr.c:	     (job_ptr->warn_time &&
job_mgr.c:	      ((job_ptr->warn_time + PERIODIC_TIMEOUT + time(NULL)) >=
job_mgr.c:	        job_ptr->end_time)))) {
job_mgr.c:		if (job_ptr->warn_flags == 0)
job_mgr.c:			job_ptr->warn_flags = KILL_STEPS_ONLY;
job_mgr.c:		      __func__, job_ptr->warn_signal, job_ptr);
job_mgr.c:		job_signal(job_ptr, job_ptr->warn_signal,
job_mgr.c:			   job_ptr->warn_flags, 0, false);
job_mgr.c:		job_ptr->warn_flags |= WARN_SENT;
power_save.c:	if (job_ptr->reboot)
power_save.c:		boot_node_bitmap = bit_copy(job_ptr->node_bitmap);
power_save.c:		if (bit_overlap(power_node_bitmap, job_ptr->node_bitmap) ||
power_save.c:		    bit_overlap(booting_node_bitmap, job_ptr->node_bitmap)) {
power_save.c:			job_ptr->job_state |= JOB_CONFIGURING;
power_save.c:			job_ptr->bit_flags |= NODE_REBOOT;
power_save.c:	if (job_ptr->details && job_ptr->details->features &&
power_save.c:	    node_features_g_user_update(job_ptr->user_id)) {
power_save.c:					job_ptr->details->features);
power_save.c:			job_ptr->job_state |= JOB_CONFIGURING;
power_save.c:			job_ptr->wait_all_nodes = 1;
power_save.c:			job_ptr->bit_flags |= NODE_REBOOT;
power_save.c:					job_ptr->job_id);
power_save.c:			job_ptr->job_state |= JOB_CONFIGURING;
power_save.c:			job_ptr->wait_all_nodes = 1;
power_save.c:			job_ptr->bit_flags |= NODE_REBOOT;
power_save.c:					job_ptr->job_id);
Binary file step_mgr.o matches
Binary file .libs/slurmctld matches
Binary file reservation.o matches
step_mgr.c:	if (job_ptr->next_step_id >= 0xfffffff0) {
step_mgr.c:		step_ptr->start_protocol_ver = job_ptr->start_protocol_ver;
step_mgr.c:	(void) list_append (job_ptr->step_list, step_ptr);
step_mgr.c:	step_iterator = list_iterator_create(job_ptr->step_list);
step_mgr.c:	if (job_ptr->node_bitmap)
step_mgr.c:		step_ptr->step_node_bitmap = bit_copy(job_ptr->node_bitmap);
step_mgr.c:	if (add_energy && jobacct && job_ptr->tres_alloc_cnt &&
step_mgr.c:		if (job_ptr->tres_alloc_cnt[TRES_ARRAY_ENERGY] == NO_VAL64)
step_mgr.c:			job_ptr->tres_alloc_cnt[TRES_ARRAY_ENERGY] = 0;
step_mgr.c:		job_ptr->tres_alloc_cnt[TRES_ARRAY_ENERGY] +=
step_mgr.c:	    job_ptr->tres_alloc_cnt &&
step_mgr.c:	    (job_ptr->tres_alloc_cnt[TRES_ENERGY] != NO_VAL64) &&
step_mgr.c:	    (list_count(job_ptr->step_list) == 1)) {
step_mgr.c:		job_ptr->bit_flags |= TRES_STR_CALC;
step_mgr.c:	     (step_ptr->exit_code > job_ptr->derived_ec)))
step_mgr.c:		job_ptr->derived_ec = step_ptr->exit_code;
step_mgr.c:	step_iterator = list_iterator_create(job_ptr->step_list);
step_mgr.c:	if (job_ptr->step_list == NULL)
step_mgr.c:	step_iterator = list_iterator_create(job_ptr->step_list);
step_mgr.c:	FREE_NULL_LIST(job_ptr->step_list);
step_mgr.c:	if (!job_ptr->step_list)
step_mgr.c:	step_iterator = list_iterator_create (job_ptr->step_list);
step_mgr.c:	return list_find_first(job_ptr->step_list, _find_step_id, &step_id);
step_mgr.c:	if ((job_ptr->user_id != uid) && !validate_slurm_user(uid)) {
step_mgr.c:			job_state_string(job_ptr->job_state));
step_mgr.c:	signal_tasks_msg->job_id      = step_ptr->job_ptr->job_id;
step_mgr.c:	xassert(step_ptr->job_ptr->batch_host);
step_mgr.c:	if (step_ptr->job_ptr->front_end_ptr)
step_mgr.c:			step_ptr->job_ptr->front_end_ptr->protocol_version;
step_mgr.c:	hostlist_push_host(agent_args->hostlist, step_ptr->job_ptr->batch_host);
step_mgr.c:	xassert(step_ptr->job_ptr->batch_host);
step_mgr.c:	if (step_ptr->job_ptr->front_end_ptr)
step_mgr.c:			step_ptr->job_ptr->front_end_ptr->protocol_version;
step_mgr.c:	agent_args->hostlist = hostlist_create(step_ptr->job_ptr->batch_host);
step_mgr.c:		fatal("Invalid batch_host: %s", step_ptr->job_ptr->batch_host);
step_mgr.c:	signal_tasks_msg->job_id      = step_ptr->job_ptr->job_id;
step_mgr.c:	if (!job_ptr->step_list)
step_mgr.c:	step_iterator = list_iterator_create(job_ptr->step_list);
step_mgr.c:	if ((job_ptr->user_id != uid) && !validate_slurm_user(uid)) {
step_mgr.c:	job_resources_t *job_resrcs_ptr = job_ptr->job_resrcs;
step_mgr.c:	if (job_ptr->node_bitmap == NULL) {
step_mgr.c:		step_spec->max_nodes = job_ptr->node_cnt;
step_mgr.c:		nodes_avail = bit_copy (job_ptr->node_bitmap);
step_mgr.c:	if (job_ptr->next_step_id == 0) {
step_mgr.c:		if (job_ptr->details && job_ptr->details->prolog_running) {
step_mgr.c:		i_first = bit_ffs(job_ptr->node_bitmap);
step_mgr.c:			i_last  = bit_fls(job_ptr->node_bitmap);
step_mgr.c:			if (!bit_test(job_ptr->node_bitmap, i))
step_mgr.c:			if (job_ptr->bit_flags & NODE_REBOOT)
step_mgr.c:					   job_ptr->node_bitmap)) {
step_mgr.c:						job_ptr->gres_list, node_inx,
step_mgr.c:						job_ptr->job_id, NO_VAL);
step_mgr.c:						job_ptr->gres_list, node_inx,
step_mgr.c:						job_ptr->job_id, NO_VAL);
step_mgr.c:		    job_ptr->details && job_ptr->details->pn_min_memory &&
step_mgr.c:		    ((job_ptr->details->pn_min_memory & MEM_PER_CPU) == 0) &&
step_mgr.c:		     job_ptr->details->pn_min_memory)) {
step_mgr.c:						job_ptr->gres_list, node_inx,
step_mgr.c:						job_ptr->job_id, NO_VAL);
step_mgr.c:						job_ptr->gres_list, node_inx,
step_mgr.c:						job_ptr->job_id, NO_VAL);
step_mgr.c:				     job_ptr->node_cnt)) {
step_mgr.c:		if (!bit_super_set(selected_nodes, job_ptr->node_bitmap)) {
step_mgr.c:		relative_nodes = bit_pick_cnt(job_ptr->node_bitmap,
step_mgr.c:		step_iterator = list_iterator_create(job_ptr->step_list);
step_mgr.c:	if (step_spec->cpu_count && job_ptr->job_resrcs &&
step_mgr.c:	    (job_ptr->job_resrcs->cpu_array_cnt == 1) &&
step_mgr.c:	    (job_ptr->job_resrcs->cpu_array_value)) {
step_mgr.c:		     (job_ptr->job_resrcs->cpu_array_value[0] - 1)) /
step_mgr.c:		    job_ptr->job_resrcs->cpu_array_value[0];
step_mgr.c:				} else if (!bit_super_set(job_ptr->node_bitmap,
step_mgr.c:			} else if (!bit_super_set(job_ptr->node_bitmap,
step_mgr.c:			} else if (!bit_super_set(job_ptr->node_bitmap,
step_mgr.c:		bit_and(nodes_picked, job_ptr->node_bitmap);
step_mgr.c:	if (job_ptr->job_resrcs && job_ptr->job_resrcs->cpus &&
step_mgr.c:	    job_ptr->job_resrcs->node_bitmap) {
step_mgr.c:			if (!bit_test(job_ptr->job_resrcs->node_bitmap, i))
step_mgr.c:			if (!bit_test(job_ptr->node_bitmap, i) ||
step_mgr.c:				sum += job_ptr->job_resrcs->cpus[node_inx];
step_mgr.c:	job_resources_t *job_resrcs_ptr = job_ptr->job_resrcs;
step_mgr.c:		   (step_ptr->cpu_count == job_ptr->total_cpus)) {
step_mgr.c:		gres_plugin_step_alloc(step_ptr->gres_list, job_ptr->gres_list,
step_mgr.c:				rem_nodes, job_ptr->job_id,
step_mgr.c:	gres_plugin_step_state_log(step_ptr->gres_list, job_ptr->job_id,
step_mgr.c:	job_resources_t *job_resrcs_ptr = job_ptr->job_resrcs;
step_mgr.c:	job_resources_t *job_resrcs_ptr = job_ptr->job_resrcs;
step_mgr.c:		} else if (job_ptr->bit_flags & JOB_RESIZED) {
step_mgr.c:	if (!job_ptr->job_resrcs)
step_mgr.c:	for (i = 0; i < job_ptr->job_resrcs->cpu_array_cnt; i++) {
step_mgr.c:		if (cpus_per_task > job_ptr->job_resrcs->cpu_array_value[i]) {
step_mgr.c:		num_tasks -= (job_ptr->job_resrcs->cpu_array_value[i] /
step_mgr.c:			     job_ptr->job_resrcs->cpu_array_reps[i];
step_mgr.c:	job_resources_t *job_resrcs_ptr = job_ptr->job_resrcs;
step_mgr.c:	if (!job_ptr->details || !job_resrcs_ptr ||
step_mgr.c:	if ((job_ptr->details->cpu_bind_type != NO_VAL16) &&
step_mgr.c:	    (job_ptr->details->cpu_bind_type & bind_to_bits))
step_mgr.c:	bind_bits = job_ptr->details->cpu_bind_type & CPU_BIND_VERBOSE;
step_mgr.c:		job_ptr->details->cpu_bind_type = bind_bits | node_bind;
step_mgr.c:	if (job_ptr->part_ptr && job_ptr->part_ptr->cpu_bind) {
step_mgr.c:		job_ptr->details->cpu_bind_type = bind_bits |
step_mgr.c:						  job_ptr->part_ptr->cpu_bind;
step_mgr.c:	job_ptr->details->cpu_bind_type = bind_bits |
step_mgr.c:		step_specs->tres_per_step   = xstrdup(job_ptr->tres_per_job);
step_mgr.c:		step_specs->tres_per_node   = xstrdup(job_ptr->tres_per_node);
step_mgr.c:		step_specs->tres_per_socket = xstrdup(job_ptr->tres_per_socket);
step_mgr.c:		step_specs->tres_per_task   = xstrdup(job_ptr->tres_per_task);
step_mgr.c:	if (step_specs->user_id != job_ptr->user_id)
step_mgr.c:	if ((job_ptr->details == NULL) || IS_JOB_SUSPENDED(job_ptr))
step_mgr.c:	    ((job_ptr->end_time <= time(NULL)) && !IS_JOB_CONFIGURING(job_ptr)))
step_mgr.c:	if (job_ptr->next_step_id >= slurmctld_conf.max_step_cnt)
step_mgr.c:					    job_ptr->gres_list, job_ptr->job_id,
step_mgr.c:	job_ptr->time_last_active = now;
step_mgr.c:		job_ptr->next_step_id = MAX(job_ptr->next_step_id,
step_mgr.c:		job_ptr->next_step_id++;
step_mgr.c:	} else if (job_ptr->pack_job_id &&
step_mgr.c:		   (job_ptr->pack_job_id != job_ptr->job_id)) {
step_mgr.c:		pack_job = find_job_record(job_ptr->pack_job_id);
step_mgr.c:			step_ptr->step_id = job_ptr->next_step_id++;
step_mgr.c:		job_ptr->next_step_id = MAX(job_ptr->next_step_id,
step_mgr.c:		step_ptr->step_id = job_ptr->next_step_id++;
step_mgr.c:	gres_plugin_step_state_log(step_ptr->gres_list, job_ptr->job_id,
step_mgr.c:		step_ptr->cpu_freq_min = job_ptr->details->cpu_freq_min;
step_mgr.c:		step_ptr->cpu_freq_max = job_ptr->details->cpu_freq_max;
step_mgr.c:		step_ptr->cpu_freq_gov = job_ptr->details->cpu_freq_gov;
step_mgr.c:		step_ptr->name = xstrdup(job_ptr->name);
step_mgr.c:		step_ptr->network = xstrdup(job_ptr->network);
step_mgr.c:		if ((step_specs->time_limit > job_ptr->part_ptr->max_time) &&
step_mgr.c:			     job_ptr->part_ptr->max_time);
step_mgr.c:	if (job_ptr->pack_job_id && (job_ptr->pack_job_id != NO_VAL)) {
step_mgr.c:		jobid = job_ptr->pack_job_id;
step_mgr.c:		if (job_ptr->job_id == job_ptr->pack_job_id) {
step_mgr.c:				job_ptr->pack_job_list);
step_mgr.c:				hostlist_push(hl, het_job_ptr->nodes);
step_mgr.c:				find_job_pack_record(job_ptr->pack_job_id, 0);
step_mgr.c:				list_iterator_create(het_job_ptr->step_list);
step_mgr.c:		jobid = job_ptr->job_id;
step_mgr.c:	jobid = job_ptr->job_id;
step_mgr.c:	if (!with_slurmdbd && !job_ptr->db_index)
step_mgr.c:	job_resources_t *job_resrcs_ptr = job_ptr->job_resrcs;
step_mgr.c:	if (step_ptr->job_ptr->front_end_ptr &&
step_mgr.c:	     step_ptr->job_ptr->front_end_ptr->protocol_version))
step_mgr.c:			step_ptr->job_ptr->front_end_ptr->protocol_version;
step_mgr.c:	if (job_ptr->details && job_ptr->details->mc_ptr) {
step_mgr.c:		multi_core_data_t *mc_ptr = job_ptr->details->mc_ptr;
step_mgr.c:	first_bit = bit_ffs(job_ptr->node_bitmap);
step_mgr.c:		last_bit = bit_fls(job_ptr->node_bitmap);
step_mgr.c:		if (!bit_test(job_ptr->node_bitmap, i))
step_mgr.c:			    && (job_ptr->details &&
step_mgr.c:				(job_ptr->details->cpu_bind_type != NO_VAL16)
step_mgr.c:				&& (job_ptr->details->cpu_bind_type
step_mgr.c:							job_ptr->gres_list,
step_mgr.c:							job_ptr->job_id,
step_mgr.c:	task_cnt = step_ptr->job_ptr->cpu_cnt;
step_mgr.c:	node_list = step_ptr->job_ptr->nodes;
step_mgr.c:	pack_bitstr = step_ptr->job_ptr->node_bitmap;
step_mgr.c:	if (step_ptr->job_ptr->total_cpus)
step_mgr.c:		cpu_cnt = step_ptr->job_ptr->total_cpus;
step_mgr.c:	else if (step_ptr->job_ptr->details)
step_mgr.c:		cpu_cnt = step_ptr->job_ptr->details->min_cpus;
step_mgr.c:		cpu_cnt = step_ptr->job_ptr->cpu_cnt;
step_mgr.c:		node_list = step_ptr->job_ptr->nodes;
step_mgr.c:		pack32(step_ptr->job_ptr->array_job_id, buffer);
step_mgr.c:		pack32(step_ptr->job_ptr->array_task_id, buffer);
step_mgr.c:		pack32(step_ptr->job_ptr->job_id, buffer);
step_mgr.c:		pack32(step_ptr->job_ptr->user_id, buffer);
step_mgr.c:					 step_ptr->job_ptr->suspend_time);
step_mgr.c:		if (step_ptr->job_ptr->part_ptr)
step_mgr.c:			packstr(step_ptr->job_ptr->part_ptr->name, buffer);
step_mgr.c:			packstr(step_ptr->job_ptr->partition, buffer);
step_mgr.c:		pack32(step_ptr->job_ptr->array_job_id, buffer);
step_mgr.c:		pack32(step_ptr->job_ptr->array_task_id, buffer);
step_mgr.c:		pack32(step_ptr->job_ptr->job_id, buffer);
step_mgr.c:		pack32(step_ptr->job_ptr->user_id, buffer);
step_mgr.c:					 step_ptr->job_ptr->suspend_time);
step_mgr.c:		if (step_ptr->job_ptr->part_ptr)
step_mgr.c:			packstr(step_ptr->job_ptr->part_ptr->name, buffer);
step_mgr.c:			packstr(step_ptr->job_ptr->partition, buffer);
step_mgr.c:		if ((job_id != NO_VAL) && (job_id != job_ptr->job_id) &&
step_mgr.c:		    (job_id != job_ptr->array_job_id))
step_mgr.c:		    (job_ptr->part_ptr) && !part_is_visible(job_ptr->part_ptr, uid))
step_mgr.c:		    (job_ptr->user_id != uid) && !validate_operator(uid) &&
step_mgr.c:						    job_ptr->account)) ||
step_mgr.c:		      (mcs_g_check_mcs_label(uid, job_ptr->mcs_label) != 0))))
step_mgr.c:		step_iterator = list_iterator_create(job_ptr->step_list);
step_mgr.c:	step_iterator = list_iterator_create (job_ptr->step_list);
step_mgr.c:		req.job_id = job_ptr->job_id;
step_mgr.c:	if ((uid != job_ptr->user_id) && (uid != 0)) {
step_mgr.c:		xstrfmtcat(ckpt_ptr->image_dir, "/%u.%u", job_ptr->job_id,
step_mgr.c:	if ((uid != job_ptr->user_id) && (uid != 0)) {
step_mgr.c:	if ((uid != job_ptr->user_id) && (uid != 0)) {
step_mgr.c:	if (job_ptr->job_state == JOB_PENDING) {
step_mgr.c:	if ((!validate_slurm_user(uid)) && (uid != job_ptr->user_id)) {
step_mgr.c:	    step_ptr->job_ptr->job_resrcs) {
step_mgr.c:		if (step_ptr->job_ptr->job_resrcs->cpus)
step_mgr.c:			cpu_count = step_ptr->job_ptr->job_resrcs->cpus[0];
step_mgr.c:		if (step_ptr->job_ptr->job_resrcs->memory_allocated)
step_mgr.c:			mem_count = step_ptr->job_ptr->job_resrcs->
step_mgr.c:		   step_ptr->job_ptr->tres_alloc_str) {
step_mgr.c:			xstrdup(step_ptr->job_ptr->tres_alloc_str);
step_mgr.c:				xstrdup(step_ptr->job_ptr->tres_fmt_alloc_str);
step_mgr.c:			cpu_count = (uint64_t)step_ptr->job_ptr->total_cpus;
step_mgr.c:	step_iterator = list_iterator_create(job_ptr->step_list);
step_mgr.c:	if ((job_ptr->suspend_time)
step_mgr.c:	&&  (job_ptr->suspend_time > step_ptr->start_time)) {
step_mgr.c:			difftime(now, job_ptr->suspend_time);
step_mgr.c:	step_iterator = list_iterator_create (job_ptr->step_list);
step_mgr.c:	if ((job_ptr->suspend_time) &&
step_mgr.c:	    (job_ptr->suspend_time < step_ptr->start_time)) {
step_mgr.c:			difftime(now, job_ptr->suspend_time);
step_mgr.c:	step_iterator = list_iterator_create (job_ptr->step_list);
step_mgr.c:					   step_ptr->job_ptr->job_id,
step_mgr.c:						  job_ptr->job_id, step_id,
step_mgr.c:						  job_ptr->job_id, step_id,
step_mgr.c:		if (job_ptr->batch_flag &&
step_mgr.c:		    (job_ptr->ckpt_interval != 0)) { /* periodic job ckpt */
step_mgr.c:			ckpt_due = job_ptr->ckpt_time +
step_mgr.c:				   (job_ptr->ckpt_interval * 60);
step_mgr.c:			ckpt_due = job_ptr->start_time +
step_mgr.c:				   (job_ptr->ckpt_interval * 60);
step_mgr.c:			ckpt_req.job_id = job_ptr->job_id;
step_mgr.c:			job_ptr->ckpt_time = now;
step_mgr.c:		step_iterator = list_iterator_create (job_ptr->step_list);
step_mgr.c:			xstrfmtcat(image_dir, "/%u.%u", job_ptr->job_id,
step_mgr.c:			(void) checkpoint_op(job_ptr->job_id,
step_mgr.c:	kill_step->job_id    = job_ptr->job_id;
step_mgr.c:	kill_step->pack_jobid = job_ptr->pack_job_id;
step_mgr.c:	kill_step->job_state = job_ptr->job_state;
step_mgr.c:	kill_step->job_uid   = job_ptr->user_id;
step_mgr.c:	kill_step->nodes     = xstrdup(job_ptr->nodes);
step_mgr.c:	kill_step->start_time = job_ptr->start_time;
step_mgr.c:			job_ptr->select_jobinfo);
step_mgr.c:	xassert(job_ptr->batch_host);
step_mgr.c:	if (job_ptr->front_end_ptr)
step_mgr.c:			job_ptr->front_end_ptr->protocol_version;
step_mgr.c:	hostlist_push_host(agent_args->hostlist, job_ptr->batch_host);
step_mgr.c:	if (job_ptr->job_state != JOB_RUNNING)
step_mgr.c:	step_iterator = list_iterator_create (job_ptr->step_list);
step_mgr.c:				bit_copy(job_ptr->node_bitmap);
step_mgr.c:				job_ptr->next_step_id++;
step_mgr.c:			if (req->step_id >= job_ptr->next_step_id)
step_mgr.c:	} else if ((job_ptr->user_id != uid) && !validate_operator(uid) &&
step_mgr.c:						 job_ptr->account)) {
step_mgr.c:		step_iterator = list_iterator_create(job_ptr->step_list);
step_mgr.c:	if (job_ptr->step_list == NULL)
step_mgr.c:	step_iterator = list_iterator_create(job_ptr->step_list);
step_mgr.c:					job_ptr->job_resrcs->node_bitmap);
step_mgr.c:		i_size = bit_size(job_ptr->job_resrcs->core_bitmap);
step_mgr.c:			      bit_ffs(job_ptr->job_resrcs->node_bitmap));
step_mgr.c:			      bit_fls(job_ptr->job_resrcs->node_bitmap));
step_mgr.c:			new_node_set = bit_test(job_ptr->job_resrcs->
step_mgr.c:					bit_set(job_ptr->job_resrcs->
step_mgr.c: * the job_ptr->step_list so make sure you don't call this if you are
step_mgr.c:				 job_ptr->gres_list, job_ptr->job_id,
step_mgr.c:	node_list = job_ptr->front_end_ptr->name;
step_mgr.c:	node_list = job_ptr->nodes;
step_mgr.c:	node_cnt = job_ptr->node_cnt;
step_mgr.c:	step_ptr->start_time = job_ptr->start_time;
step_mgr.c:	if (job_ptr->node_bitmap)
step_mgr.c:			bit_copy(job_ptr->node_bitmap);
step_mgr.c:		job_ptr->batch_host, NULL, NULL, 1, 1);
step_mgr.c:	step_ptr->start_time = job_ptr->start_time;
step_mgr.c:	if (node_name2bitmap(job_ptr->batch_host, false,
step_mgr.c:		      __func__, job_ptr, job_ptr->batch_host);
Binary file srun_comm.o matches
